{"version":3,"sources":["webpack://decon/./node_modules/events/events.js","webpack://decon/./node_modules/immediate/lib/index.js","webpack://decon/./node_modules/immediate/lib/messageChannel.js","webpack://decon/./node_modules/immediate/lib/mutation.js","webpack://decon/./node_modules/immediate/lib/queueMicrotask.js","webpack://decon/./node_modules/immediate/lib/stateChange.js","webpack://decon/./node_modules/immediate/lib/timeout.js","webpack://decon/./node_modules/spark-md5/spark-md5.js","webpack://decon/./node_modules/uuid/dist/esm-browser/rng.js","webpack://decon/./node_modules/uuid/dist/esm-browser/regex.js","webpack://decon/./node_modules/uuid/dist/esm-browser/validate.js","webpack://decon/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://decon/./node_modules/uuid/dist/esm-browser/v4.js","webpack://decon/./node_modules/pouchdb-browser/lib/index.es.js","webpack://decon/./node_modules/pouchdb-errors/lib/index.es.js","webpack://decon/./node_modules/pouchdb-fetch/lib/index-browser.es.js","webpack://decon/./node_modules/pouchdb-collections/lib/index.es.js","webpack://decon/./node_modules/pouchdb-binary-utils/lib/index-browser.es.js","webpack://decon/./node_modules/pouchdb-collate/lib/index.es.js","webpack://decon/./node_modules/pouchdb-md5/lib/index-browser.es.js","webpack://decon/./node_modules/pouchdb-utils/lib/index-browser.es.js","webpack://decon/./node_modules/pouchdb-mapreduce-utils/lib/index.es.js","webpack://decon/./node_modules/pouchdb-abstract-mapreduce/lib/index.es.js","webpack://decon/./node_modules/pouchdb-selector-core/lib/index.es.js","webpack://decon/./node_modules/pouchdb-find/lib/index-browser.es.js","webpack://decon/./src/db/dbConnection.ts","webpack://decon/./node_modules/vuvuzela/index.js","webpack://decon/./node_modules/workbox-core/_version.js","webpack://decon/./node_modules/workbox-precaching/_version.js","webpack://decon/./node_modules/workbox-routing/_version.js","webpack://decon/./node_modules/workbox-strategies/_version.js","webpack://decon/webpack/bootstrap","webpack://decon/webpack/runtime/compat get default export","webpack://decon/webpack/runtime/define property getters","webpack://decon/webpack/runtime/global","webpack://decon/webpack/runtime/hasOwnProperty shorthand","webpack://decon/webpack/runtime/make namespace object","webpack://decon/./node_modules/workbox-core/models/messages/messages.js","webpack://decon/./node_modules/workbox-core/models/messages/messageGenerator.js","webpack://decon/./node_modules/workbox-core/_private/WorkboxError.js","webpack://decon/./node_modules/workbox-core/_private/assert.js","webpack://decon/./node_modules/workbox-core/_private/cacheNames.js","webpack://decon/./node_modules/workbox-core/_private/waitUntil.js","webpack://decon/./node_modules/workbox-precaching/utils/createCacheKey.js","webpack://decon/./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js","webpack://decon/./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js","webpack://decon/./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js","webpack://decon/./node_modules/workbox-core/copyResponse.js","webpack://decon/./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js","webpack://decon/./node_modules/workbox-core/_private/Deferred.js","webpack://decon/./node_modules/workbox-core/models/quotaErrorCallbacks.js","webpack://decon/./node_modules/workbox-strategies/StrategyHandler.js","webpack://decon/./node_modules/workbox-core/_private/timeout.js","webpack://decon/./node_modules/workbox-core/_private/getFriendlyURL.js","webpack://decon/./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js","webpack://decon/./node_modules/workbox-strategies/Strategy.js","webpack://decon/./node_modules/workbox-precaching/PrecacheStrategy.js","webpack://decon/./node_modules/workbox-precaching/PrecacheController.js","webpack://decon/./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js","webpack://decon/./node_modules/workbox-routing/utils/constants.js","webpack://decon/./node_modules/workbox-routing/utils/normalizeHandler.js","webpack://decon/./node_modules/workbox-routing/Route.js","webpack://decon/./node_modules/workbox-routing/RegExpRoute.js","webpack://decon/./node_modules/workbox-routing/Router.js","webpack://decon/./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js","webpack://decon/./node_modules/workbox-precaching/PrecacheRoute.js","webpack://decon/./node_modules/workbox-precaching/utils/generateURLVariations.js","webpack://decon/./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js","webpack://decon/./node_modules/workbox-precaching/addRoute.js","webpack://decon/./node_modules/workbox-routing/registerRoute.js","webpack://decon/./src/api/categories.js","webpack://decon/./src/api/config.js","webpack://decon/./src/api/locations.js","webpack://decon/./src/api/messages.ts","webpack://decon/./src/api/posts.js","webpack://decon/./src/api/subcategories.js","webpack://decon/./src/api/sublocations.js","webpack://decon/./src/api/users.ts","webpack://decon/./node_modules/workbox-precaching/precacheAndRoute.js","webpack://decon/./src/service-worker.js","webpack://decon/./node_modules/workbox-precaching/precache.js"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","module","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","draining","currentQueue","scheduleDrain","types","queueIndex","queue","scheduled","cleanUpNextTick","nextTick","timeout","setTimeout","run","clearTimeout","test","install","Item","fun","array","task","g","setImmediate","MessageChannel","func","channel","port1","onmessage","port2","postMessage","Mutation","MutationObserver","WebKitMutationObserver","handle","called","observer","element","document","createTextNode","observe","characterData","data","queueMicrotask","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","t","hex_chr","md5cycle","x","k","a","b","c","d","md5blk","s","md5blks","charCodeAt","md5blk_array","md51","tail","tmp","lo","hi","substring","toString","match","parseInt","md51_array","subarray","Uint8Array","rhex","j","hex","join","toUtf8","str","unescape","encodeURIComponent","utf8Str2ArrayBuffer","returnUInt8Array","buff","ArrayBuffer","arrayBuffer2Utf8Str","fromCharCode","concatenateArrayBuffers","first","second","result","byteLength","buffer","hexToBinaryString","bytes","substr","SparkMD5","reset","clamp","val","Math","max","min","from","to","num","targetArray","sourceArray","begin","end","append","appendBinary","contents","_buff","_length","_hash","raw","_finish","getState","hash","setState","destroy","hashBinary","content","factory","getRandomValues","rnds8","rng","crypto","msCrypto","uuid","byteToHex","offset","toLowerCase","options","buf","rnds","random","ExportedSet","ExportedMap","mangle","unmangle","Map$1","_store","Set$1","isArray","add","cloneBinaryObject","object","cloneArrayBuffer","size","webkitSlice","mangled","has","map","delete","res","forEach","cb","Symbol","Map","Set","prop","getOwnPropertyDescriptor","species","supportsMapAndSet","funcToString","objectCtorString","clone","newObject","Date","isFinite","toISOString","Blob","isBinaryObject","proto","Ctor","constructor","isPlainObject","hasOwnProperty","toPromise","self","usedCB","promise","fulfill","resp","callback","mesg","then","e","adapterFun","_closed","_destroyed","logArgs","origCallback","responseArgs","logApiCall","taskqueue","isReady","addTask","failed","pick","obj","hasLocal","MAX_NUM_CONCURRENT_REQUESTS","identityFunction","formatResultForOpenRevsGet","ok","bulkGet","db","opts","requests","docs","requestsById","request","id","numDocs","numDone","perDocResults","checkDone","results","info","allRequests","nextBatch","upTo","batch","docId","docIdx","docRequests","docOpts","open_revs","rev","filter","formatResult","param","processBatch","localStorage","setItem","getItem","hasLocalStorage","Changes","super","dbName","inprogress","eventFunction","changesOpts","changes","seq","since","cancelled","onChange","notifyLocalWindows","notify","guardedConsole","method","defaultBackOff","maxTimeout","randomNumber","explainError","status","$inject_Object_assign","assign","nextSource","nextKey","PouchError","reason","JSON","stringify","MISSING_BULK_DOCS","MISSING_DOC","REV_CONFLICT","UNKNOWN_ERROR","BAD_ARG","QUERY_PARSE_ERROR","DOC_VALIDATION","NOT_AN_OBJECT","IDB_ERROR","INVALID_REV","MISSING_STUB","CustomPouchError","names","stack","generateErrorFromResponse","filterChange","req","hasFilter","query","query_params","change","doc","filterReturn","msg","tryFilter","include_docs","attachments","att","_attachments","stub","flatten","arrs","invalidIdError","isRemote","_remote","parseDesignDocFunctionName","parts","split","normalizeDesignDocFunctionName","normalized","qName","qParser","parser","parseUri","exec","uri","encoded","indexOf","decodeURIComponent","replace","$0","$1","$2","scopeEval","source","scope","values","upsert","diffFun","catch","docRev","_rev","newDoc","_id","put","updated","tryAndPut","thisAtob","atob","thisBtoa","btoa","createBlob","properties","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","getBlob","binaryStringToArrayBuffer","bin","binStringToBluffer","binString","b64ToBluffer","b64","readAsBinaryString","blob","reader","FileReader","hasBinaryString","onloadend","binary","arrayBufferToBinaryString","readAsArrayBuffer","blobToBinaryString","blobOrBuffer","blobToBase64","base64","setImmediateShim","MD5_CHUNK_SIZE","appendBlob","start","sliceBlob","arrayBuffer","appendString","string","binaryMd5","inputIsString","chunkSize","chunks","ceil","currentChunk","next","loadNextChunk","done","rawToBase64","rev$$1","deterministic_revs","mutateableDoc","_rev_tree","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","ctx","sortByPos","collectLeaves","leaves","isLeaf","acc","sort","reverse","collectConflicts","win","conflicts","leaf","rootToLeaf","paths","history","sortByPos$1","insertSorted","item","comparator","idx","mid","low","high","binarySearch","splice","pathToTree","path","numStemmed","root","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","el","merge","depth","newTree","stemmed","stemmedRevs","revHash","stem","getTrees","isDeleted","isLocalId","processChange","changeList","style","_conflicts","Changes$1","complete","ee","onDestroy","cancel","pending","lastSeq","isCancelled","tryCatchInChangeListener","validateChanges","PouchDB","_changesFilterPlugin","validate","doChanges","continuous","live","normalize","shouldFilter","descending","limit","newPromise","_changes","update_seq","compare","left","right","yankError","compareByIdThenRev","idCompare","_revisions","doNextCompaction","_compactionQueue","last_seq","_compact","appendPurgeSeq","purgeSeq","purges","purged_infos_limit","AbstractPouchDB","_setup","post","bulkDocs","_putLocal","_deleted","_removeLocal","putDoc","_put","new_edits","oldRevId","newRevNum","newRevId","force","putAttachment","attachmentId","api","createAttachment","prevrevpos","content_type","revpos","removeAttachment","remove","docOrId","optsOrRev","was_delete","revsDiff","missing","addToMissing","revId","_getRevisionTree","missingForId","processDoc","missingObj","compactDocument","maxHeight","revTree","height","edges","prnt","edge","computeHeight","candidates","_doCompaction","compact","_getLocal","finishOpenRevs","latest","l","_get","revs_info","splittedRev","revNo","currentPath","hashIndex","indexOfRev","howMany","_revs_info","_getAttachment","getAttachment","allDocs","skip","start_key","startkey","end_key","endkey","incompatibleOpt","allDocsKeysParse","_allDocs","close","_close","_info","db_name","auto_compaction","adapter","attachmentError","charAt","attachmentNameError","atts","cleanDocs","_bulkDocs","registerDependentDatabase","dependentDb","dbOptions","__opts","view_adapter","depDB","dependentDbs","usePrefix","use_prefix","destroyDb","_destroy","localDoc","deletedMap","trueName","RegExp","prefix","all","taskId","return_docs","promises","compactedDocs","row","activeTasks","update","completed_items","onError","onComplete","total_items","_type","purge","_purge","targetRev","findPathToLeaf","TaskQueue","execute","fail","ready","createClass","klass","A","B","PouchInternal","backend","adapters","preferredAdapters","adapterName","parseAdapter","_adapter","valid","onDestroyed","from_constructor","onClosed","prepareForDestruction","AbortController","abort","f$1","fetch","h","Headers","eventEmitter","Pouch","destructListeners","_destructionListeners","dbList","setUpEventEmitter","addToPreferredAdapters","plugin","__defaults","defaults","defaultOpts","PouchWithDefaults","url","tasks","created_at","toJSON","updatedTask","mergedTask","updated_at","getFieldFromDoc","parsedField","parseField","fieldName","fields","current","ch","combinationFields","isCombinationalField","field","getKey","mergeAndedSelectors","selectors","$or","$nor","selector","matcher","$eq","entries","longest","fieldMatchers","operator","$gte","$gt","mergeGtGte","$lte","$lt","mergeLtLte","$ne","mergeNe","mergeEq","$regex","mergeRegex","mergeAndedSelectorsNested","isAndInSelector","isAnd","massageSelector","input","orOrNor","subSelector","normalizeArrayOperators","matcherItem","MIN_MAGNITUDE","MAGNITUDE_DIGITS","SEP","collate","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","ak","bk","objectCollate","Infinity","origKey","indexify","expFormat","toExponential","magnitude","neg","magString","padWith","upToLength","padding","targetLength","pad","factor","abs","parseFloat","factorStr","toFixed","numToIndexableString","toIndexableString","objKey","parseNumber","originalIdx","numAsString","magAsString","metaStack","lastMetaElement","lastElementIndex","filterInMemoryFields","rows","requestDef","inMemoryFields","rowFilter","fieldSorter","getFieldValuesAsArray","sorting","aRow","bRow","collation","createFieldSorter","every","docFieldValue","some","orMatchers","find","matchCominationalSelector","matchSelector","maybeUserOperator","userValue","subParsedField","subDocFieldValue","userOperator","matchers","fieldExists","fieldIsNotUndefined","arrayContainsValue","docFieldValueItem","modField","neValue","arraySize","arrayContainsAllValues","regexValue","regexMatch","typeMatch","filterName","view","changesHandler","doc_ids","viewName","ddoc","mapFun","views","rowsMatched","matchesSelector","filterFun","filters","toObject","reduce","version","reservedWords","dataWords","parseRevisionInfo","parseDoc","newEdits","dbOpts","nRevNum","revInfo","revisions","revisionIds","makeRevTreeFromRevisions","specialKey","preprocessString","blobType","asBinary","parseBase64","digest","preprocessAttachment","md5","preprocessBlob","updateDoc","revLimit","prev","docInfo","writeDoc","splitRev","targetPos","targetId","revExists","previousWinningRev","previouslyDeleted","isRoot","newRev","rev_map","winningRev$$1","winningRevIsDeleted","delta","processDocs","docInfos","fetchedDocs","tx","overallCallback","idsToDocs","docsDone","docsToDo","checkAllDocsDone","currentDoc","resultsIdx","docWritten","nextDoc","rootIsMissing","insertDoc","ADAPTER_VERSION","DOC_STORE","BY_SEQ_STORE","ATTACH_STORE","ATTACH_AND_SEQ_STORE","META_STORE","LOCAL_STORE","DETECT_BLOB_SUPPORT_STORE","safeJsonStringify","json","vuvuzela","idbError","evt","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","parse","safeJsonParse","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","body","asBlob","fetchAttachmentsIfNecessary","txn","attObj","objectStore","onsuccess","fetchAttachment","postProcessAttachments","attNames","compactRevs","possiblyOrphanedDigests","seqStore","attStore","attAndSeqStore","IDBKeyRange","bound","deleteOrphanedAttachments","openCursor","only","event","cursor","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","docInfoError","metaDoc","allDocsProcessed","docCountDelta","preconditionErrored","_meta","blobSupport","onAllDocsProcessed","updateDocCountIfReady","docCount","newRevIsDeleted","isUpdate","collectResults","finishDoc","attachmentSaved","getKeyReq","newAtt","saveAttachment","writeAttachments","afterPutDoc","revsToDelete","compactTree","metadataToStore","afterPutMetadata","attsAdded","attsToAdd","onerror","preventDefault","stopPropagation","insertAttachmentMappings","putReq","overallErr","docv","recv","processedAttachment","preprocessAttachments","txnResult","onabort","ontimeout","oncomplete","finish","digests","filename","verifyAttachment","attErr","verifyAttachments","numFetched","revs_limit","readMetadata","fetchExistingDocs","startTransaction","runBatchedCursor","keyRange","batchSize","onBatch","keysBatch","valuesBatch","pseudoCursor","onGetAll","onGetAllKeys","onCursor","getAll","getAllKeys","newKeyRange","lastKey","upper","upperOpen","code","lowerBound","idbAllDocs","keyRangeError","inclusiveEnd","inclusive_end","upperBound","createKeyRange","onResultsReady","updateSeq","docIdRevIndex","allDocsInner","fetchDocAsynchronously","batchValues","batchValue","batchKeys","returnVal","total_rows","onSuccess","maxKey","getMaxUpdateSeq","allDocsKeys","running","applyNext","docIds","numResults","docIdsToMetadata","onGetMetadata","docIdRev","objectStores","winningDocs","metadatas","fetchWinningDocAndMetadata","winningDoc","processMetadataAndWinningDoc","onBatchDone","filtered","blobSupportPromise","cachedDBs","openReqList","IdbPouch","action","tryCode","enqueueTask","thisCallback","idbGlobalFailureError","enrichCallbackError","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","local","range","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","onGetMetadataSeq","fetchMetadataSeq","metadataSeq","instanceId","reqOpts","historyNode","attachId","attachment","blobData","doc_count","idb_attachment_format","oldRev","oStore","oldDoc","openReq","indexedDB","deleteDatabase","cached","global","open","onupgradeneeded","oldVersion","currentTarget","migrations","migration","onversionchange","storedMetaDoc","completeSetup","storeMetaDocIfReady","instanceKey","countDocs","blob$$1","matchedChrome","navigator","userAgent","matchedEdge","checkBlobSupport","CHANGES_BATCH_SIZE","MAX_SIMULTANEOUS_REVS","CHANGES_TIMEOUT_BUFFER","DEFAULT_HEARTBEAT","supportsBulkGetMap","readAttachmentsAsBlobOrBuffer","encodeDocId","preprocessAttachments$1","getHost","protocol","hasUrlPrefix","user","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","params","HttpPouch","dbUrl","ourFetch","async","headers","credentials","nAuth","token","ua","isIE","isTrident","isEdge","isGET","shouldCacheBust","now","fetchFun","adapterFun$$1","setup","fetchJSON","response","v","setupPromise","skip_setup","encodeAttachmentId","ping","compact_running","interval","doBulkGet","doBulkGetShim","numBatches","onResult","batchNum","subOpts","supportsBulkGet","fetchAttachments","filenames","promiseFactories","doNext","runNextBatch","thisErr","pool","typeFieldDescriptor","__proto__","fetchData","docOrDocs","contentType","process","browser","paramStr","batch_size","heartbeat","requestTimeout","leftToFetch","feed","seq_interval","param_name","lastFetchedSeq","controller","aborted","fetchOpts","signal","fetched","raw_results_length","finished","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","sequentialize","promiseFactory","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","log","evalFunctionWithEval","TaskQueue$1","createView","sourceDB","reduceFun","temporary","localDocName","viewSignature","createViewSignature","cachedViews","_cachedViews","promiseForView","depDbName","fullViewName","depDbs","lastSeqDoc","persistentQueues","tempViewQueue","parseViewName","emitError","builtInReduce","_sum","_count","_stats","sumsqr","_sumsqr","mapper","reducer","ddocValidator","tryMap","tryReduce","rereduce","output","sortByKeyThenValue","y","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","checkQueryParseError","startkeyName","endkeyName","group","group_level","optionName","number","checkPositiveInteger","defaultsTo","saveKeyValues","docIdsToChangesAndEmits","seqDocId","metaDocId","defaultMetaDoc","docData","indexableKeysToKeyValues","isGenOne","keyValueDocs","getKeyValueDocs","kvDocsRes","kvDocs","oldKeys","keyValue","newKeys","kvDoc","processKeyValueDocs","getDocsToPersist","listOfDocsToPersist","docsToPersist","updatePurgeSeq","getQueue","updateView","mapResults","currentSeq","createTask","indexed_docs","progress","processNextBatch","changes_batch_size","getRecentPurges","recentPurges","uniquePurges","findIndex","entry","createDocIdsToChangesAndEmits","results_count","createIndexableKeysToKeyValues","emittedKeyValue","complexKey","updateViewInQueue","queryView","totalRows","shouldReduce","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","parsedNum","parsedStr","arrayElement","objElement","parseIndexableString","onMapResultsReady","finalResults","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","reduceView","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","queryViewInQueue","queryPromised","_query","customQuery","MAX_URL_LENGTH","keysAsString","httpQuery","updateViewOpts","view_update_changes_batch_size","finalPromiseFactory","designDocName","stale","abstractViewCleanup","_viewCleanup","customViewCleanup","httpViewCleanup","docsToViews","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","destroyPromises","localViewCleanup","coerceOptions","viewCleanup","createAbstractMapReduce","origMap","reduceFunString","builtIn","getBuiltIn","mapreduce","getDocAttachments","getDocs","src","diffs","resultDocs","bulkGetOpts","missingRev","createBulkGetOpts","bulkGetResponse","bulkGetInfo","remoteDoc","doCheckForLocalAttachments","fileHasChanged","getDocAttachmentsFromTargetOrSource","Boolean","REPLICATOR","LOWEST_SEQ","updateCheckpoint","checkpoint","session","returnValue","session_id","replicator","CheckpointerInternal","writeCheckpoint","updateTarget","updateSource","writeTargetCheckpoint","writeSourceCheckpoint","isForbiddenError","getCheckpoint","sourceDoc","targetDoc","comparisons","srcDoc","tgtDoc","compareReplicationHistory","compareReplicationLogs","sourceHistory","targetHistory","S","sourceRest","T","targetRest","hasSessionId","sessionId","props","rest","floor","Checkpointer","STARTING_BACK_OFF","generateReplicationId","queryParams","filterViewName","sortObjectPropertiesByKey","queryData","md5sum","replicate","currentBatch","repId","checkpointer","batches","pendingBatch","writingCheckpoint","changesCompleted","replicationCompleted","initial_last_seq","batches_limit","changesPending","changedDocs","start_time","docs_read","docs_written","doc_write_failures","errors","initCheckpointer","checkpointOpts","writeDocs","bulkOpts","completeReplication","errorsById","errorsNo","errorName","finishBatch","outResult","completed","getChanges","onCheckpointError","getBatchDocs","got","startNextBatch","abortReplication","processPendingBatch","immediate$$1","fatalError","end_time","retry","back_off_function","backOffSet","current_back_off","backOff","onChangesComplete","onChangesError","_abortChanges","abortChanges","startChanges","_addedListeners","Replication","_readyCalled","cleanup","toPouch","PouchConstructor","replicateWrapper","replicateRet","sync","Sync","canceled","optsPush","optsPull","pull","pushPaused","pullPaused","pullChange","direction","pushChange","pushDenied","pullDenied","pushActive","pullActive","removed","removeAll","addOneListener","out","success","replicateMethods","other","assign$2","setFieldInDoc","elem","massageCreateIndexRequest","checkFieldValueType","isHttp","received","addReceived","divisor","mod","allowed","allowedStr","requireValidation","arrayTypeComparisonOperators","equalityOperators","validateSelector","dbFetch","explain","getIndexes","deleteIndex","indexDef","subArr","mergeObjects","oneArrayIsSubArrayOfOther","arrayEquals","arr1","arr2","createMapper","isShallow","checkShallow","isSingle","createShallowSingleMapper","toEmit","createShallowMultiMapper","createDeepSingleMapper","iLen","createDeepMultiMapper","abstractMapper","mapFunDef","partial_filter_selector","abstractMapper$1","_customFindAbstractMapper","signature","fallback","massageIndexDef","getKeyFromDoc","def","getIndexes$1","indexes","language","COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","checkFieldInIndex","indexFields","userOperatorLosesPrecision","sortFieldsByIndex","userFields","aIdx","bIdx","MAX_VALUE","getInMemoryFields","coreInMemoryFields","needToFilterInMemory","getBasicInMemoryFields","getInMemoryFieldsFromNe","checkIndexFieldsMatch","sortOrder","sortMatches","selectorMatches","leftIdx","oneSetIsSubArrayOfOther","logicalMatchers","isNonLogicalMatcher","checkIndexMatches","checkFieldsLogicallySound","findBestMatchingIndex","useIndex","matchingIndexes","findMatchingIndexes","defaultIndex","defaultUsed","userFieldsMap","arrayToObject","useIndexDdoc","useIndexName","maxScore","score","indexField","getSingleFieldCoreQueryPlan","combinedOpts","newQueryOpts","inclusive_start","getSingleFieldQueryOptsFor","getMultiFieldCoreQueryPlan","getCoreQueryPlan","getDefaultQueryPlan","inclusiveStart","usingGtlt","previousKeys","previousWasEq","previousWasSame","userOperators","newOpts","getMultiFieldQueryOpts","planQuery","shouldShortCircuit","userFieldsRes","selectorFields","sortFields","rightIdx","getUserFields","use_index","coreQueryPlan","find$1","cleanedUseIndex","massageSort","validateFindRequest","getIndexesRes","queryPlan","indexToUse","noneIdSorts","sortItem","validateSort","indexes_count","reverseOptions","originalOpts","original_limit","doAllDocs","targetValue","docKey","filterInclusiveStart","warning","createIndexAsCallback","originalIndexDef","getMd5","ascFields","validateIndex","ddocId","hasInvalidLanguage","viewExists","findAsCallback","explainAsCallback","dbname","bookmark","r","getIndexesAsCallback","deleteIndexAsCallback","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","rejected","posts","socials","users","messages","guids","transactions","categories","subcategories","locations","sublocations","socialcategories","settings","initDatabase","database","insertPost","postObj","guid","insertSocial","socialObj","insertUser","userObj","findUserByName","findUserByStakeAddr","addr","stakeAddress","insertMessage","insertGuid","findGuid","insertTransaction","transactionId","findTransaction","incrementCategory","category","oldObj","incrementSocialCategory","incrementSubcategory","subcategory","incrementLocation","location","incrementSublocation","sublocation","listPosts","ts","listSocials","listMessages","listCategories","listSocialCategories","listSubcategories","listLocations","listSublocations","insertSettings","settingsObj","findSettings","clearDatabase","savedSettings","getDb","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","_","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","o","globalThis","window","toStringTag","messageGenerator","errorCode","details","_cacheNameDetails","googleAnalytics","precache","runtime","suffix","registration","_createCacheName","cacheName","userCacheName","waitUntil","asyncFn","returnPromise","createCacheKey","urlObject","URL","href","cacheKey","revision","cacheKeyURL","originalURL","searchParams","PrecacheInstallReportPlugin","updatedURLs","notUpdatedURLs","handlerWillStart","originalRequest","cachedResponseWillBeUsed","cachedResponse","Request","PrecacheCacheKeyPlugin","precacheController","cacheKeyWillBeUsed","_precacheController","getCacheKeyForURL","supportStatus","copyResponse","modifier","origin","clonedResponse","responseInit","statusText","modifiedResponseInit","testResponse","Response","canConstructResponseFromBodyStream","stripParams","fullURL","ignoreParams","strippedURL","Deferred","quotaErrorCallbacks","toRequest","StrategyHandler","strategy","_cacheKeys","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","FetchEvent","preloadResponse","possiblePreloadResponse","hasCallback","iterateCallbacks","thrownErrorMessage","pluginFilteredRequest","fetchResponse","fetchOptions","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","ms","responseToCache","_ensureResponseSafeToCache","cache","hasCacheUpdateCallback","oldResponse","strippedRequestURL","keysOptions","ignoreSearch","cacheKeys","cacheMatchIgnoreParams","executeQuotaErrorCallbacks","newResponse","statefulCallback","statefulParam","doneWaiting","pluginsUsed","Strategy","responseDone","handleAll","_getResponse","_awaitComplete","_handle","waitUntilError","PrecacheStrategy","_fallbackToNetwork","fallbackToNetwork","copyRedirectedCacheableResponsesPlugin","_handleInstall","_handleFetch","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","_useDefaultCacheabilityPluginIfNeeded","defaultPluginIndex","cacheWillUpdatePluginCount","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","redirected","PrecacheController","_urlsToCacheKeys","_urlsToCacheModes","_cacheKeysToIntegrities","activate","addToCacheList","_installAndActiveListenersAdded","urlsToWarnAbout","cacheMode","firstEntry","secondEntry","installReportPlugin","currentlyCachedRequests","expectedCacheKeys","deletedURLs","getURLsToCacheKeys","getCachedURLs","getIntegrityForCacheKey","matchPrecache","createHandlerBoundToURL","normalizeHandler","Route","setCatchHandler","catchHandler","RegExpRoute","regExp","Router","_routes","_defaultHandlerMap","routes","addFetchListener","responsePromise","handleRequest","respondWith","addCacheListener","payload","requestPromises","urlsToCache","ports","startsWith","sameOrigin","route","findMatchingRoute","_catchHandler","catchErr","matchResult","setDefaultHandler","registerRoute","unregisterRoute","routeIndex","defaultRouter","getOrCreateDefaultRouter","PrecacheRoute","urlsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","removeIgnoredSearchParams","pathname","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","addRoute","capture","captureUrl","moduleName","funcName","defaultCategories","includes","getCategories","isProd","FOLLOW_TRANSACTION_URL","WALLET_ADDRESS","KOIOS_URL","KOIOS_KEY","BLOCKFROST_URL","BLOCKFROST_KEY","METADATA_LABEL","POLLING_INTERVAL","getConfig","getLocations","srcKey","dstKey","iv","getMessages","title","price","description","getPosts","getSubcategories","getSublocations","userinfo","publicKey","getUser","__WB_MANIFEST"],"mappings":"8iBAuBA,IAOI,EAPA,EAAuB,iBAAZ,QAAuB,QAAU,KAC5C,EAAe,GAAwB,mBAAZ,EAAE,MAC7B,EAAE,MACF,SAAsB,EAAQ,EAAU,GACxC,OAAO,SAAS,UAAU,MAAM,KAAK,EAAQ,EAAU,EACzD,EAIA,EADE,GAA0B,mBAAd,EAAE,QACC,EAAE,QACV,OAAO,sBACC,SAAwB,GACvC,OAAO,OAAO,oBAAoB,GAC/B,OAAO,OAAO,sBAAsB,GACzC,EAEiB,SAAwB,GACvC,OAAO,OAAO,oBAAoB,EACpC,EAOF,IAAI,EAAc,OAAO,OAAS,SAAqB,GACrD,OAAO,GAAU,CACnB,EAEA,SAAS,IACP,EAAa,KAAK,KAAK,KACzB,CACA,EAAO,QAAU,EACjB,EAAO,QAAQ,KAwYf,SAAc,EAAS,GACrB,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,SAAS,EAAc,GACrB,EAAQ,eAAe,EAAM,GAC7B,EAAO,EACT,CAEA,SAAS,IAC+B,mBAA3B,EAAQ,gBACjB,EAAQ,eAAe,QAAS,GAElC,EAAQ,GAAG,MAAM,KAAK,WACxB,CAEA,EAA+B,EAAS,EAAM,EAAU,CAAE,MAAM,IACnD,UAAT,GAMR,SAAuC,EAAS,EAAS,GAC7B,mBAAf,EAAQ,IACjB,EAA+B,EAAS,QAAS,EAAS,EAE9D,CATM,CAA8B,EAAS,EAAe,CAAE,MAAM,GAElE,GACF,EAxZA,EAAa,aAAe,EAE5B,EAAa,UAAU,aAAU,EACjC,EAAa,UAAU,aAAe,EACtC,EAAa,UAAU,mBAAgB,EAIvC,IAAI,EAAsB,GAE1B,SAAS,EAAc,GACrB,GAAwB,mBAAb,EACT,MAAM,IAAI,UAAU,0EAA4E,EAEpG,CAoCA,SAAS,EAAiB,GACxB,YAA2B,IAAvB,EAAK,cACA,EAAa,oBACf,EAAK,aACd,CAkDA,SAAS,EAAa,EAAQ,EAAM,EAAU,GAC5C,IAAI,EACA,EACA,EAsBJ,GApBA,EAAc,QAGC,KADf,EAAS,EAAO,UAEd,EAAS,EAAO,QAAU,OAAO,OAAO,MACxC,EAAO,aAAe,SAIK,IAAvB,EAAO,cACT,EAAO,KAAK,cAAe,EACf,EAAS,SAAW,EAAS,SAAW,GAIpD,EAAS,EAAO,SAElB,EAAW,EAAO,SAGH,IAAb,EAEF,EAAW,EAAO,GAAQ,IACxB,EAAO,kBAeT,GAbwB,mBAAb,EAET,EAAW,EAAO,GAChB,EAAU,CAAC,EAAU,GAAY,CAAC,EAAU,GAErC,EACT,EAAS,QAAQ,GAEjB,EAAS,KAAK,IAIhB,EAAI,EAAiB,IACb,GAAK,EAAS,OAAS,IAAM,EAAS,OAAQ,CACpD,EAAS,QAAS,EAGlB,IAAI,EAAI,IAAI,MAAM,+CACE,EAAS,OAAS,IAAM,OAAO,GADjC,qEAIlB,EAAE,KAAO,8BACT,EAAE,QAAU,EACZ,EAAE,KAAO,EACT,EAAE,MAAQ,EAAS,OA5KnB,SAAW,QAAQ,IA8KrB,CAGF,OAAO,CACT,CAaA,SAAS,IACP,IAAK,KAAK,MAGR,OAFA,KAAK,OAAO,eAAe,KAAK,KAAM,KAAK,QAC3C,KAAK,OAAQ,EACY,IAArB,UAAU,OACL,KAAK,SAAS,KAAK,KAAK,QAC1B,KAAK,SAAS,MAAM,KAAK,OAAQ,UAE5C,CAEA,SAAS,EAAU,EAAQ,EAAM,GAC/B,IAAI,EAAQ,CAAE,OAAO,EAAO,YAAQ,EAAW,OAAQ,EAAQ,KAAM,EAAM,SAAU,GACjF,EAAU,EAAY,KAAK,GAG/B,OAFA,EAAQ,SAAW,EACnB,EAAM,OAAS,EACR,CACT,CAyHA,SAAS,EAAW,EAAQ,EAAM,GAChC,IAAI,EAAS,EAAO,QAEpB,QAAe,IAAX,EACF,MAAO,GAET,IAAI,EAAa,EAAO,GACxB,YAAmB,IAAf,EACK,GAEiB,mBAAf,EACF,EAAS,CAAC,EAAW,UAAY,GAAc,CAAC,GAElD,EAsDT,SAAyB,GAEvB,IADA,IAAI,EAAM,IAAI,MAAM,EAAI,QACf,EAAI,EAAG,EAAI,EAAI,SAAU,EAChC,EAAI,GAAK,EAAI,GAAG,UAAY,EAAI,GAElC,OAAO,CACT,CA3DI,CAAgB,GAAc,EAAW,EAAY,EAAW,OACpE,CAmBA,SAAS,EAAc,GACrB,IAAI,EAAS,KAAK,QAElB,QAAe,IAAX,EAAsB,CACxB,IAAI,EAAa,EAAO,GAExB,GAA0B,mBAAf,EACT,OAAO,EACF,QAAmB,IAAf,EACT,OAAO,EAAW,MAEtB,CAEA,OAAO,CACT,CAMA,SAAS,EAAW,EAAK,GAEvB,IADA,IAAI,EAAO,IAAI,MAAM,GACZ,EAAI,EAAG,EAAI,IAAK,EACvB,EAAK,GAAK,EAAI,GAChB,OAAO,CACT,CA2CA,SAAS,EAA+B,EAAS,EAAM,EAAU,GAC/D,GAA0B,mBAAf,EAAQ,GACb,EAAM,KACR,EAAQ,KAAK,EAAM,GAEnB,EAAQ,GAAG,EAAM,OAEd,IAAwC,mBAA7B,EAAQ,iBAYxB,MAAM,IAAI,UAAU,6EAA+E,GATnG,EAAQ,iBAAiB,GAAM,SAAS,EAAa,GAG/C,EAAM,MACR,EAAQ,oBAAoB,EAAM,GAEpC,EAAS,EACX,GAGF,CACF,CAraA,OAAO,eAAe,EAAc,sBAAuB,CACzD,YAAY,EACZ,IAAK,WACH,OAAO,CACT,EACA,IAAK,SAAS,GACZ,GAAmB,iBAAR,GAAoB,EAAM,GAAK,EAAY,GACpD,MAAM,IAAI,WAAW,kGAAoG,EAAM,KAEjI,EAAsB,CACxB,IAGF,EAAa,KAAO,gBAEG,IAAjB,KAAK,SACL,KAAK,UAAY,OAAO,eAAe,MAAM,UAC/C,KAAK,QAAU,OAAO,OAAO,MAC7B,KAAK,aAAe,GAGtB,KAAK,cAAgB,KAAK,oBAAiB,CAC7C,EAIA,EAAa,UAAU,gBAAkB,SAAyB,GAChE,GAAiB,iBAAN,GAAkB,EAAI,GAAK,EAAY,GAChD,MAAM,IAAI,WAAW,gFAAkF,EAAI,KAG7G,OADA,KAAK,cAAgB,EACd,IACT,EAQA,EAAa,UAAU,gBAAkB,WACvC,OAAO,EAAiB,KAC1B,EAEA,EAAa,UAAU,KAAO,SAAc,GAE1C,IADA,IAAI,EAAO,GACF,EAAI,EAAG,EAAI,UAAU,OAAQ,IAAK,EAAK,KAAK,UAAU,IAC/D,IAAI,EAAoB,UAAT,EAEX,EAAS,KAAK,QAClB,QAAe,IAAX,EACF,EAAW,QAA4B,IAAjB,EAAO,WAC1B,IAAK,EACR,OAAO,EAGT,GAAI,EAAS,CACX,IAAI,EAGJ,GAFI,EAAK,OAAS,IAChB,EAAK,EAAK,IACR,aAAc,MAGhB,MAAM,EAGR,IAAI,EAAM,IAAI,MAAM,oBAAsB,EAAK,KAAO,EAAG,QAAU,IAAM,KAEzE,MADA,EAAI,QAAU,EACR,CACR,CAEA,IAAI,EAAU,EAAO,GAErB,QAAgB,IAAZ,EACF,OAAO,EAET,GAAuB,mBAAZ,EACT,EAAa,EAAS,KAAM,OAE5B,KAAI,EAAM,EAAQ,OACd,EAAY,EAAW,EAAS,GACpC,IAAS,EAAI,EAAG,EAAI,IAAO,EACzB,EAAa,EAAU,GAAI,KAAM,EAHX,CAM1B,OAAO,CACT,EAgEA,EAAa,UAAU,YAAc,SAAqB,EAAM,GAC9D,OAAO,EAAa,KAAM,EAAM,GAAU,EAC5C,EAEA,EAAa,UAAU,GAAK,EAAa,UAAU,YAEnD,EAAa,UAAU,gBACnB,SAAyB,EAAM,GAC7B,OAAO,EAAa,KAAM,EAAM,GAAU,EAC5C,EAoBJ,EAAa,UAAU,KAAO,SAAc,EAAM,GAGhD,OAFA,EAAc,GACd,KAAK,GAAG,EAAM,EAAU,KAAM,EAAM,IAC7B,IACT,EAEA,EAAa,UAAU,oBACnB,SAA6B,EAAM,GAGjC,OAFA,EAAc,GACd,KAAK,gBAAgB,EAAM,EAAU,KAAM,EAAM,IAC1C,IACT,EAGJ,EAAa,UAAU,eACnB,SAAwB,EAAM,GAC5B,IAAI,EAAM,EAAQ,EAAU,EAAG,EAK/B,GAHA,EAAc,QAGC,KADf,EAAS,KAAK,SAEZ,OAAO,KAGT,QAAa,KADb,EAAO,EAAO,IAEZ,OAAO,KAET,GAAI,IAAS,GAAY,EAAK,WAAa,EACb,KAAtB,KAAK,aACT,KAAK,QAAU,OAAO,OAAO,cAEtB,EAAO,GACV,EAAO,gBACT,KAAK,KAAK,iBAAkB,EAAM,EAAK,UAAY,SAElD,GAAoB,mBAAT,EAAqB,CAGrC,IAFA,GAAY,EAEP,EAAI,EAAK,OAAS,EAAG,GAAK,EAAG,IAChC,GAAI,EAAK,KAAO,GAAY,EAAK,GAAG,WAAa,EAAU,CACzD,EAAmB,EAAK,GAAG,SAC3B,EAAW,EACX,KACF,CAGF,GAAI,EAAW,EACb,OAAO,KAEQ,IAAb,EACF,EAAK,QAiIf,SAAmB,EAAM,GACvB,KAAO,EAAQ,EAAI,EAAK,OAAQ,IAC9B,EAAK,GAAS,EAAK,EAAQ,GAC7B,EAAK,KACP,CAnIU,CAAU,EAAM,GAGE,IAAhB,EAAK,SACP,EAAO,GAAQ,EAAK,SAEQ,IAA1B,EAAO,gBACT,KAAK,KAAK,iBAAkB,EAAM,GAAoB,EAC1D,CAEA,OAAO,IACT,EAEJ,EAAa,UAAU,IAAM,EAAa,UAAU,eAEpD,EAAa,UAAU,mBACnB,SAA4B,GAC1B,IAAI,EAAW,EAAQ,EAGvB,QAAe,KADf,EAAS,KAAK,SAEZ,OAAO,KAGT,QAA8B,IAA1B,EAAO,eAUT,OATyB,IAArB,UAAU,QACZ,KAAK,QAAU,OAAO,OAAO,MAC7B,KAAK,aAAe,QACM,IAAjB,EAAO,KACY,KAAtB,KAAK,aACT,KAAK,QAAU,OAAO,OAAO,aAEtB,EAAO,IAEX,KAIT,GAAyB,IAArB,UAAU,OAAc,CAC1B,IACI,EADA,EAAO,OAAO,KAAK,GAEvB,IAAK,EAAI,EAAG,EAAI,EAAK,SAAU,EAEjB,oBADZ,EAAM,EAAK,KAEX,KAAK,mBAAmB,GAK1B,OAHA,KAAK,mBAAmB,kBACxB,KAAK,QAAU,OAAO,OAAO,MAC7B,KAAK,aAAe,EACb,IACT,CAIA,GAAyB,mBAFzB,EAAY,EAAO,IAGjB,KAAK,eAAe,EAAM,QACrB,QAAkB,IAAd,EAET,IAAK,EAAI,EAAU,OAAS,EAAG,GAAK,EAAG,IACrC,KAAK,eAAe,EAAM,EAAU,IAIxC,OAAO,IACT,EAmBJ,EAAa,UAAU,UAAY,SAAmB,GACpD,OAAO,EAAW,KAAM,GAAM,EAChC,EAEA,EAAa,UAAU,aAAe,SAAsB,GAC1D,OAAO,EAAW,KAAM,GAAM,EAChC,EAEA,EAAa,cAAgB,SAAS,EAAS,GAC7C,MAAqC,mBAA1B,EAAQ,cACV,EAAQ,cAAc,GAEtB,EAAc,KAAK,EAAS,EAEvC,EAEA,EAAa,UAAU,cAAgB,EAiBvC,EAAa,UAAU,WAAa,WAClC,OAAO,KAAK,aAAe,EAAI,EAAe,KAAK,SAAW,EAChE,8BCxaA,IAQI,EACA,EA0CA,EAnDA,EAAQ,CACV,EAAQ,KACR,EAAQ,KACR,EAAQ,KACR,EAAQ,KACR,EAAQ,KACR,EAAQ,MAIN,GAAc,EACd,EAAQ,GACR,GAAY,EAChB,SAAS,IACF,GAAa,IAGlB,GAAW,EACP,EAAa,OACf,EAAQ,EAAa,OAAO,GAE5B,GAAc,EAEZ,EAAM,QACR,IAEJ,CAGA,SAAS,IACP,IAAI,EAAJ,CAGA,GAAY,EACZ,GAAW,EAGX,IAFA,IAAI,EAAM,EAAM,OACZ,EAAU,WAAW,GAClB,GAAK,CAGV,IAFA,EAAe,EACf,EAAQ,GACD,KAAkB,EAAa,GACpC,EAAa,GAAY,MAE3B,GAAc,EACd,EAAM,EAAM,MACd,CACA,EAAe,KACf,GAAc,EACd,GAAW,EACX,aAAa,EAjBb,CAkBF,CAIA,IAFA,IAAI,GAAK,EACL,EAAM,EAAM,SACP,EAAI,GACX,GAAI,EAAM,IAAM,EAAM,GAAG,MAAQ,EAAM,GAAG,OAAQ,CAChD,EAAgB,EAAM,GAAG,QAAQ,GACjC,KACF,CAGF,SAAS,EAAK,EAAK,GACjB,KAAK,IAAM,EACX,KAAK,MAAQ,CACf,CACA,EAAK,UAAU,IAAM,WACnB,IAAI,EAAM,KAAK,IACX,EAAQ,KAAK,MACjB,OAAQ,EAAM,QACd,KAAK,EACH,OAAO,IACT,KAAK,EACH,OAAO,EAAI,EAAM,IACnB,KAAK,EACH,OAAO,EAAI,EAAM,GAAI,EAAM,IAC7B,KAAK,EACH,OAAO,EAAI,EAAM,GAAI,EAAM,GAAI,EAAM,IACvC,QACE,OAAO,EAAI,MAAM,KAAM,GAG3B,EACA,EAAO,QACP,SAAmB,GACjB,IAAI,EAAO,IAAI,MAAM,UAAU,OAAS,GACxC,GAAI,UAAU,OAAS,EACrB,IAAK,IAAI,EAAI,EAAG,EAAI,UAAU,OAAQ,IACpC,EAAK,EAAI,GAAK,UAAU,GAG5B,EAAM,KAAK,IAAI,EAAK,EAAM,IACrB,GAAc,IACjB,GAAY,EACZ,IAEJ,8BC9FA,EAAQ,KAAO,WACb,OAAI,EAAA,EAAO,mBAK6B,IAA1B,EAAA,EAAO,cACvB,EAEA,EAAQ,QAAU,SAAU,GAC1B,IAAI,EAAU,IAAI,EAAA,EAAO,eAEzB,OADA,EAAQ,MAAM,UAAY,EACnB,WACL,EAAQ,MAAM,YAAY,EAC5B,CACF,8BCZA,IAAI,EAAW,EAAA,EAAO,kBAAoB,EAAA,EAAO,uBAEjD,EAAQ,KAAO,WACb,OAAO,CACT,EAEA,EAAQ,QAAU,SAAU,GAC1B,IAAI,EAAS,EACT,EAAW,IAAI,EAAS,GACxB,EAAU,EAAA,EAAO,SAAS,eAAe,IAI7C,OAHA,EAAS,QAAQ,EAAS,CACxB,eAAe,IAEV,WACL,EAAQ,KAAQ,IAAW,EAAS,CACtC,CACF,8BCpBA,EAAQ,KAAO,WACb,MAAwC,mBAA1B,EAAA,EAAO,cACvB,EAEA,EAAQ,QAAU,SAAU,GAC1B,OAAO,WACL,EAAA,EAAO,eAAe,EACxB,CACF,8BCPA,EAAQ,KAAO,WACb,MAAO,aAAc,EAAA,GAAU,uBAAwB,EAAA,EAAO,SAAS,cAAc,SACvF,EAEA,EAAQ,QAAU,SAAU,GAC1B,OAAO,WAIL,IAAI,EAAW,EAAA,EAAO,SAAS,cAAc,UAU7C,OATA,EAAS,mBAAqB,WAC5B,IAEA,EAAS,mBAAqB,KAC9B,EAAS,WAAW,YAAY,GAChC,EAAW,IACb,EACA,EAAA,EAAO,SAAS,gBAAgB,YAAY,GAErC,CACT,CACF,4BCtBA,EAAQ,KAAO,WACb,OAAO,CACT,EAEA,EAAQ,QAAU,SAAU,GAC1B,OAAO,WACL,WAAW,EAAG,EAChB,CACF,WCNQ,EAAO,QAgBb,SAAU,GAER,aAeA,IAGI,EAAU,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAQ1F,SAAS,EAAS,EAAG,GACjB,IAAI,EAAI,EAAE,GACN,EAAI,EAAE,GACN,EAAI,EAAE,GACN,EAAI,EAAE,GASV,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,GAAK,EAAI,GAAK,EAAE,GAAK,UAAY,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,GAAK,EAAI,GAAK,EAAE,GAAK,UAAY,IAChC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,GAAK,UAAY,IAChC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,GAAK,EAAI,GAAK,EAAE,GAAK,UAAY,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,GAAK,EAAI,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,GAAK,SAAW,IAC/B,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,GAAK,EAAI,GAAK,EAAE,GAAK,WAAa,IACjC,EAAI,IAAM,IAAM,EAAI,GACrB,GAAK,EAAI,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,IAAM,MAAQ,IAC7B,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,IAAM,WAAa,IAClC,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,GAAK,EAAI,GAAK,EAAE,IAAM,WAAa,IAClC,EAAI,IAAM,IAAM,EAAI,GACrB,GAAK,EAAI,GAAK,EAAE,IAAM,SAAW,IAChC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,IAAM,WAAa,IAClC,GAAK,IAAM,IAAM,EAAI,GACtB,GAAK,EAAI,GAAK,EAAE,IAAM,WAAa,IAClC,GAAK,IAAM,IAAM,EAAI,EAShC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,GAAK,WAAa,IACjC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,IAAM,UAAY,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,IAAM,SAAW,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,IAAM,UAAY,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,IAAM,WAAa,IAClC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,GAAK,UAAY,IAChC,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,EAQhC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,GAAK,EAAE,IAAM,WAAa,IAClC,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,GAAK,SAAW,IAC/B,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,GAAK,EAAE,GAAK,WAAa,IACjC,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,GAAK,EAAE,IAAM,WAAa,IAClC,GAAK,IAAM,IAAM,EAAI,EAShC,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,EAAE,GAAK,OAAS,IACxB,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,EAAE,GAAK,WAAa,IAC5B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,IAAM,WAAa,IAC7B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,IAAM,SAAW,IAC3B,GAAK,IAAM,GAAK,EAAI,EAQ/B,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,EAAE,GAAK,WAAa,IAC5B,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,EAAE,GAAK,WAAa,IAC5B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,GAAK,UAAY,IAC3B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,IAAM,WAAa,IAC7B,GAAK,IAAM,GAAK,EAAI,EAQ/B,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,EAAE,IAAM,UAAY,IAC5B,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,EAAE,GAAK,UAAY,IAC3B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,GAAK,UAAY,IAC3B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,GAAK,SAAW,IAC1B,GAAK,IAAM,GAAK,EAAI,EAQ/B,IADA,KADA,IADA,KADA,IADA,KADA,IADA,IAAM,EAAI,EAAI,GAAK,EAAE,GAAK,UAAY,IAC3B,EAAI,IAAM,IAAM,EAAI,GACrB,EAAI,GAAK,EAAE,IAAM,UAAY,IAC5B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,IAAM,UAAY,IAC5B,GAAK,IAAM,IAAM,EAAI,GACtB,EAAI,GAAK,EAAE,GAAK,UAAY,IAC3B,GAAK,IAAM,GAAK,EAAI,EAS/B,IADA,KAHA,IADA,IAAM,IADN,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,GAAK,UAAY,IAC9B,EAAI,IAAM,IAAM,EAAI,IACf,IAAM,EAAE,GAAK,WAAa,IAC/B,GAAK,IAAM,IAAM,EAAI,KAEhC,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,IAAM,WAAa,IAChC,GAAK,IAAM,IAAM,EAAI,IAChB,IAAM,EAAE,GAAK,SAAW,IAC7B,GAAI,IAAM,IAAM,EAAI,EAQ/B,IADA,KAHA,IADA,IAAM,IADN,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,IAAM,WAAa,IAChC,EAAI,IAAM,IAAM,EAAI,IACf,IAAM,EAAE,GAAK,WAAa,IAC/B,GAAK,IAAM,IAAM,EAAI,KAEhC,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,IAAM,QAAU,IAC7B,GAAK,IAAM,IAAM,EAAI,IAChB,IAAM,EAAE,GAAK,WAAa,IAC/B,GAAI,IAAM,IAAM,EAAI,EAQ/B,IADA,KAHA,IADA,IAAM,IADN,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,GAAK,WAAa,IAC/B,EAAI,IAAM,IAAM,EAAI,IACf,IAAM,EAAE,IAAM,SAAW,IAC9B,GAAK,IAAM,IAAM,EAAI,KAEhC,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,GAAK,WAAa,IAC/B,GAAK,IAAM,IAAM,EAAI,IAChB,IAAM,EAAE,IAAM,WAAa,IAChC,GAAI,IAAM,IAAM,EAAI,EAQ/B,IADA,KAHA,IADA,IAAM,IADN,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,GAAK,UAAY,IAC9B,EAAI,IAAM,IAAM,EAAI,IACf,IAAM,EAAE,IAAM,WAAa,IAChC,GAAK,IAAM,IAAM,EAAI,KAEhC,IADA,IAAM,GAAK,GAAK,IAAM,EAAE,GAAK,UAAY,IAC9B,GAAK,IAAM,IAAM,EAAI,IAChB,IAAM,EAAE,GAAK,UAAY,IAC9B,GAAK,IAAM,IAAM,EAAI,EAEhC,EAAE,GAAK,EAAI,EAAE,GAAK,EAClB,EAAE,GAAK,EAAI,EAAE,GAAK,EAClB,EAAE,GAAK,EAAI,EAAE,GAAK,EAClB,EAAE,GAAK,EAAI,EAAE,GAAK,CACtB,CAEA,SAAS,EAAO,GACZ,IACI,EADA,EAAU,GAGd,IAAK,EAAI,EAAG,EAAI,GAAI,GAAK,EACrB,EAAQ,GAAK,GAAK,EAAE,WAAW,IAAM,EAAE,WAAW,EAAI,IAAM,IAAM,EAAE,WAAW,EAAI,IAAM,KAAO,EAAE,WAAW,EAAI,IAAM,IAE3H,OAAO,CACX,CAEA,SAAS,EAAa,GAClB,IACI,EADA,EAAU,GAGd,IAAK,EAAI,EAAG,EAAI,GAAI,GAAK,EACrB,EAAQ,GAAK,GAAK,EAAE,IAAM,EAAE,EAAI,IAAM,IAAM,EAAE,EAAI,IAAM,KAAO,EAAE,EAAI,IAAM,IAE/E,OAAO,CACX,CAEA,SAAS,EAAK,GACV,IAEI,EACA,EACA,EACA,EACA,EACA,EAPA,EAAI,EAAE,OACN,EAAQ,CAAC,YAAa,WAAY,WAAY,WAQlD,IAAK,EAAI,GAAI,GAAK,EAAG,GAAK,GACtB,EAAS,EAAO,EAAO,EAAE,UAAU,EAAI,GAAI,KAK/C,IAFA,GADA,EAAI,EAAE,UAAU,EAAI,KACT,OACX,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChD,EAAI,EAAG,EAAI,EAAQ,GAAK,EACzB,EAAK,GAAK,IAAM,EAAE,WAAW,KAAQ,EAAI,GAAM,GAGnD,GADA,EAAK,GAAK,IAAM,MAAU,EAAI,GAAM,GAChC,EAAI,GAEJ,IADA,EAAS,EAAO,GACX,EAAI,EAAG,EAAI,GAAI,GAAK,EACrB,EAAK,GAAK,EAclB,OARA,GADA,EAAU,EAAJ,GACI,SAAS,IAAI,MAAM,kBAC7B,EAAK,SAAS,EAAI,GAAI,IACtB,EAAK,SAAS,EAAI,GAAI,KAAO,EAE7B,EAAK,IAAM,EACX,EAAK,IAAM,EAEX,EAAS,EAAO,GACT,CACX,CAEA,SAAS,EAAW,GAChB,IAEI,EACA,EACA,EACA,EACA,EACA,EAPA,EAAI,EAAE,OACN,EAAQ,CAAC,YAAa,WAAY,WAAY,WAQlD,IAAK,EAAI,GAAI,GAAK,EAAG,GAAK,GACtB,EAAS,EAAO,EAAa,EAAE,SAAS,EAAI,GAAI,KAWpD,IAFA,GAFA,EAAK,EAAI,GAAM,EAAI,EAAE,SAAS,EAAI,IAAM,IAAI,WAAW,IAE5C,OACX,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChD,EAAI,EAAG,EAAI,EAAQ,GAAK,EACzB,EAAK,GAAK,IAAM,EAAE,KAAQ,EAAI,GAAM,GAIxC,GADA,EAAK,GAAK,IAAM,MAAU,EAAI,GAAM,GAChC,EAAI,GAEJ,IADA,EAAS,EAAO,GACX,EAAI,EAAG,EAAI,GAAI,GAAK,EACrB,EAAK,GAAK,EAelB,OATA,GADA,EAAU,EAAJ,GACI,SAAS,IAAI,MAAM,kBAC7B,EAAK,SAAS,EAAI,GAAI,IACtB,EAAK,SAAS,EAAI,GAAI,KAAO,EAE7B,EAAK,IAAM,EACX,EAAK,IAAM,EAEX,EAAS,EAAO,GAET,CACX,CAEA,SAAS,EAAK,GACV,IACI,EADA,EAAI,GAER,IAAK,EAAI,EAAG,EAAI,EAAG,GAAK,EACpB,GAAK,EAAS,GAAU,EAAJ,EAAQ,EAAM,IAAQ,EAAS,GAAU,EAAJ,EAAU,IAEvE,OAAO,CACX,CAEA,SAAS,EAAI,GACT,IAAI,EACJ,IAAK,EAAI,EAAG,EAAI,EAAE,OAAQ,GAAK,EAC3B,EAAE,GAAK,EAAK,EAAE,IAElB,OAAO,EAAE,KAAK,GAClB,CAkEA,SAAS,EAAO,GAKZ,MAJI,kBAAkB,KAAK,KACvB,EAAM,SAAS,mBAAmB,KAG/B,CACX,CAEA,SAAS,EAAoB,EAAK,GAC9B,IAGG,EAHC,EAAS,EAAI,OACd,EAAO,IAAI,YAAY,GACvB,EAAM,IAAI,WAAW,GAGxB,IAAK,EAAI,EAAG,EAAI,EAAQ,GAAK,EACzB,EAAI,GAAK,EAAI,WAAW,GAG5B,OAAO,EAAmB,EAAM,CACpC,CAEA,SAAS,EAAoB,GACzB,OAAO,OAAO,aAAa,MAAM,KAAM,IAAI,WAAW,GAC1D,CAEA,SAAS,EAAwB,EAAO,EAAQ,GAC5C,IAAI,EAAS,IAAI,WAAW,EAAM,WAAa,EAAO,YAKtD,OAHA,EAAO,IAAI,IAAI,WAAW,IAC1B,EAAO,IAAI,IAAI,WAAW,GAAS,EAAM,YAElC,EAAmB,EAAS,EAAO,MAC9C,CAEA,SAAS,EAAkB,GACvB,IAEI,EAFA,EAAQ,GACR,EAAS,EAAI,OAGjB,IAAK,EAAI,EAAG,EAAI,EAAS,EAAG,GAAK,EAC7B,EAAM,KAAK,SAAS,EAAI,OAAO,EAAG,GAAI,KAG1C,OAAO,OAAO,aAAa,MAAM,OAAQ,EAC7C,CAWA,SAAS,IAEL,KAAK,OACT,CAuTA,OAhbI,EAAI,EAAK,UAgBc,oBAAhB,aAAgC,YAAY,UAAU,OAC7D,WACI,SAAS,EAAM,EAAK,GAGhB,OAFA,EAAa,EAAN,GAAY,GAET,EACC,KAAK,IAAI,EAAM,EAAQ,GAG3B,KAAK,IAAI,EAAK,EACzB,CAEA,YAAY,UAAU,MAAQ,SAAU,EAAM,GAC1C,IAGI,EACA,EACA,EACA,EANA,EAAS,KAAK,WACd,EAAQ,EAAM,EAAM,GACpB,EAAM,EAUV,OAJI,IAAO,IACP,EAAM,EAAM,EAAI,IAGhB,EAAQ,EACD,IAAI,YAAY,IAG3B,EAAM,EAAM,EACZ,EAAS,IAAI,YAAY,GACzB,EAAc,IAAI,WAAW,GAE7B,EAAc,IAAI,WAAW,KAAM,EAAO,GAC1C,EAAY,IAAI,GAET,EACX,CACH,CArCD,GAkHJ,EAAS,UAAU,OAAS,SAAU,GAKlC,OAFA,KAAK,aAAa,EAAO,IAElB,IACX,EASA,EAAS,UAAU,aAAe,SAAU,GACxC,KAAK,OAAS,EACd,KAAK,SAAW,EAAS,OAEzB,IACI,EADA,EAAS,KAAK,MAAM,OAGxB,IAAK,EAAI,GAAI,GAAK,EAAQ,GAAK,GAC3B,EAAS,KAAK,MAAO,EAAO,KAAK,MAAM,UAAU,EAAI,GAAI,KAK7D,OAFA,KAAK,MAAQ,KAAK,MAAM,UAAU,EAAI,IAE/B,IACX,EAUA,EAAS,UAAU,IAAM,SAAU,GAC/B,IAEI,EAEA,EAJA,EAAO,KAAK,MACZ,EAAS,EAAK,OAEd,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGzD,IAAK,EAAI,EAAG,EAAI,EAAQ,GAAK,EACzB,EAAK,GAAK,IAAM,EAAK,WAAW,KAAQ,EAAI,GAAM,GAYtD,OATA,KAAK,QAAQ,EAAM,GACnB,EAAM,EAAI,KAAK,OAEX,IACA,EAAM,EAAkB,IAG5B,KAAK,QAEE,CACX,EAOA,EAAS,UAAU,MAAQ,WAKvB,OAJA,KAAK,MAAQ,GACb,KAAK,QAAU,EACf,KAAK,MAAQ,CAAC,YAAa,WAAY,WAAY,WAE5C,IACX,EAOA,EAAS,UAAU,SAAW,WAC1B,MAAO,CACH,KAAM,KAAK,MACX,OAAQ,KAAK,QACb,KAAM,KAAK,MAAM,QAEzB,EASA,EAAS,UAAU,SAAW,SAAU,GAKpC,OAJA,KAAK,MAAQ,EAAM,KACnB,KAAK,QAAU,EAAM,OACrB,KAAK,MAAQ,EAAM,KAEZ,IACX,EAMA,EAAS,UAAU,QAAU,kBAClB,KAAK,aACL,KAAK,aACL,KAAK,OAChB,EAQA,EAAS,UAAU,QAAU,SAAU,EAAM,GACzC,IACI,EACA,EACA,EAHA,EAAI,EAMR,GADA,EAAK,GAAK,IAAM,MAAU,EAAI,GAAM,GAChC,EAAI,GAEJ,IADA,EAAS,KAAK,MAAO,GAChB,EAAI,EAAG,EAAI,GAAI,GAAK,EACrB,EAAK,GAAK,EAOlB,GADA,EAAqB,EAAf,KAAK,SACD,SAAS,IAAI,MAAM,kBAC7B,EAAK,SAAS,EAAI,GAAI,IACtB,EAAK,SAAS,EAAI,GAAI,KAAO,EAE7B,EAAK,IAAM,EACX,EAAK,IAAM,EACX,EAAS,KAAK,MAAO,EACzB,EAWA,EAAS,KAAO,SAAU,EAAK,GAG3B,OAAO,EAAS,WAAW,EAAO,GAAM,EAC5C,EAUA,EAAS,WAAa,SAAU,EAAS,GACrC,IACI,EAAM,EADC,EAAK,IAGhB,OAAO,EAAM,EAAkB,GAAO,CAC1C,EASA,EAAS,YAAc,WAEnB,KAAK,OACT,EASA,EAAS,YAAY,UAAU,OAAS,SAAU,GAC9C,IAEI,EAFA,EAAO,EAAwB,KAAK,MAAM,OAAQ,GAAK,GACvD,EAAS,EAAK,OAKlB,IAFA,KAAK,SAAW,EAAI,WAEf,EAAI,GAAI,GAAK,EAAQ,GAAK,GAC3B,EAAS,KAAK,MAAO,EAAa,EAAK,SAAS,EAAI,GAAI,KAK5D,OAFA,KAAK,MAAS,EAAI,GAAM,EAAS,IAAI,WAAW,EAAK,OAAO,MAAM,EAAI,KAAO,IAAI,WAAW,GAErF,IACX,EAUA,EAAS,YAAY,UAAU,IAAM,SAAU,GAC3C,IAGI,EACA,EAJA,EAAO,KAAK,MACZ,EAAS,EAAK,OACd,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAIzD,IAAK,EAAI,EAAG,EAAI,EAAQ,GAAK,EACzB,EAAK,GAAK,IAAM,EAAK,KAAQ,EAAI,GAAM,GAY3C,OATA,KAAK,QAAQ,EAAM,GACnB,EAAM,EAAI,KAAK,OAEX,IACA,EAAM,EAAkB,IAG5B,KAAK,QAEE,CACX,EAOA,EAAS,YAAY,UAAU,MAAQ,WAKnC,OAJA,KAAK,MAAQ,IAAI,WAAW,GAC5B,KAAK,QAAU,EACf,KAAK,MAAQ,CAAC,YAAa,WAAY,WAAY,WAE5C,IACX,EAOA,EAAS,YAAY,UAAU,SAAW,WACtC,IAAI,EAAQ,EAAS,UAAU,SAAS,KAAK,MAK7C,OAFA,EAAM,KAAO,EAAoB,EAAM,MAEhC,CACX,EASA,EAAS,YAAY,UAAU,SAAW,SAAU,GAIhD,OAFA,EAAM,KAAO,EAAoB,EAAM,MAAM,GAEtC,EAAS,UAAU,SAAS,KAAK,KAAM,EAClD,EAEA,EAAS,YAAY,UAAU,QAAU,EAAS,UAAU,QAE5D,EAAS,YAAY,UAAU,QAAU,EAAS,UAAU,QAU5D,EAAS,YAAY,KAAO,SAAU,EAAK,GACvC,IACI,EAAM,EADC,EAAW,IAAI,WAAW,KAGrC,OAAO,EAAM,EAAkB,GAAO,CAC1C,EAEO,CACX,CA3uByB,gECArB,sCACA,EAAQ,IAAI,WAAW,IACZ,SAAS,IAEtB,IAAK,KAGH,EAAoC,oBAAX,QAA0B,OAAO,iBAAmB,OAAO,gBAAgB,KAAK,SAA+B,oBAAb,UAAgE,mBAA7B,SAAS,iBAAkC,SAAS,gBAAgB,KAAK,WAGrO,MAAM,IAAI,MAAM,4GAIpB,OAAO,EAAgB,EACzB,CClBA,8HCMA,QAJA,SAAkB,GAChB,MAAuB,iBAAT,GAAqB,EAAM,KAAK,EAChD,ECIA,IAFA,IAAI,EAAY,GAEP,EAAI,EAAG,EAAI,MAAO,EACzB,EAAU,MAAM,EAAI,KAAO,SAAS,IAAI,OAAO,IAoBjD,QAjBA,SAAmB,GACjB,IAAI,EAAS,UAAU,OAAS,QAAsB,IAAjB,UAAU,GAAmB,UAAU,GAAK,EAG7E,GAAQ,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,IAAM,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,IAAM,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,IAAM,EAAU,EAAI,EAAS,IAAM,EAAU,EAAI,EAAS,IAAM,IAAM,EAAU,EAAI,EAAS,KAAO,EAAU,EAAI,EAAS,KAAO,EAAU,EAAI,EAAS,KAAO,EAAU,EAAI,EAAS,KAAO,EAAU,EAAI,EAAS,KAAO,EAAU,EAAI,EAAS,MAAM,cAMzf,IAAK,EAAS,GACZ,MAAM,UAAU,+BAGlB,OAAO,CACT,ECJA,QApBA,SAAY,EAAS,EAAK,GAExB,IAAI,GADJ,EAAU,GAAW,CAAC,GACH,SAAW,EAAQ,KAAO,KAK7C,GAHA,EAAK,GAAe,GAAV,EAAK,GAAY,GAC3B,EAAK,GAAe,GAAV,EAAK,GAAY,IAEvB,EAAK,CACP,EAAS,GAAU,EAEnB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAM,EACxB,EAAI,EAAS,GAAK,EAAK,GAGzB,OAAO,CACT,CAEA,OAAO,EAAU,EACnB,MCuEI,EACA,6BAvFJ,SAAS,EAAO,GACd,MAAO,IAAM,CACf,CACA,SAAS,EAAS,GAChB,OAAO,EAAI,UAAU,EACvB,CACA,SAAS,IACP,KAAK,OAAS,CAAC,CACjB,CAsCA,SAAS,EAAM,GAIb,GAHA,KAAK,OAAS,IAAI,EAGd,GAAS,MAAM,QAAQ,GACzB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAM,OAAQ,EAAI,EAAK,IAC3C,KAAK,IAAI,EAAM,GAGrB,CA6DA,SAAS,EAAkB,GACzB,GAAI,aAAkB,YACpB,OAdJ,SAA0B,GACxB,GAA0B,mBAAf,EAAK,MACd,OAAO,EAAK,MAAM,GAGpB,IAAI,EAAS,IAAI,YAAY,EAAK,YAC9B,EAAc,IAAI,WAAW,GAC7B,EAAc,IAAI,WAAW,GAEjC,OADA,EAAY,IAAI,GACT,CACT,CAIW,CAAiB,GAE1B,IAAI,EAAO,EAAO,KACd,EAAO,EAAO,KAElB,MAA4B,mBAAjB,EAAO,MACT,EAAO,MAAM,EAAG,EAAM,GAGxB,EAAO,YAAY,EAAG,EAAM,EACrC,CAvHA,EAAM,UAAU,IAAM,SAAU,GAC9B,IAAI,EAAU,EAAO,GACrB,OAAO,KAAK,OAAO,EACrB,EACA,EAAM,UAAU,IAAM,SAAU,EAAK,GACnC,IAAI,EAAU,EAAO,GAErB,OADA,KAAK,OAAO,GAAW,GAChB,CACT,EACA,EAAM,UAAU,IAAM,SAAU,GAE9B,OADc,EAAO,KACH,KAAK,MACzB,EACA,EAAM,UAAU,KAAO,WACrB,OAAO,OAAO,KAAK,KAAK,QAAQ,KAAI,GAAK,EAAS,IACpD,EACA,EAAM,UAAU,OAAS,SAAU,GACjC,IAAI,EAAU,EAAO,GACjB,EAAM,KAAW,KAAK,OAE1B,cADO,KAAK,OAAO,GACZ,CACT,EACA,EAAM,UAAU,QAAU,SAAU,GAElC,IADA,IAAI,EAAO,OAAO,KAAK,KAAK,QACnB,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CAC/C,IAAI,EAAM,EAAK,GAGf,EAFY,KAAK,OAAO,GACxB,EAAM,EAAS,GAEjB,CACF,EACA,OAAO,eAAe,EAAM,UAAW,OAAQ,CAC7C,IAAK,WACH,OAAO,OAAO,KAAK,KAAK,QAAQ,MAClC,IAaF,EAAM,UAAU,IAAM,SAAU,GAC9B,OAAO,KAAK,OAAO,IAAI,GAAK,EAC9B,EACA,EAAM,UAAU,IAAM,SAAU,GAC9B,OAAO,KAAK,OAAO,IAAI,EACzB,EACA,EAAM,UAAU,QAAU,SAAU,GAClC,KAAK,OAAO,SAAQ,SAAU,EAAO,GACnC,EAAG,EACL,GACF,EACA,OAAO,eAAe,EAAM,UAAW,OAAQ,CAC7C,IAAK,WACH,OAAO,KAAK,OAAO,IACrB,KAMF,WACE,GAAsB,oBAAX,QAAyC,oBAAR,KAAsC,oBAAR,IACxE,OAAO,EAET,IAAI,EAAO,OAAO,yBAAyB,IAAK,OAAO,SACvD,OAAO,GAAQ,QAAS,GAAQ,IAAI,OAAO,WAAa,GAC1D,CAQM,IAIF,EAAc,EACd,EAAc,IAJd,EAAc,IACd,EAAc,KA0ClB,IAAI,EAAe,SAAS,UAAU,SAClC,EAAmB,EAAa,KAAK,QAazC,SAAS,EAAM,GACb,IAAI,EACA,EACA,EAEJ,IAAK,GAA4B,iBAAX,EACpB,OAAO,EAGT,GAAI,MAAM,QAAQ,GAAS,CAEzB,IADA,EAAY,GACP,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IACxC,EAAU,GAAK,EAAM,EAAO,IAE9B,OAAO,CACT,CAIA,GAAI,aAAkB,MAAQ,SAAS,GACrC,OAAO,EAAO,cAGhB,GAxEF,SAAwB,GACtB,MAA+B,oBAAhB,aAA+B,aAAkB,aAC7C,oBAAT,MAAwB,aAAkB,IACtD,CAqEM,CAAe,GACjB,OAAO,EAAkB,GAG3B,IAtCF,SAAuB,GACrB,IAAI,EAAQ,OAAO,eAAe,GAElC,GAAc,OAAV,EACF,OAAO,EAET,IAAI,EAAO,EAAM,YACjB,MAAuB,mBAAR,GACb,aAAgB,GAAQ,EAAa,KAAK,IAAS,CACvD,CA6BO,CAAc,GACjB,OAAO,EAIT,IAAK,KADL,EAAY,CAAC,EACH,EAER,GAAI,OAAO,UAAU,eAAe,KAAK,EAAQ,GAAI,CACnD,IAAI,EAAQ,EAAM,EAAO,SACJ,IAAV,IACT,EAAU,GAAK,EAEnB,CAEF,OAAO,CACT,CAEA,SAAS,EAAK,GACZ,IAAI,GAAS,EACb,OAAO,YAAa,GAElB,GAAI,EAEF,MAAM,IAAI,MAAM,8BAEhB,GAAS,EACT,EAAI,MAAM,KAAM,EAEpB,CACF,CAEA,SAAS,EAAU,GAEjB,OAAO,YAAa,GAElB,EAAO,EAAM,GACb,IAAI,EAAO,KAEP,EAA2C,mBAA1B,EAAK,EAAK,OAAS,IAAqB,EAAK,MAC9D,EAAU,IAAI,SAAQ,SAAU,EAAS,GAC3C,IAAI,EACJ,IACE,IAAI,EAAW,GAAK,SAAU,EAAK,GAC7B,EACF,EAAO,GAEP,EAAQ,EAEZ,IAGA,EAAK,KAAK,IACV,EAAO,EAAK,MAAM,EAAM,KACS,mBAAd,EAAK,MACtB,EAAQ,EAEZ,CAAE,MAAO,GACP,EAAO,EACT,CACF,IAOA,OALI,GACF,EAAQ,MAAK,SAAU,GACrB,EAAO,KAAM,EACf,GAAG,GAEE,CACT,CACF,CAwBA,SAAS,EAAW,EAAM,GACxB,OAAO,GAAU,YAAa,GAC5B,GAAI,KAAK,QACP,OAAO,QAAQ,OAAO,IAAI,MAAM,uBAElC,GAAI,KAAK,WACP,OAAO,QAAQ,OAAO,IAAI,MAAM,0BAElC,IAAI,EAAO,KAEX,OAhCJ,SAAoB,EAAM,EAAM,GAE9B,GAAI,EAAK,YAAY,UAAU,SAAS,OAAQ,CAE9C,IADA,IAAI,EAAU,CAAC,MAAO,EAAK,KAAM,GACxB,EAAI,EAAG,EAAI,EAAK,OAAS,EAAG,IACnC,EAAQ,KAAK,EAAK,IAEpB,EAAK,YAAY,KAAK,QAAS,GAG/B,IAAI,EAAe,EAAK,EAAK,OAAS,GACtC,EAAK,EAAK,OAAS,GAAK,SAAU,EAAK,GACrC,IAAI,EAAe,CAAC,MAAO,EAAK,KAAM,GACtC,EAAe,EAAa,OAC1B,EAAM,CAAC,QAAS,GAAO,CAAC,UAAW,IAErC,EAAK,YAAY,KAAK,QAAS,GAC/B,EAAa,EAAK,EACpB,CACF,CACF,CAWI,CAAW,EAAM,EAAM,GAClB,KAAK,UAAU,QAWb,EAAS,MAAM,KAAM,GAVnB,IAAI,SAAQ,SAAU,EAAS,GACpC,EAAK,UAAU,SAAQ,SAAU,GAC3B,EACF,EAAO,GAEP,EAAQ,EAAK,GAAM,MAAM,EAAM,GAEnC,GACF,GAGJ,GACF,CAGA,SAAS,EAAK,EAAK,GAEjB,IADA,IAAI,EAAM,CAAC,EACF,EAAI,EAAG,EAAM,EAAI,OAAQ,EAAI,EAAK,IAAK,CAC9C,IAAI,EAAO,EAAI,GACX,KAAQ,IACV,EAAI,GAAQ,EAAI,GAEpB,CACA,OAAO,CACT,CAKA,IAgII,EAhIA,EAA8B,EAElC,SAAS,EAAiB,GACxB,OAAO,CACT,CAEA,SAAS,EAA2B,GAClC,MAAO,CAAC,CACN,GAAI,GAER,CAGA,SAAS,EAAQ,EAAI,EAAM,GACzB,IAAI,EAAW,EAAK,KAGhB,EAAe,IAAI,EACvB,EAAS,SAAQ,SAAU,GACrB,EAAa,IAAI,EAAQ,IAC3B,EAAa,IAAI,EAAQ,IAAI,KAAK,GAElC,EAAa,IAAI,EAAQ,GAAI,CAAC,GAElC,IAEA,IAAI,EAAU,EAAa,KACvB,EAAU,EACV,EAAgB,IAAI,MAAM,GAe9B,SAAS,IAbT,IACM,IAaE,IAAY,IAbd,EAAU,GACd,EAAc,SAAQ,SAAU,GAC9B,EAAI,KAAK,SAAQ,SAAU,GACzB,EAAQ,KAAK,CACX,GAAI,EAAI,GACR,KAAM,CAAC,IAEX,GACF,IACA,EAAS,KAAM,CAAC,QAAS,IAO3B,CAOA,IAAI,EAAc,GAClB,EAAa,SAAQ,SAAU,EAAO,GACpC,EAAY,KAAK,EACnB,IAEA,IAAI,EAAI,EAER,SAAS,IAEP,KAAI,GAAK,EAAY,QAArB,CAIA,IAAI,EAAO,KAAK,IAAI,EAAI,EAA6B,EAAY,QAC7D,EAAQ,EAAY,MAAM,EAAG,IAKnC,SAAsB,EAAO,GAC3B,EAAM,SAAQ,SAAU,EAAO,GAC7B,IAAI,EAAS,EAAS,EAClB,EAAc,EAAa,IAAI,GAQ/B,EAAU,EAAK,EAAY,GAAI,CAAC,aAAc,gBAClD,EAAQ,UAAY,EAAY,KAAI,SAAU,GAE5C,OAAO,EAAQ,GACjB,IAGA,EAAQ,UAAY,EAAQ,UAAU,OAAO,GAE7C,IAAI,EAAe,EAEc,IAA7B,EAAQ,UAAU,gBACb,EAAQ,UAKf,EAAe,GAIjB,CAAC,OAAQ,cAAe,SAAU,OAAQ,UAAU,SAAQ,SAAU,GAChE,KAAS,IACX,EAAQ,GAAS,EAAK,GAE1B,IACA,EAAG,IAAI,EAAO,GAAS,SAAU,EAAK,GACpC,IAAI,EA9DmB,EAAI,EAiEzB,EADE,EACO,CAAC,CAAC,MAAO,IAET,EAAa,GAnED,EAqEL,EArES,EAqEF,EApE7B,EAoEc,GApEY,CAAC,GAAI,EAAI,KAAM,GACzC,IAoEI,GACF,GACF,GACF,CArDE,CAAa,EAAO,GACpB,GAAK,EAAM,MALX,CAMF,CAqDA,GAEF,CAIA,IACE,aAAa,QAAQ,4BAA6B,GAClD,IAAa,aAAa,QAAQ,4BACpC,CAAE,MAAO,GACP,GAAW,CACb,CAEA,SAAS,IACP,OAAO,CACT,CAIA,MAAM,UAAgB,KACpB,WAAA,GACE,QAEA,KAAK,WAAa,CAAC,EAEf,KACF,iBAAiB,WAAY,IAC3B,KAAK,KAAK,EAAE,IAAI,GAGtB,CAEA,WAAA,CAAY,EAAQ,EAAI,EAAI,GAC1B,IAAI,KAAK,WAAW,GAApB,CAGA,IAAI,GAAa,EACb,EAAO,KA+BX,KAAK,WAAW,GAAM,EACtB,KAAK,GAAG,EAAQ,EAlChB,CAGA,SAAS,IACP,GAAK,EAAK,WAAW,GAGrB,GAAI,EACF,EAAa,cADf,CAIA,GAAa,EACb,IAAI,EAAc,EAAK,EAAM,CAC3B,QAAS,eAAgB,cAAe,YAAa,SACrD,UAAW,OAAQ,QAAS,eAAgB,SAAU,gBAOxD,EAAG,QAAQ,GAAa,GAAG,UAAU,SAAU,GACzC,EAAE,IAAM,EAAK,QAAU,EAAK,YAC9B,EAAK,MAAQ,EAAE,IACf,EAAK,SAAS,GAElB,IAAG,GAAG,YAAY,WACG,YAAf,GACF,IAAU,GAEZ,GAAa,CACf,IAAG,GAAG,SAdN,WACE,GAAa,CACf,GATA,CAsBF,CAGF,CAEA,cAAA,CAAe,EAAQ,GACf,KAAM,KAAK,aAGjB,MAAM,eAAe,EAAQ,KAAK,WAAW,WACtC,KAAK,WAAW,GACzB,CAEA,kBAAA,CAAmB,GAGb,MACF,aAAa,GAAoC,MAAzB,aAAa,GAAmB,IAAM,IAElE,CAEA,MAAA,CAAO,GACL,KAAK,KAAK,GACV,KAAK,mBAAmB,EAC1B,EAGF,SAAS,EAAe,GAEtB,GAAuB,oBAAZ,SAAsD,mBAApB,QAAQ,GACxC,MAAM,UAAU,MAAM,KAAK,UAAW,EAGrD,CAsBA,SAAS,EAAe,GACtB,IAAI,EAAM,EAIV,OAHK,IACH,EAAM,KAvBV,SAAsB,EAAK,GACzB,IAAI,EAAa,IAgBjB,OAfA,EAAM,SAAS,EAAK,KAAO,GAC3B,EAAM,SAAS,EAAK,MACR,GAAO,GAAO,EACxB,GAAO,GAAO,IAAM,EAEpB,GAAY,EAGV,EAAM,IACR,EAAM,IACN,EAAM,OAGI,EAAM,GADN,KAAK,SAGS,EAC5B,CAOS,CAAa,EAAK,EAC3B,CAIA,SAAS,EAAa,EAAQ,GAC5B,EAAe,OAAQ,aAAe,EAAS,uBAAyB,EAC1E,CA6BA,IAAI,EAzB2B,mBAAlB,OAAO,OACP,OAAO,OAIP,SAAU,GAGjB,IAFA,IAAI,EAAK,OAAO,GAEP,EAAQ,EAAG,EAAQ,UAAU,OAAQ,IAAS,CACrD,IAAI,EAAa,UAAU,GAE3B,GAAkB,MAAd,EACF,IAAK,IAAI,KAAW,EAEd,OAAO,UAAU,eAAe,KAAK,EAAY,KACnD,EAAG,GAAW,EAAW,GAIjC,CACA,OAAO,CACT,EAMJ,MAAM,UAAmB,MACvB,WAAA,CAAY,EAAQ,EAAO,GACzB,QACA,KAAK,OAAS,EACd,KAAK,KAAO,EACZ,KAAK,QAAU,EACf,KAAK,OAAQ,CACf,CAEA,QAAA,GACE,OAAO,KAAK,UAAU,CACpB,OAAQ,KAAK,OACb,KAAM,KAAK,KACX,QAAS,KAAK,QACd,OAAQ,KAAK,QAEjB,EAGiB,IAAI,EAAW,IAAK,eAAgB,kCAAvD,IACI,EAAoB,IAAI,EAAW,IAAK,cAAe,+BACvD,EAAc,IAAI,EAAW,IAAK,YAAa,WAC/C,EAAe,IAAI,EAAW,IAAK,WAAY,4BAC/C,EAAa,IAAI,EAAW,IAAK,cAAe,mCAChD,EAAa,IAAI,EAAW,IAAK,aAAc,4BAC/C,EAAc,IAAI,EAAW,IAAK,cAAe,yDAEjD,GADW,IAAI,EAAW,IAAK,sBAAuB,qBACtC,IAAI,EAAW,IAAK,gBAAiB,0CACrD,EAAU,IAAI,EAAW,IAAK,SAAU,kCAExC,GADkB,IAAI,EAAW,IAAK,kBAAmB,uBACrC,IAAI,EAAW,IAAK,oBAAqB,oCAC7D,GAAiB,IAAI,EAAW,IAAK,iBAAkB,+BACvD,GAAc,IAAI,EAAW,IAAK,cAAe,oCACjD,GAAgB,IAAI,EAAW,IAAK,cAAe,kCAEnD,IADa,IAAI,EAAW,IAAK,YAAa,sBAClC,IAAI,EAAW,IAAK,sBAAuB,YAIvD,IAHY,IAAI,EAAW,IAAK,mBAAoB,WACxC,IAAI,EAAW,IAAK,wBAAyB,WAC7C,IAAI,EAAW,IAAK,YAAa,wDAC/B,IAAI,EAAW,IAAK,cAAe,uBAEjD,IADc,IAAI,EAAW,IAAK,cAAe,+DAClC,IAAI,EAAW,IAAK,eAAgB,gDACrC,IAAI,EAAW,IAAK,cAAe,2BAErD,SAAS,GAAY,EAAO,GAC1B,SAAS,EAAiB,GAKxB,IADA,IAAI,EAAQ,OAAO,oBAAoB,GAC9B,EAAI,EAAG,EAAM,EAAM,OAAQ,EAAI,EAAK,IACZ,mBAApB,EAAM,EAAM,MACrB,KAAK,EAAM,IAAM,EAAM,EAAM,UAId,IAAf,KAAK,QACP,KAAK,OAAQ,IAAK,OAAS,YAId,IAAX,IACF,KAAK,OAAS,EAElB,CAEA,OADA,EAAiB,UAAY,EAAW,UACjC,IAAI,EAAiB,EAC9B,CAEA,SAAS,GAA0B,GAEjC,GAAmB,iBAAR,EAAkB,CAC3B,IAAI,EAAO,GACX,EAAM,GACF,KAAO,CACb,CAuBA,MArBI,UAAW,GAAqB,aAAd,EAAI,QACxB,EAAI,KAAO,WACX,EAAI,OAAS,KAGT,SAAU,IACd,EAAI,KAAO,EAAI,OAAS,WAGpB,WAAY,IAChB,EAAI,OAAS,KAGT,YAAa,IACjB,EAAI,QAAU,EAAI,SAAW,EAAI,QAG7B,UAAW,IACf,EAAI,OAAQ,IAAK,OAAS,OAGrB,CACT,CAWA,SAAS,GAAa,GACpB,IAAI,EAAM,CAAC,EACP,EAAY,EAAK,QAAiC,mBAAhB,EAAK,OAG3C,OAFA,EAAI,MAAQ,EAAK,aAEV,SAAgB,GAChB,EAAO,MAGV,EAAO,IAAM,CAAC,GAGhB,IAAI,EAAe,GArBvB,SAAmB,EAAQ,EAAK,GAC9B,IACE,OAAQ,EAAO,EAAK,EACtB,CAAE,MAAO,GACP,IAAI,EAAM,0BAA4B,EAAI,WAC1C,OAAO,GAAY,GAAa,EAClC,CACF,CAcoC,CAAU,EAAK,OAAQ,EAAO,IAAK,GAEnE,GAA4B,iBAAjB,EACT,OAAO,EAGT,GAAI,EACF,OAAO,EAGT,GAAK,EAAK,cAEH,IAAK,EAAK,YACf,IAAK,IAAI,KAAO,EAAO,IAAI,aAErB,OAAO,UAAU,eAAe,KAAK,EAAO,IAAI,aAAc,KAChE,EAAO,IAAI,aAAa,GAAK,MAAO,eALjC,EAAO,IAShB,OAAO,CACT,CACF,CAEA,SAAS,GAAQ,GAEf,IADA,IAAI,EAAM,GACD,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAC1C,EAAM,EAAI,OAAO,EAAK,IAExB,OAAO,CACT,CASA,SAAS,GAAe,GACtB,IAAI,EAQJ,GAPK,EAEoB,iBAAP,EAChB,EAAM,GAAY,GACT,KAAK,KAAK,KAAQ,mBAAqB,KAAK,KACrD,EAAM,GAAY,IAJlB,EAAM,GAAY,GAMhB,EACF,MAAM,CAEV,CAIA,SAAS,GAAS,GAChB,MAA0B,kBAAf,EAAG,QACL,EAAG,QAGW,mBAAZ,EAAG,OACZ,EAAe,OACb,8EAEmB,SAAd,EAAG,OAId,CAOA,SAAS,GAA2B,GAClC,IAAK,EACH,OAAO,KAET,IAAI,EAAQ,EAAE,MAAM,KACpB,OAAqB,IAAjB,EAAM,OACD,EAEY,IAAjB,EAAM,OACD,CAAC,EAAG,GAEN,IACT,CAEA,SAAS,GAA+B,GACtC,IAAI,EAAa,GAA2B,GAC5C,OAAO,EAAa,EAAW,KAAK,KAAO,IAC7C,CAKA,IAAI,GAAO,CAAC,SAAU,WAAY,YAAa,WAAY,OAAQ,WAC/D,OAAQ,OAAQ,WAAY,OAAQ,YAAa,OAAQ,QAAS,UAClE,GAAO,WACP,GAAU,4BAIV,GAAS,mMAEb,SAAS,GAAS,GAKhB,IAJA,IAAI,EAAI,GAAO,KAAK,GAChB,EAAM,CAAC,EACP,EAAI,GAED,KAAK,CACV,IAAI,EAAM,GAAK,GACX,EAAQ,EAAE,IAAM,GAChB,GAAiD,IAAvC,CAAC,OAAQ,YAAY,QAAQ,GAC3C,EAAI,GAAO,EAAU,mBAAmB,GAAS,CACnD,CASA,OAPA,EAAI,IAAS,CAAC,EACd,EAAI,GAAK,KAAK,QAAQ,IAAS,SAAU,EAAI,EAAI,GAC3C,IACF,EAAI,IAAO,GAAM,EAErB,IAEO,CACT,CAMA,SAAS,GAAU,EAAQ,GACzB,IAAI,EAAO,GACP,EAAS,GACb,IAAK,IAAI,KAAO,EACV,OAAO,UAAU,eAAe,KAAK,EAAO,KAC9C,EAAK,KAAK,GACV,EAAO,KAAK,EAAM,KAItB,OADA,EAAK,KAAK,GACH,SAAS,MAAM,KAAM,GAAM,MAAM,KAAM,EAChD,CAKA,SAAS,GAAO,EAAI,EAAO,GACzB,OAAO,EAAG,IAAI,GACX,OAAM,SAAU,GAEf,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,MAAO,CAAC,CACV,IACC,MAAK,SAAU,GAEd,IAAI,EAAS,EAAI,KACb,EAAS,EAAQ,GAErB,OAAK,GAQL,EAAO,IAAM,EACb,EAAO,KAAO,EAKpB,SAAmB,EAAI,EAAK,GAC1B,OAAO,EAAG,IAAI,GAAK,MAAK,SAAU,GAChC,MAAO,CACL,SAAS,EACT,IAAK,EAAI,IAEb,IAAG,SAAU,GAEX,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,OAAO,GAAO,EAAI,EAAI,IAAK,EAC7B,GACF,CAjBa,CAAU,EAAI,EAAQ,IAPpB,CAAC,SAAS,EAAO,IAAK,EAQjC,GACJ,CAiBA,IAAI,GAAW,SAAU,GACvB,OAAO,KAAK,EACd,EAEI,GAAW,SAAU,GACvB,OAAO,KAAK,EACd,EAKA,SAAS,GAAW,EAAO,GAEzB,EAAQ,GAAS,GACjB,EAAa,GAAc,CAAC,EAC5B,IACE,OAAO,IAAI,KAAK,EAAO,EACzB,CAAE,MAAO,GACP,GAAe,cAAX,EAAE,KACJ,MAAM,EAOR,IALA,IAII,EAAU,IAJuB,oBAAhB,YAA8B,YACZ,oBAAlB,cAAgC,cACb,oBAAnB,eAAiC,eACxC,mBAEL,EAAI,EAAG,EAAI,EAAM,OAAQ,GAAK,EACrC,EAAQ,OAAO,EAAM,IAEvB,OAAO,EAAQ,QAAQ,EAAW,KACpC,CACF,CAIA,SAAS,GAA0B,GAIjC,IAHA,IAAI,EAAS,EAAI,OACb,EAAM,IAAI,YAAY,GACtB,EAAM,IAAI,WAAW,GAChB,EAAI,EAAG,EAAI,EAAQ,IAC1B,EAAI,GAAK,EAAI,WAAW,GAE1B,OAAO,CACT,CAEA,SAAS,GAAmB,EAAW,GACrC,OAAO,GAAW,CAAC,GAA0B,IAAa,CAAC,KAAM,GACnE,CAEA,SAAS,GAAa,EAAK,GACzB,OAAO,GAAmB,GAAS,GAAM,EAC3C,CAgBA,SAAS,GAAmB,EAAM,GAChC,IAAI,EAAS,IAAI,WACb,EAAuD,mBAA9B,EAAO,mBACpC,EAAO,UAAY,SAAU,GAC3B,IAAI,EAAS,EAAE,OAAO,QAAU,GAChC,GAAI,EACF,OAAO,EAAS,GAElB,EAnBJ,SAAmC,GAIjC,IAHA,IAAI,EAAS,GACT,EAAQ,IAAI,WAAW,GACvB,EAAS,EAAM,WACV,EAAI,EAAG,EAAI,EAAQ,IAC1B,GAAU,OAAO,aAAa,EAAM,IAEtC,OAAO,CACT,CAWa,CAA0B,GACrC,EACI,EACF,EAAO,mBAAmB,GAE1B,EAAO,kBAAkB,EAE7B,CAEA,SAAS,GAAmB,EAAc,GACxC,GAAmB,GAAc,SAAU,GACzC,EAAS,EACX,GACF,CAEA,SAAS,GAAa,EAAc,GAClC,GAAmB,GAAc,SAAU,GACzC,EAAS,GAAS,GACpB,GACF,CAcA,IAAI,GAAmB,KAAK,cAAgB,KAAK,WAC7C,GAAiB,MAarB,SAAS,GAAW,EAAQ,EAAM,EAAO,EAAK,IACxC,EAAQ,GAAK,EAAM,EAAK,QAE1B,EAVJ,SAAmB,EAAM,EAAO,GAC9B,OAAI,EAAK,YACA,EAAK,YAAY,EAAO,GAE1B,EAAK,MAAM,EAAO,EAC3B,CAKW,CAAU,EAAM,EAAO,IA5BlC,SAA2B,EAAM,GAC/B,IAAI,EAAS,IAAI,WACjB,EAAO,UAAY,SAAU,GAC3B,IAAI,EAAS,EAAE,OAAO,QAAU,IAAI,YAAY,GAChD,EAAS,EACX,EACA,EAAO,kBAAkB,EAC3B,CAuBE,CAAkB,GAAM,SAAU,GAChC,EAAO,OAAO,GACd,GACF,GACF,CAEA,SAAS,GAAa,EAAQ,EAAQ,EAAO,EAAK,IAC5C,EAAQ,GAAK,EAAM,EAAO,UAE5B,EAAS,EAAO,UAAU,EAAO,IAEnC,EAAO,aAAa,GACpB,GACF,CAEA,SAAS,GAAU,EAAM,GACvB,IAAI,EAAgC,iBAAT,EACvB,EAAM,EAAgB,EAAK,OAAS,EAAK,KACzC,EAAY,KAAK,IAAI,GAAgB,GACrC,EAAS,KAAK,KAAK,EAAM,GACzB,EAAe,EACf,EAAS,EAAgB,IAAI,KAAQ,IAAI,iBAEzC,EAAS,EAAgB,GAAe,GAE5C,SAAS,IACP,GAAiB,EACnB,CAEA,SAAS,IACP,IACI,EA/CR,SAAqB,GACnB,OAAO,GAAS,EAClB,CA6CiB,CADH,EAAO,KAAI,IAErB,EAAS,GACT,EAAO,SACT,CAEA,SAAS,IACP,IAAI,EAAQ,EAAe,EACvB,EAAM,EAAQ,EAClB,IAEE,EAAO,EAAQ,EAAM,EAAO,EAD1B,EAAe,EACgB,EAEA,EAErC,CACA,GACF,CAEA,SAAS,GAAU,GACjB,OAAO,SAAS,EAClB,CAMA,SAAS,GAAO,EAAK,GACnB,IAAK,EACH,OAAO,IAAK,QAAQ,KAAM,IAAI,cAGhC,IAAI,EAAgB,EAAsB,CAAC,EAAG,GAE9C,cADO,EAAc,UACd,GAAU,KAAK,UAAU,GAClC,CAEA,IAAI,GAAO,EAOX,SAAS,GAAW,GAMlB,IALA,IAAI,EACA,EACA,EAEA,EADA,EAAU,EAAS,SAAS,QAExB,EAAO,EAAQ,OAAQ,CAC7B,IAAI,EAAO,EAAK,IACZ,EAAW,EAAK,GAChB,EAAM,EAAK,IACf,GAAI,EAAS,OACX,IAAK,IAAI,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAC9C,EAAQ,KAAK,CAAC,IAAK,EAAM,EAAG,IAAK,EAAS,SAF9C,CAMA,IAAI,IAAY,EAAK,GAAG,QACpB,EAAK,EAAK,GAET,KAAc,IAAmB,EAAU,EAC5C,IAAe,EAAM,EAAa,EAAM,EAAY,KACtD,EAAY,EACZ,EAAa,EACb,EAAiB,EARnB,CAUF,CAEA,OAAO,EAAa,IAAM,CAC5B,CAMA,SAAS,GAAgB,EAAM,GAI7B,IAHA,IAEI,EAFA,EAAU,EAAK,QAGX,EAAO,EAAQ,OAMrB,IALA,IAAI,EAAM,EAAK,IACX,EAAO,EAAK,IACZ,EAAW,EAAK,GAChB,EACF,EAA6B,IAApB,EAAS,OAAc,EAAK,EAAK,GAAI,EAAK,IAAK,EAAK,IACtD,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAC9C,EAAQ,KAAK,CAAC,IAAK,EAAM,EAAG,IAAK,EAAS,GAAI,IAAK,GAGzD,CAEA,SAAS,GAAU,EAAG,GACpB,OAAO,EAAE,IAAM,EAAE,GACnB,CAEA,SAAS,GAAc,GACrB,IAAI,EAAS,GACb,GAAgB,GAAM,SAAU,EAAQ,EAAK,EAAI,EAAK,GAChD,GACF,EAAO,KAAK,CAAC,IAAK,EAAM,IAAM,EAAI,IAAK,EAAK,KAAM,GAEtD,IACA,EAAO,KAAK,IAAW,UACvB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,WACrC,EAAO,GAAG,IAEnB,OAAO,CACT,CAKA,SAAS,GAAiB,GAIxB,IAHA,IAAI,EAAM,GAAW,GACjB,EAAS,GAAc,EAAS,UAChC,EAAY,GACP,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAAK,CACjD,IAAI,EAAO,EAAO,GACd,EAAK,MAAQ,GAAQ,EAAK,KAAK,SACjC,EAAU,KAAK,EAAK,IAExB,CACA,OAAO,CACT,CAyEA,SAAS,GAAW,GAIlB,IAHA,IAEI,EAFA,EAAQ,GACR,EAAU,EAAK,QAEX,EAAO,EAAQ,OAAQ,CAC7B,IAAI,EAAM,EAAK,IACX,EAAO,EAAK,IACZ,EAAK,EAAK,GACV,EAAO,EAAK,GACZ,EAAW,EAAK,GAChB,EAA6B,IAApB,EAAS,OAElB,EAAU,EAAK,QAAU,EAAK,QAAQ,QAAU,GACpD,EAAQ,KAAK,CAAC,GAAI,EAAI,KAAM,IACxB,GACF,EAAM,KAAK,CAAC,IAAM,EAAM,EAAI,EAAQ,OAAS,IAAK,IAEpD,IAAK,IAAI,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAC9C,EAAQ,KAAK,CAAC,IAAK,EAAM,EAAG,IAAK,EAAS,GAAI,QAAS,GAE3D,CACA,OAAO,EAAM,SACf,CAIA,SAAS,GAAY,EAAG,GACtB,OAAO,EAAE,IAAM,EAAE,GACnB,CAmBA,SAAS,GAAa,EAAK,EAAM,GAC/B,IAAI,EAjBN,SAAsB,EAAK,EAAM,GAI/B,IAHA,IAEI,EAFA,EAAM,EACN,EAAO,EAAI,OAER,EAAM,GAEP,EAAW,EADf,EAAO,EAAM,IAAU,GACE,GAAQ,EAC/B,EAAM,EAAM,EAEZ,EAAO,EAGX,OAAO,CACT,CAIY,CAAa,EAAK,EAAM,GAClC,EAAI,OAAO,EAAK,EAAG,EACrB,CAKA,SAAS,GAAW,EAAM,GAGxB,IAFA,IAAI,EACA,EACK,EAAI,EAAY,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CACxD,IAAI,EAAO,EAAK,GACZ,EAAc,CAAC,EAAK,GAAI,EAAK,KAAM,IACnC,GACF,EAAK,GAAG,KAAK,GACb,EAAO,GAEP,EAAO,EAAO,CAElB,CACA,OAAO,CACT,CAGA,SAAS,GAAY,EAAG,GACtB,OAAO,EAAE,GAAK,EAAE,IAAM,EAAI,CAC5B,CAIA,SAAS,GAAU,EAAU,GAG3B,IAFA,IAAI,EAAQ,CAAC,CAAC,MAAO,EAAU,MAAO,IAClC,GAAY,EACT,EAAM,OAAS,GAAG,CACvB,IAAI,EAAO,EAAM,MACb,EAAQ,EAAK,MACb,EAAQ,EAAK,OAEb,EAAM,GAAG,QAAU,EAAM,GAAG,UAC9B,EAAM,GAAG,OACe,cAArB,EAAM,GAAG,QACU,cAApB,EAAM,GAAG,OAA0B,YAAc,WAGrD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,GAAG,OAAQ,IACnC,GAAK,EAAM,GAAG,GAAd,CAOA,IADA,IAAI,GAAS,EACJ,EAAI,EAAG,EAAI,EAAM,GAAG,OAAQ,IAC/B,EAAM,GAAG,GAAG,KAAO,EAAM,GAAG,GAAG,KACjC,EAAM,KAAK,CAAC,MAAO,EAAM,GAAG,GAAI,MAAO,EAAM,GAAG,KAChD,GAAS,GAGR,IACH,EAAY,aACZ,GAAa,EAAM,GAAI,EAAM,GAAG,GAAI,IAXtC,MAHE,EAAY,WACZ,EAAM,GAAG,GAAK,EAAM,GAAG,EAgB7B,CACA,MAAO,CAAC,UAAW,EAAW,KAAM,EACtC,CAEA,SAAS,GAAQ,EAAM,EAAM,GAC3B,IAGI,EAHA,EAAU,GACV,GAAY,EACZ,GAAS,EAGb,IAAK,EAAK,OACR,MAAO,CAAC,KAAM,CAAC,GAAO,UAAW,YAGnC,IAAK,IAAI,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CAC/C,IAAI,EAAS,EAAK,GAClB,GAAI,EAAO,MAAQ,EAAK,KAAO,EAAO,IAAI,KAAO,EAAK,IAAI,GAGxD,EAAM,GAAU,EAAO,IAAK,EAAK,KACjC,EAAQ,KAAK,CAAC,IAAK,EAAO,IAAK,IAAK,EAAI,OACxC,EAAY,GAAa,EAAI,UAC7B,GAAS,OACJ,IAAmB,IAAf,EAAqB,CAM9B,IAAI,EAAK,EAAO,IAAM,EAAK,IAAM,EAAS,EACtC,EAAK,EAAO,IAAM,EAAK,IAAM,EAAO,EACpC,EAAO,EAAG,IAAM,EAAG,IAEnB,EAAmB,GAEnB,EAAQ,GAEZ,IADA,EAAM,KAAK,CAAC,IAAK,EAAG,IAAK,KAAM,EAAM,OAAQ,KAAM,UAAW,OACvD,EAAM,OAAS,GAAG,CACvB,IAAI,EAAO,EAAM,MACjB,GAAkB,IAAd,EAAK,KAOT,IADA,IAAI,EAAW,EAAK,IAAI,GACf,EAAI,EAAG,EAAc,EAAS,OAAQ,EAAI,EAAa,IAC9D,EAAM,KAAK,CACT,IAAK,EAAS,GACd,KAAM,EAAK,KAAO,EAClB,OAAQ,EAAK,IACb,UAAW,SAXT,EAAK,IAAI,KAAO,EAAG,IAAI,IACzB,EAAiB,KAAK,EAa5B,CAEA,IAAI,EAAK,EAAiB,GAErB,GAGH,EAAM,GAAU,EAAG,IAAK,EAAG,KAC3B,EAAG,OAAO,GAAG,EAAG,WAAa,EAAI,KACjC,EAAQ,KAAK,CAAC,IAAK,EAAG,IAAK,IAAK,EAAG,MACnC,EAAY,GAAa,EAAI,UAC7B,GAAS,GANT,EAAQ,KAAK,EAQjB,MACE,EAAQ,KAAK,EAEjB,CASA,OANK,GACH,EAAQ,KAAK,GAGf,EAAQ,KAAK,IAEN,CACL,KAAM,EACN,UAAW,GAAa,gBAE5B,CA4DA,SAAS,GAAM,EAAM,EAAM,GACzB,IAAI,EAAU,GAAQ,EAAM,GACxB,EA3DN,SAAc,EAAM,GAMlB,IAJA,IACI,EAEA,EAHA,EAAQ,GAAW,GAId,EAAI,EAAG,EAAM,EAAM,OAAQ,EAAI,EAAK,IAAK,CAGhD,IAEI,EAFA,EAAO,EAAM,GACb,EAAU,EAAK,IAEnB,GAAI,EAAQ,OAAS,EAAO,CAErB,IACH,EAAc,CAAC,GAEjB,IAAI,EAAa,EAAQ,OAAS,EAClC,EAAO,CACL,IAAK,EAAK,IAAM,EAChB,IAAK,GAAW,EAAS,IAG3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,IAAK,CACnC,IAAI,EAAO,EAAK,IAAM,EAAK,IAAM,EAAQ,GAAG,GAC5C,EAAY,IAAO,CACrB,CACF,MACE,EAAO,CACL,IAAK,EAAK,IACV,IAAK,GAAW,EAAS,IAO3B,EADE,EACO,GAAQ,EAAQ,GAAM,GAAM,KAE5B,CAAC,EAEd,CAUA,OAPI,GACF,GAAgB,GAAQ,SAAU,EAAQ,EAAK,UAEtC,EAAY,EAAM,IAAM,EACjC,IAGK,CACL,KAAM,EACN,KAAM,EAAc,OAAO,KAAK,GAAe,GAEnD,CAIgB,CAAK,EAAQ,KAAM,GACjC,MAAO,CACL,KAAM,EAAQ,KACd,YAAa,EAAQ,KACrB,UAAW,EAAQ,UAEvB,CAsBA,SAAS,GAAS,GAChB,OAAO,EAAK,GACd,CAKA,SAAS,GAAU,EAAU,GACtB,IACH,EAAM,GAAW,IAMnB,IAJA,IAGI,EAHA,EAAK,EAAI,UAAU,EAAI,QAAQ,KAAO,GACtC,EAAU,EAAS,SAAS,IAAI,IAG5B,EAAO,EAAQ,OAAQ,CAC7B,GAAI,EAAK,KAAO,EACd,QAAS,EAAK,GAAG,QAEnB,EAAU,EAAQ,OAAO,EAAK,GAChC,CACF,CAEA,SAAS,GAAU,GACjB,MAAO,UAAY,KAAK,EAC1B,CA+CA,SAAS,GAAc,EAAK,EAAU,GACpC,IAAI,EAAa,CAAC,CAAC,IAAK,EAAI,OACT,aAAf,EAAK,QACP,EAAa,GAAc,EAAS,UACnC,KAAI,SAAU,GAAK,MAAO,CAAC,IAAK,EAAE,IAAM,KAE3C,IAAI,EAAS,CACX,GAAI,EAAS,GACb,QAAS,EACT,IAAK,GAYP,OATI,GAAU,EAAU,EAAI,QAC1B,EAAO,SAAU,GAEf,EAAK,YACP,EAAO,IAAI,WAAa,GAAiB,GACpC,EAAO,IAAI,WAAW,eAClB,EAAO,IAAI,YAGf,CACT,CAEA,MAAM,WAAkB,KACtB,WAAA,CAAY,EAAI,EAAM,GACpB,QACA,KAAK,GAAK,EAEV,IAAI,GADJ,EAAO,EAAO,EAAM,GAAQ,CAAC,GACT,SAAW,GAAK,CAAC,EAAK,KA91B9C,IAAuB,EAAI,EA+1BjB,GA/1BiB,EAg2BK,SA/1BvB,kBADc,EAg2BG,MA/1BO,EAAG,cAAc,GACjB,kBAAiB,EAAI,IA81BX,GACjC,KAAK,KAAK,QAAS,IAGrB,KAAK,KAAK,WAAY,GAExB,KAAK,qBACL,EAAG,eAAe,YAAa,EAAU,IAEvC,IACF,KAAK,GAAG,YAAY,SAAU,GAC5B,EAAS,KAAM,EACjB,IACA,KAAK,GAAG,QAAS,IAEnB,MAAM,EAAY,KAChB,KAAK,QAAQ,EAEf,EAAG,KAAK,YAAa,GAErB,EAAK,SAAW,CAAC,EAAQ,EAAS,KAE5B,KAAK,aA9Df,SAAkC,EAAM,EAAQ,EAAS,GAEvD,IACE,EAAK,KAAK,SAAU,EAAQ,EAAS,EACvC,CAAE,MAAO,GACP,EAAe,QAAS,oCAAqC,EAC/D,CACF,CA0DM,CAAyB,KAAM,EAAQ,EAAS,EAAQ,EAG1D,IAAI,EAAU,IAAI,SAAQ,SAAU,EAAS,GAC3C,EAAK,SAAW,SAAU,EAAK,GACzB,EACF,EAAO,GAEP,EAAQ,EAEZ,CACF,IACA,KAAK,KAAK,UAAU,WAClB,EAAG,eAAe,YAAa,GAC/B,EAAK,SAAS,KAAM,CAAC,OAAQ,aAC/B,IACA,KAAK,KAAO,EAAQ,KAAK,KAAK,GAC9B,KAAY,MAAI,EAAe,MAAE,KAAK,GACtC,KAAK,MAAK,SAAU,GAClB,EAAS,KAAM,EACjB,GAAG,GAIE,EAAG,UAAU,QAWhB,KAAK,gBAAgB,GAVrB,EAAG,UAAU,SAAS,IAChB,EACF,EAAK,SAAS,GACL,KAAK,YACd,KAAK,KAAK,UAEV,KAAK,gBAAgB,EACvB,GAKN,CAEA,MAAA,GACE,KAAK,aAAc,EACf,KAAK,GAAG,UAAU,SACpB,KAAK,KAAK,SAEd,CAEA,eAAA,CAAgB,GACd,IAAI,EAAW,EAAK,SAGhB,GAAQ,qBACV,GAAQ,qBAAqB,SAAS,GAAO,IAC3C,GAAI,EACF,OAAO,EAAS,GAElB,KAAK,UAAU,EAAK,IAGtB,KAAK,UAAU,EAEnB,CAEA,SAAA,CAAU,GACR,IAAI,EAAW,EAAK,SAcpB,GAXI,SADJ,EAAO,EAAM,OACW,eAAgB,KACtC,EAAK,WAAa,EAAK,MAEzB,EAAK,cAAgB,GAEF,WAAf,EAAK,QACP,EAAK,MAAQ,OAEV,EAAK,QACR,EAAK,MAAQ,GAEI,QAAf,EAAK,MAAT,CAcA,GAAI,GAAQ,sBAEV,GADA,GAAQ,qBAAqB,UAAU,GACnC,GAAQ,qBAAqB,aAAa,KAAM,GAClD,OAAO,GAAQ,qBAAqB,OAAO,KAAM,OAGnD,CAAC,UAAW,SAAU,WAAY,QAAQ,SAAQ,SAAU,GACtD,KAAO,GACT,EAAe,OACb,QAAU,EAAV,qKAKN,IAGI,eAAgB,IACpB,EAAK,YAAa,GAIpB,EAAK,MAAuB,IAAf,EAAK,MAAc,EAAI,EAAK,MACzC,EAAK,SAAW,EAChB,IAAI,EAAa,KAAK,GAAG,SAAS,GAElC,GAAI,GAA2C,mBAAtB,EAAW,OAAuB,CACzD,MAAM,EAAS,KAAK,OACpB,KAAK,OAAS,IAAI,KAChB,EAAW,SACX,EAAO,MAAM,KAAM,EAAK,CAE5B,CAnCA,MAVE,KAAK,GAAG,OAAO,MAAM,IAEf,KAAK,YACP,EAAS,KAAM,CAAC,OAAQ,eAG1B,EAAK,MAAQ,EAAK,WAClB,KAAK,UAAU,GAAK,GACnB,EAsCP,EAOF,SAAS,GAAQ,EAAM,GACrB,OAAO,EAAO,GAAS,EAAI,EAAO,EAAQ,EAAI,CAChD,CAIA,SAAS,GAAU,EAAU,GAC3B,OAAO,SAAU,EAAK,GAChB,GAAQ,EAAQ,IAAM,EAAQ,GAAG,QACnC,EAAM,GAAO,EAAQ,IACjB,MAAQ,EACZ,EAAS,IAET,EAAS,KAAM,EAAQ,OAAS,EAAQ,GAAM,EAElD,CACF,CAqBA,SAAS,GAAmB,EAAG,GAC7B,IAAI,EAAY,GAAQ,EAAE,IAAK,EAAE,KACjC,OAAkB,IAAd,EACK,EAIF,GAFM,EAAE,WAAa,EAAE,WAAW,MAAQ,EACpC,EAAE,WAAa,EAAE,WAAW,MAAQ,EAEnD,CA4CA,SAAS,GAAiB,GACxB,IAAI,EAAO,EAAK,iBAAiB,GAC7B,EAAO,EAAK,KACZ,EAAW,EAAK,SACpB,EAAK,IAAI,qBAAqB,OAAM,WAClC,OAAO,CACT,IAAG,MAAK,SAAU,GACZ,GAAO,EAAI,WACb,EAAK,SAAW,EAAI,UAEtB,EAAK,SAAS,GAAM,SAAU,EAAK,GAE7B,EACF,EAAS,GAET,EAAS,KAAM,GAEjB,KAAU,WACR,EAAK,iBAAiB,QAClB,EAAK,iBAAiB,QACxB,GAAiB,EAErB,GACF,GACF,GACF,CAEA,SAAS,GAAe,EAAI,EAAO,GACjC,OAAO,EAAG,IAAI,iBAAiB,MAAK,SAAU,GAC5C,MAAM,EAAW,EAAI,SAAW,EAUhC,OATA,EAAI,OAAO,KAAK,CACd,QACA,MACA,aAEE,EAAI,OAAO,OAAS,KAAK,oBAC3B,EAAI,OAAO,OAAO,EAAG,EAAI,OAAO,OAAS,KAAK,oBAEhD,EAAI,SAAW,EACR,CACT,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,MAAO,CACL,IAAK,gBACL,OAAQ,CAAC,CACP,QACA,MACA,SAAU,IAEZ,SAAU,EAEd,IAAG,MAAK,SAAU,GAChB,OAAO,EAAG,IAAI,EAChB,GACF,CAUA,MAAM,WAAwB,KAC5B,MAAA,GACE,KAAK,KAAO,EAAW,QAAQ,SAAU,EAAK,EAAM,GAKlD,GAJoB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAES,iBAAR,GAAoB,MAAM,QAAQ,GAC3C,OAAO,EAAS,GAAY,KAE9B,KAAK,SAAS,CAAC,KAAM,CAAC,IAAO,EAAM,GAAU,EAAU,EAAI,KAC7D,IAAG,KAAK,MAER,KAAK,IAAM,EAAW,OAAO,SAAU,EAAK,EAAM,GAKhD,GAJoB,mBAAT,IACT,EAAK,EACL,EAAO,CAAC,GAES,iBAAR,GAAoB,MAAM,QAAQ,GAC3C,OAAO,EAAG,GAAY,KAGxB,GADA,GAAe,EAAI,KACf,GAAU,EAAI,MAAkC,mBAAnB,KAAK,UACpC,OAAI,EAAI,SACC,KAAK,aAAa,EAAK,GAEvB,KAAK,UAAU,EAAK,GAI/B,MAAM,EAAU,IACW,mBAAd,KAAK,OAA0C,IAAnB,EAAK,UAC1C,KAAK,KAAK,EAAK,EAAM,GAErB,KAAK,SAAS,CAAC,KAAM,CAAC,IAAO,EAAM,GAAU,EAAM,EAAI,KACzD,EAaF,IACM,EACA,EAGA,EACA,EAhBF,EAAK,OAAS,EAAI,MAWhB,EAAQ,EAAI,KAAK,MAAM,KACvB,EAAW,EAAM,GAGjB,EAFY,SAAS,EAAM,GAAI,IAEP,EACxB,EAAW,KAEf,EAAI,WAAa,CACf,MAAO,EACP,IAAK,CAAC,EAAU,IAElB,EAAI,KAAO,EAAY,IAAM,EAC7B,EAAK,WAAY,EArBjB,GAAO,SAAU,GACf,IAAI,EAAS,EAAM,KAAO,CAAC,IAAI,EAAM,GAAI,EAAI,IAAK,IAAK,EAAI,MAC3D,EAAG,EAAK,EACV,KAEA,EAAO,EAkBX,IAAG,KAAK,MAER,KAAK,cAAgB,EAAW,iBAAiB,SAAU,EAAO,EAAc,EAAK,EAAM,GACzF,IAAI,EAAM,KAiBV,SAAS,EAAiB,GACxB,IAAI,EAAa,SAAU,EAAM,SAAS,EAAI,KAAM,IAAM,EAO1D,OANA,EAAI,aAAe,EAAI,cAAgB,CAAC,EACxC,EAAI,aAAa,GAAgB,CAC/B,aAAc,EACd,KAAM,EACN,SAAU,GAEL,EAAI,IAAI,EACjB,CAEA,MA3BoB,mBAAT,IACT,EAAO,EACP,EAAO,EACP,EAAM,WAIY,IAAT,IACT,EAAO,EACP,EAAO,EACP,EAAM,MAEH,GACH,EAAe,OAAQ,aAAc,EAAc,cAAe,EAAO,2BAcpE,EAAI,IAAI,GAAO,MAAK,SAAU,GACnC,GAAI,EAAI,OAAS,EACf,MAAM,GAAY,GAGpB,OAAO,EAAiB,EAC1B,IAAG,SAAU,GAGX,GAAI,EAAI,SAAW,EAAY,QAC7B,OAAO,EAAiB,CAAC,IAAK,IAE9B,MAAM,CAEV,GACF,IAAG,KAAK,MAER,KAAK,iBAAmB,EAAW,oBAAoB,SAAU,EAAO,EAAc,EAAK,GACzF,KAAK,IAAI,GAAO,CAAC,EAAK,KAEpB,GAAI,EACF,EAAS,QAGX,GAAI,EAAI,OAAS,EAAjB,CAKA,IAAK,EAAI,aACP,OAAO,WAEF,EAAI,aAAa,GACqB,IAAzC,OAAO,KAAK,EAAI,cAAc,eACzB,EAAI,aAEb,KAAK,IAAI,EAAK,EATd,MAFE,EAAS,GAAY,GAWA,GAE3B,IAAG,KAAK,MAER,KAAK,OAAS,EAAW,UAAU,SAAU,EAAS,EAAW,EAAM,GACrE,IAAI,EACqB,iBAAd,GAET,EAAM,CACJ,IAAK,EACL,KAAM,GAEY,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,KAIV,EAAM,EACmB,mBAAd,GACT,EAAW,EACX,EAAO,CAAC,IAER,EAAW,EACX,EAAO,KAGX,EAAO,GAAQ,CAAC,GACX,YAAa,EAClB,IAAI,EAAS,CAAC,IAAK,EAAI,IAAK,KAAO,EAAI,MAAQ,EAAK,IACpD,UAAkB,GAClB,GAAI,GAAU,EAAO,MAAqC,mBAAtB,KAAK,aACvC,OAAO,KAAK,aAAa,EAAK,GAEhC,KAAK,SAAS,CAAC,KAAM,CAAC,IAAU,EAAM,GAAU,EAAU,EAAO,KACnE,IAAG,KAAK,MAER,KAAK,SAAW,EAAW,YAAY,SAAU,EAAK,EAAM,GACtC,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,IAAI,EAAM,OAAO,KAAK,GAEtB,IAAK,EAAI,OACP,OAAO,EAAS,KAAM,CAAC,GAGzB,IAAI,EAAQ,EACR,EAAU,IAAI,EAElB,SAAS,EAAa,EAAI,GACnB,EAAQ,IAAI,IACf,EAAQ,IAAI,EAAI,CAAC,QAAS,KAE5B,EAAQ,IAAI,GAAI,QAAQ,KAAK,EAC/B,CA2BA,EAAI,KAAI,SAAU,GAChB,KAAK,iBAAiB,GAAI,SAAU,EAAK,GACvC,GAAI,GAAsB,MAAf,EAAI,QAAkC,YAAhB,EAAI,QACnC,EAAQ,IAAI,EAAI,CAAC,QAAS,EAAI,SACzB,IAAI,EAET,OAAO,EAAS,IA/BtB,SAAoB,EAAI,GAEtB,IAAI,EAAe,EAAI,GAAI,MAAM,GACjC,GAAgB,GAAU,SAAU,EAAQ,EAAK,EAAS,EACxD,GACE,IAAI,EAAM,EAAM,IAAM,EAClB,EAAM,EAAa,QAAQ,IAClB,IAAT,IAIJ,EAAa,OAAO,EAAK,GAEL,cAAhB,EAAK,QACP,EAAa,EAAI,GAErB,IAIF,EAAa,SAAQ,SAAU,GAC7B,EAAa,EAAI,EACnB,GACF,CAUM,CAAW,EAAI,EACjB,CAEA,KAAM,IAAU,EAAI,OAAQ,CAE1B,IAAI,EAAa,CAAC,EAIlB,OAHA,EAAQ,SAAQ,SAAU,EAAO,GAC/B,EAAW,GAAO,CACpB,IACO,EAAS,KAAM,EACxB,CACF,GACF,GAAG,KACL,IAAG,KAAK,MASR,KAAK,QAAU,EAAW,WAAW,SAAU,EAAM,GACnD,EAAQ,KAAM,EAAM,EACtB,IAAG,KAAK,MAKR,KAAK,gBAAkB,EAAW,mBAAmB,SAAU,EAAO,EAAW,GAC/E,KAAK,iBAAiB,GAAO,CAAC,EAAK,KAEjC,GAAI,EACF,OAAO,EAAS,GAElB,IAAI,EA1WZ,SAAuB,GACrB,IAAI,EAAS,CAAC,EACV,EAAQ,GAoBZ,OAnBA,GAAgB,GAAM,SAAU,EAAQ,EAAK,EAAI,GAC/C,IAAI,EAAM,EAAM,IAAM,EAOtB,OANI,IACF,EAAO,GAAO,QAEH,IAAT,GACF,EAAM,KAAK,CAAC,KAAM,EAAM,GAAI,IAEvB,CACT,IAEA,EAAM,UACN,EAAM,SAAQ,SAAU,QACI,IAAtB,EAAO,EAAK,MACd,EAAO,EAAK,MAAQ,EAAI,EAAO,EAAK,IAEpC,EAAO,EAAK,MAAQ,KAAK,IAAI,EAAO,EAAK,MAAO,EAAI,EAAO,EAAK,IAEpE,IACO,CACT,CAmVqB,CAAc,GACvB,EAAa,GACb,EAAO,GACX,OAAO,KAAK,GAAQ,SAAQ,SAAU,GAChC,EAAO,GAAO,GAChB,EAAW,KAAK,EAEpB,IAEA,GAAgB,GAAS,SAAU,EAAQ,EAAK,EAAS,EAAK,GAC5D,IAAI,EAAM,EAAM,IAAM,EACF,cAAhB,EAAK,SAAuD,IAA7B,EAAW,QAAQ,IACpD,EAAK,KAAK,EAEd,IACA,KAAK,cAAc,EAAO,EAAM,EAAS,GAE7C,IAAG,KAAK,MAIR,KAAK,QAAU,EAAW,WAAW,SAAU,EAAM,GAC/B,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAGV,EAAO,GAAQ,CAAC,EAEhB,KAAK,iBAAmB,KAAK,kBAAoB,GACjD,KAAK,iBAAiB,KAAK,CAAC,KAAM,EAAM,SAAU,IACb,IAAjC,KAAK,iBAAiB,QACxB,GAAiB,KAErB,IAAG,KAAK,MAGR,KAAK,IAAM,EAAW,OAAO,SAAU,EAAI,EAAM,GAK/C,GAJoB,mBAAT,IACT,EAAK,EACL,EAAO,CAAC,GAEQ,iBAAP,EACT,OAAO,EAAG,GAAY,IAExB,GAAI,GAAU,IAAiC,mBAAnB,KAAK,UAC/B,OAAO,KAAK,UAAU,EAAI,GAE5B,IAAI,EAAS,GAEb,MAAM,EAAiB,KACrB,IAAI,EAAS,GACT,EAAQ,EAAO,OAEnB,IAAK,EACH,OAAO,EAAG,KAAM,GAIlB,EAAO,SAAS,IACd,KAAK,IAAI,EAAI,CACX,IAAK,EACL,KAAM,EAAK,KACX,OAAQ,EAAK,OACb,YAAa,EAAK,YAClB,OAAQ,EAAK,SACZ,SAAU,EAAK,GAChB,GAAK,EAaH,EAAO,KAAK,CAAC,QAAS,QAbd,CAGR,IADA,IAAI,EACK,EAAI,EAAG,EAAI,EAAO,OAAQ,EAAI,EAAG,IACxC,GAAI,EAAO,GAAG,IAAM,EAAO,GAAG,GAAG,OAAS,EAAI,KAAM,CAClD,GAAW,EACX,KACF,CAEG,GACH,EAAO,KAAK,CAAC,GAAI,GAErB,GAGA,GAEE,EAAG,KAAM,EAEb,GAAE,GACF,EAGJ,IAAI,EAAK,UA8BT,OAAO,KAAK,KAAK,EAAI,GAAM,CAAC,EAAK,KAC/B,GAAI,EAEF,OADA,EAAI,MAAQ,EACL,EAAG,GAGZ,IAAI,EAAM,EAAO,IACb,EAAW,EAAO,SAClB,EAAM,EAAO,IAEjB,GAAI,EAAK,UAAW,CAClB,IAAI,EAAY,GAAiB,GAC7B,EAAU,SACZ,EAAI,WAAa,EAErB,CAMA,GAJI,GAAU,EAAU,EAAI,QAC1B,EAAI,UAAW,GAGb,EAAK,MAAQ,EAAK,UAAW,CAQ/B,IAPA,IAAI,EAAc,EAAI,KAAK,MAAM,KAC7B,EAAc,SAAS,EAAY,GAAI,IACvC,EAAc,EAAY,GAE1B,EAAQ,GAAW,EAAS,UAC5B,EAAO,KAEF,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACrC,IAAI,EAAc,EAAM,GACpB,EAAY,EAAY,IAAI,KAAI,SAAU,GAAK,OAAO,EAAE,EAAI,IAC7D,QAAQ,IACa,IAAe,EAAQ,IAEpB,IAAuB,IAAf,KACjC,EAAO,EAEX,CAGA,IAAK,EAGH,OAFA,EAAM,IAAI,MAAM,qBACZ,MAAQ,EACL,EAAG,GAGZ,IAAI,EAAa,EAAK,IAAI,KAAI,SAAU,GAAK,OAAO,EAAE,EAAI,IACvD,QAAQ,EAAI,KAAK,MAAM,KAAK,IAAM,EACjC,EAAU,EAAK,IAAI,OAAS,EAYhC,GAXA,EAAK,IAAI,OAAO,EAAY,GAC5B,EAAK,IAAI,UAEL,EAAK,OACP,EAAI,WAAa,CACf,MAAQ,EAAK,IAAM,EAAK,IAAI,OAAU,EACtC,IAAK,EAAK,IAAI,KAAI,SAAU,GAC1B,OAAO,EAAI,EACb,MAGA,EAAK,UAAW,CAClB,IAAI,EAAO,EAAK,IAAM,EAAK,IAAI,OAC/B,EAAI,WAAa,EAAK,IAAI,KAAI,SAAU,GAEtC,MAAO,CACL,MAFF,EAEa,IAAM,EAAI,GACrB,OAAQ,EAAI,KAAK,OAErB,GACF,CACF,CAEA,GAAI,EAAK,aAAe,EAAI,aAAc,CACxC,IAAI,EAAc,EAAI,aAClB,EAAQ,OAAO,KAAK,GAAa,OACrC,GAAc,IAAV,EACF,OAAO,EAAG,KAAM,GAElB,OAAO,KAAK,GAAa,SAAS,IAChC,KAAK,eAAe,EAAI,IAAK,EAAK,EAAY,GAAM,CAIlD,IAAK,EAAI,KACT,OAAQ,EAAK,OACb,IAAK,IACJ,SAAU,EAAK,GAChB,IAAI,EAAM,EAAI,aAAa,GAC3B,EAAI,KAAO,SACJ,EAAI,YACJ,EAAI,SACJ,GACL,EAAG,KAAM,EAEb,GAAE,GAEN,KAAO,CACL,GAAI,EAAI,aACN,IAAK,IAAI,KAAO,EAAI,aAEd,OAAO,UAAU,eAAe,KAAK,EAAI,aAAc,KACzD,EAAI,aAAa,GAAK,MAAO,GAInC,EAAG,KAAM,EACX,KAxIA,GAAuB,QAAnB,EAAK,UACP,KAAK,iBAAiB,GAAI,SAAU,EAAK,GAEvC,GAAI,EACF,OAAO,EAAG,GAEZ,EAAS,GAAc,GAAU,KAAI,SAAU,GAC7C,OAAO,EAAK,GACd,IACA,GACF,QACK,CACL,IAAI,MAAM,QAAQ,EAAK,WAWrB,OAAO,EAAG,GAAY,EAAe,oBAVrC,EAAS,EAAK,UACd,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAI,EAAI,EAAO,GAEf,GAAqB,iBAAR,IAAoB,QAAQ,KAAK,GAC5C,OAAO,EAAG,GAAY,IAE1B,CACA,GAIJ,CAiHJ,IAAG,KAAK,MAKR,KAAK,cAAgB,EAAW,iBAAiB,SAAU,EAAO,EAAc,EAAM,GAChF,aAAgB,WAClB,EAAW,EACX,EAAO,CAAC,GAEV,KAAK,KAAK,EAAO,GAAM,CAAC,EAAK,IACvB,EACK,EAAS,GAEd,EAAI,IAAI,cAAgB,EAAI,IAAI,aAAa,IAC/C,EAAK,IAAM,EAAI,IACf,EAAK,QAAS,OACd,KAAK,eAAe,EAAO,EACP,EAAI,IAAI,aAAa,GAAe,EAAM,IAEvD,EAAS,GAAY,KAGlC,IAAG,KAAK,MAER,KAAK,QAAU,EAAW,WAAW,SAAU,EAAM,GAYnD,GAXoB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,EAAK,UAA4B,IAAd,EAAK,KAAuB,EAAK,KAAO,EACvD,EAAK,YACP,EAAK,SAAW,EAAK,WAEnB,EAAK,UACP,EAAK,OAAS,EAAK,SAEjB,SAAU,EAAM,CAClB,IAAK,MAAM,QAAQ,EAAK,MACtB,OAAO,EAAS,IAAI,UAAU,kCAEhC,IAAI,EACF,CAAC,WAAY,SAAU,OAAO,QAAO,SAAU,GAC/C,OAAO,KAAmB,CAC5B,IAAG,GACH,GAAI,EAKF,YAJA,EAAS,GAAY,EACnB,oBAAsB,EACtB,uCAIJ,IAAK,GAAS,QA1mBtB,SAA0B,GACxB,IAAI,EAAS,UAAW,EACtB,EAAK,KAAK,MAAM,EAAK,KAAM,EAAK,MAAQ,EAAK,MAC5C,EAAK,KAAO,EAAK,EAAK,KAAK,MAAM,EAAK,MAAQ,EAAK,KACtD,EAAK,KAAO,EACZ,EAAK,KAAO,SACL,EAAK,MACR,EAAK,aACP,EAAK,UACL,EAAK,YAAa,EAEtB,CAgmBU,CAAiB,GACQ,IAArB,EAAK,KAAK,QACZ,OAAO,KAAK,SAAS,CAAC,MAAO,GAAI,EAGvC,CAEA,OAAO,KAAK,SAAS,EAAM,EAC7B,IAAG,KAAK,MAER,KAAK,MAAQ,EAAW,SAAS,SAAU,GAGzC,OAFA,KAAK,SAAU,EACf,KAAK,KAAK,UACH,KAAK,OAAO,EACrB,IAAG,KAAK,MAER,KAAK,KAAO,EAAW,QAAQ,SAAU,GACvC,KAAK,OAAM,CAAC,EAAK,KACf,GAAI,EACF,OAAO,EAAS,GAGlB,EAAK,QAAU,EAAK,SAAW,KAAK,KACpC,EAAK,mBAAqB,KAAK,iBAAoB,GAAS,OAC5D,EAAK,QAAU,KAAK,QACpB,EAAS,KAAM,EAAK,GAExB,IAAG,KAAK,MAER,KAAK,GAAK,EAAW,MAAM,SAAU,GACnC,OAAO,KAAK,IAAI,EAClB,IAAG,KAAK,MAER,KAAK,SAAW,EAAW,YAAY,SAAU,EAAK,EAAM,GAc1D,GAboB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAGV,EAAO,GAAQ,CAAC,EAEZ,MAAM,QAAQ,KAChB,EAAM,CACJ,KAAM,KAIL,IAAQ,EAAI,OAAS,MAAM,QAAQ,EAAI,MAC1C,OAAO,EAAS,GAAY,IAG9B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,KAAK,SAAU,EACrC,GAA2B,iBAAhB,EAAI,KAAK,IAAmB,MAAM,QAAQ,EAAI,KAAK,IAC5D,OAAO,EAAS,GAAY,KAIhC,IAAI,EAYJ,GAXA,EAAI,KAAK,SAAQ,SAAU,GACrB,EAAI,cACN,OAAO,KAAK,EAAI,cAAc,SAAQ,SAAU,GAC9C,EAAkB,GA/lB9B,SAA6B,GAC3B,MAAuB,MAAnB,EAAK,OAAO,IACP,2EAIX,CAylBiD,CAAoB,GACpD,EAAI,aAAa,GAAM,cAC1B,EAAe,OAAQ,aAAc,EAAM,cAAe,EAAI,IAAK,0BAEvE,GAEJ,IAEI,EACF,OAAO,EAAS,GAAY,GAAa,IAGrC,cAAe,IAEjB,EAAK,YADH,cAAe,IACA,EAAI,WAMzB,IAAI,EAAU,KACT,EAAK,WAAc,GAAS,IAG/B,EAAI,KAAK,KAAK,IAvvBtB,SAAmB,GACjB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,OAAQ,IAAK,CACpC,IAAI,EAAM,EAAK,GACf,GAAI,EAAI,gBACC,EAAI,kBACN,GAAI,EAAI,aAGb,IADA,IAAI,EAAO,OAAO,KAAK,EAAI,cAClB,EAAI,EAAG,EAAI,EAAK,OAAQ,IAAK,CACpC,IAAI,EAAM,EAAK,GACf,EAAI,aAAa,GAAO,EAAK,EAAI,aAAa,GAC5C,CAAC,OAAQ,SAAU,eAAgB,SAAU,SAAU,QAC3D,CAEJ,CACF,CA2uBM,CAAU,EAAI,MAKd,IAAI,EAAM,EAAI,KAAK,KAAI,SAAU,GAC/B,OAAO,EAAI,GACb,IAEA,KAAK,UAAU,EAAK,GAAM,SAAU,EAAK,GACvC,GAAI,EACF,OAAO,EAAS,GASlB,GAPK,EAAK,YAER,EAAM,EAAI,QAAO,SAAU,GACzB,OAAO,EAAE,KACX,MAGG,GAAS,GACZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,OAAQ,EAAI,EAAG,IACrC,EAAI,GAAG,GAAK,EAAI,GAAG,IAAM,EAAI,GAIjC,EAAS,KAAM,EACjB,GACF,IAAG,KAAK,MAER,KAAK,0BAA4B,EAAW,6BAA6B,SAAU,EAAa,GAC9F,IAAI,EAAY,EAAM,KAAK,QACvB,KAAK,OAAO,eACd,EAAU,QAAU,KAAK,OAAO,cAGlC,IAAI,EAAQ,IAAI,KAAK,YAAY,EAAa,GAU9C,GAAO,KAAM,8BARb,SAAiB,GAEf,OADA,EAAI,aAAe,EAAI,cAAgB,CAAC,GACpC,EAAI,aAAa,KAGrB,EAAI,aAAa,IAAe,EACzB,EACT,IACoD,MAAK,WACvD,EAAS,KAAM,CAAC,GAAI,GACtB,IAAG,MAAM,EACX,IAAG,KAAK,MAER,KAAK,QAAU,EAAW,WAAW,SAAU,EAAM,GAE/B,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAGV,IAAI,IAAY,eAAgB,OAAO,KAAK,WAE5C,MAAM,EAAY,KAEhB,KAAK,SAAS,GAAM,CAAC,EAAK,KACxB,GAAI,EACF,OAAO,EAAS,GAElB,KAAK,YAAa,EAClB,KAAK,KAAK,aACV,EAAS,KAAM,GAAQ,CAAE,IAAM,GAAO,GACtC,EAGJ,GAAI,GAAS,MAEX,OAAO,IAGT,KAAK,IAAI,8BAA8B,CAAC,EAAK,KAC3C,GAAI,EAEF,OAAmB,MAAf,EAAI,OACC,EAAS,GAET,IAGX,IAAI,EAAe,EAAS,aACxB,EAAU,KAAK,YACf,EAAa,OAAO,KAAK,GAAc,KAAK,IAG9C,IAAI,EAAW,EACb,EAAK,QAAQ,IAAI,OAAO,IAAM,EAAQ,QAAS,IAAM,EACvD,OAAO,IAAI,EAAQ,EAAU,KAAK,QAAQ,SAAS,IAErD,QAAQ,IAAI,GAAY,KAAK,EAAW,EAAS,GAErD,IAAG,KAAK,KACV,CAEA,QAAA,CAAS,EAAM,GACb,IAMI,EANA,EAAc,CAChB,aAAa,EACb,SAAU,EAAK,UAAY,GAEzB,EAAW,GAGX,EAAgB,EAEpB,MAAM,EAAY,IAChB,KAAK,YAAY,OAAO,EAAQ,CAC9B,kBAAmB,IAErB,EAAS,KAAK,KAAK,gBAAgB,EAAI,GAAI,GAAG,EAE1C,EAAW,IACf,KAAK,YAAY,OAAO,EAAQ,GAChC,EAAS,EAAI,EAET,EAAc,IAClB,IAAI,EAAU,EAAK,SACnB,QAAQ,IAAI,GAAU,MAAK,IAClB,GAAO,KAAM,qBAAsB,KACnC,EAAI,UAAY,EAAI,SAAW,KAClC,EAAI,SAAW,EACR,OAIV,MAAK,KACN,KAAK,YAAY,OAAO,GACxB,EAAS,KAAM,CAAC,IAAI,GAAM,IACzB,MAAM,EAAQ,EAGnB,KAAK,OAAO,MAAM,IAChB,EAAS,KAAK,YAAY,IAAI,CAC5B,KAAM,sBACN,YAAa,EAAK,WAAa,EAAY,WAG7C,KAAK,QAAQ,GACV,GAAG,SAAU,GACb,GAAG,WAAY,GACf,GAAG,QAAS,EAAQ,GAE3B,CAEA,OAAA,CAAQ,EAAM,GAaZ,MAZoB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,IAGV,EAAO,GAAQ,CAAC,GAKX,YAAe,gBAAiB,EAAQ,EAAK,aAAe,EAAK,KAE/D,IAAI,GAAU,KAAM,EAAM,EACnC,CAEA,IAAA,GACE,MAA8B,mBAAf,KAAK,MAAwB,KAAK,QAAU,KAAK,OAClE,EAKF,GAAgB,UAAU,MAAQ,EAAW,UAAU,SAAU,EAAO,EAAK,GAC3E,QAA2B,IAAhB,KAAK,OACd,OAAO,EAAS,GAAY,EAAe,mCAAqC,KAAK,QAAU,cAEjG,IAAI,EAAO,KAEX,EAAK,iBAAiB,GAAO,CAAC,EAAO,KACnC,GAAI,EACF,OAAO,EAAS,GAElB,IAAK,EACH,OAAO,EAAS,GAAY,IAE9B,IAAI,EACJ,IACE,EAhhDN,SAAwB,EAAM,GAC5B,IAAI,EAAO,GACX,MAAM,EAAU,EAAK,QAErB,IAAI,EACJ,KAAQ,EAAO,EAAQ,OAAQ,CAC7B,MAAM,IAAE,EAAK,IAAK,GAAS,EACrB,EAAM,GAAG,KAAO,EAAK,KACrB,EAAW,EAAK,GAMtB,GAHA,EAAK,KAAK,GAGN,IAAQ,EAAW,CAErB,GAAwB,IAApB,EAAS,OACX,MAAM,IAAI,MAAM,wCAElB,OAAO,EAAK,SACd,EAKwB,IAApB,EAAS,QAAgB,EAAS,OAAS,KAC7C,EAAO,IAIT,IAAK,IAAI,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAC9C,EAAQ,KAAK,CAAE,IAAK,EAAM,EAAG,IAAK,EAAS,IAE/C,CACA,GAAoB,IAAhB,EAAK,OACP,MAAM,IAAI,MAAM,yCAElB,OAAO,EAAK,SACd,CA0+Ca,CAAe,EAAM,EAC9B,CAAE,MAAO,GACP,OAAO,EAAS,EAAM,SAAW,EACnC,CACA,EAAK,OAAO,EAAO,GAAM,CAAC,EAAO,KAC/B,GAAI,EACF,OAAO,EAAS,GAEhB,GAAe,EAAM,EAAO,GAAK,MAAK,WACpC,OAAO,EAAS,KAAM,EACxB,GACF,GACA,GAEN,IAEA,MAAM,GACJ,WAAA,GACE,KAAK,SAAU,EACf,KAAK,QAAS,EACd,KAAK,MAAQ,EACf,CAEA,OAAA,GACE,IAAI,EACJ,GAAI,KAAK,OACP,KAAQ,EAAM,KAAK,MAAM,SACvB,EAAI,KAAK,aAGX,KAAQ,EAAM,KAAK,MAAM,SACvB,GAGN,CAEA,IAAA,CAAK,GACH,KAAK,OAAS,EACd,KAAK,SACP,CAEA,KAAA,CAAM,GACJ,KAAK,SAAU,EACf,KAAK,GAAK,EACV,KAAK,SACP,CAEA,OAAA,CAAQ,GACN,KAAK,MAAM,KAAK,GACZ,KAAK,QACP,KAAK,SAET,EAoDF,SAAS,GAAY,EAAQ,GAC3B,IAAI,EAAQ,YAAa,GACvB,KAAM,gBAAgB,GACpB,OAAO,IAAI,KAAS,GAEtB,EAAK,MAAM,KAAM,EACnB,EAZF,IAAkB,EAAG,EAcnB,OAdmB,EAaH,GAbA,EAaP,GAZP,UAAY,OAAO,OAAO,EAAE,UAAW,CACvC,YAAa,CAAE,MAAO,KAYjB,CACT,CA+BA,MAAM,WAAsB,GAC1B,WAAA,CAAY,EAAM,GAChB,QACA,KAAK,OAAO,EAAM,EACpB,CAEA,MAAA,CAAO,EAAM,GAoBX,GAnBA,MAAM,SACN,EAAO,GAAQ,CAAC,EAEZ,GAAwB,iBAAT,IAEjB,GADA,EAAO,GACK,YACL,EAAK,WAGkB,IAA5B,EAAK,qBACP,EAAK,oBAAqB,GAG5B,KAAK,OAAS,EAAO,EAAM,GAE3B,KAAK,gBAAkB,EAAK,gBAC5B,KAAK,mBAAqB,EAAK,oBAAsB,IACrD,KAAK,OAAS,GAAQ,OAEF,iBAAT,EACT,MAAM,IAAI,MAAM,2BAGlB,IACI,EAxHR,SAAsB,EAAM,GAC1B,IAAI,EAAQ,EAAK,MAAM,sBACvB,GAAI,EAEF,MAAO,CACL,KAAM,SAAS,KAAK,EAAM,IAAM,EAAM,GAAK,MAAQ,EAAM,GAAK,EAAM,GACpE,QAAS,EAAM,IAInB,IAAI,EAAW,GAAQ,SACnB,EAAoB,GAAQ,kBAC5B,EAAS,GAAQ,OACjB,EAAc,EAAK,QAEvB,IAAK,EACH,IAAK,IAAI,EAAI,EAAG,EAAI,EAAkB,QAIhB,SAHpB,EAAc,EAAkB,KAGH,WAAY,GACrC,KAAqB,aAAa,oBAAsB,EAAS,KALvB,EAO5C,EAAe,MAAO,2BAA6B,EAA7B,8EAQ5B,IAAI,EAAU,EAAS,GAMvB,MAAO,CACL,KAJe,GAAW,eAAgB,IAC1C,EAAQ,WAG4B,EAAjB,EAAS,EAC5B,QAAS,EAEb,CA+EkB,EADM,EAAK,QAAU,IAAM,EACA,GASzC,GAPA,EAAK,KAAO,EAAQ,KACpB,EAAK,QAAU,EAAK,SAAW,EAAQ,QAEvC,KAAK,KAAO,EACZ,KAAK,SAAW,EAAK,QACrB,GAAQ,KAAK,QAAS,CAAC,UAAW,mBAAoB,EAAK,WAEtD,GAAQ,SAAS,EAAK,WACtB,GAAQ,SAAS,EAAK,SAAS,QAClC,MAAM,IAAI,MAAM,oBAAsB,EAAK,SAG7C,GAAI,EAAK,gBACF,GAAQ,SAAS,EAAK,gBACtB,GAAQ,SAAS,EAAK,cAAc,SACvC,MAAM,IAAI,MAAM,yBAA2B,EAAK,cAIpD,KAAK,UAAY,IAAI,GAErB,KAAK,QAAU,EAAK,QAEpB,GAAQ,SAAS,EAAK,SAAS,KAAK,KAAM,GAAO,IAC/C,GAAI,EACF,OAAO,KAAK,UAAU,KAAK,IA7EnC,SAA+B,GAE7B,SAAS,EAAY,GACnB,EAAK,eAAe,SAAU,GACzB,GACH,EAAK,YAAY,KAAK,YAAa,EAAK,KAE5C,CAEA,SAAS,IACP,EAAK,eAAe,YAAa,GACjC,EAAK,YAAY,KAAK,QAAS,EACjC,CAEA,EAAK,KAAK,YAAa,GACvB,EAAK,KAAK,SAAU,GACpB,EAAK,YAAY,KAAK,MAAO,EAC/B,CA8DM,CAAsB,MAEtB,KAAK,KAAK,UAAW,MACrB,GAAQ,KAAK,UAAW,KAAK,MAC7B,KAAK,UAAU,MAAM,KAAK,GAE9B,EAGF,MAAM,GAAU,GAAY,IAAe,SAAU,EAAM,GACzD,GAAc,UAAU,OAAO,KAAK,KAAM,EAAM,EAClD,IAIA,IAAI,GAAgC,oBAApB,gBACV,gBACA,WAAc,MAAO,CAAC,MAAO,WAAa,EAAI,EAEhD,GAAM,MACN,GAAI,QAiDR,GAAQ,SAAW,CAAC,EACpB,GAAQ,kBAAoB,GAE5B,GAAQ,OAAS,UAEjB,IAAI,GAAe,IAAI,MAEvB,SAA2B,GACzB,OAAO,KAAK,eAAc,SAAQ,SAAU,GACT,mBAAtB,cAAa,KACtB,EAAM,GAAO,GAAa,GAAK,KAAK,IAExC,IAIA,IAAI,EAAoB,EAAM,sBAAwB,IAAI,EAE1D,EAAM,GAAG,OAAO,SAA0B,GACnC,EAAkB,IAAI,EAAG,OAC5B,EAAkB,IAAI,EAAG,KAAM,IAEjC,EAAkB,IAAI,EAAG,MAAM,KAAK,EACtC,IAEA,EAAM,GAAG,SAAS,SAA4B,GAC5C,GAAK,EAAkB,IAAI,EAAG,MAA9B,CAGA,IAAI,EAAS,EAAkB,IAAI,EAAG,MAClC,EAAM,EAAO,QAAQ,GACrB,EAAM,IAIV,EAAO,OAAO,EAAK,GACf,EAAO,OAAS,EAElB,EAAkB,IAAI,EAAG,KAAM,GAE/B,EAAkB,OAAO,EAAG,MAZ9B,CAcF,IAEA,EAAM,GAAG,aAAa,SAAgC,GACpD,GAAK,EAAkB,IAAI,GAA3B,CAGA,IAAI,EAAS,EAAkB,IAAI,GACnC,EAAkB,OAAO,GACzB,EAAO,SAAQ,SAAU,GACvB,EAAG,KAAK,aAAY,EACtB,GALA,CAMF,GACF,CAEA,CAAkB,IAElB,GAAQ,QAAU,SAAU,EAAI,EAAK,GAE/B,EAAI,UACN,GAAQ,SAAS,GAAM,EACnB,GACF,GAAQ,kBAAkB,KAAK,GAGrC,EAEA,GAAQ,OAAS,SAAU,GACzB,GAAmB,mBAAR,EACT,EAAI,QACC,IAAmB,iBAAR,GAAgD,IAA5B,OAAO,KAAK,GAAK,OACrD,MAAM,IAAI,MAAM,wBAA0B,EAAM,uCAEhD,OAAO,KAAK,GAAK,SAAQ,SAAU,GACjC,GAAQ,UAAU,GAAM,EAAI,EAC9B,GACF,CAIA,OAHI,KAAK,aACP,GAAQ,WAAa,EAAsB,CAAC,EAAG,KAAK,aAE/C,EACT,EAEA,GAAQ,SAAW,SAAU,GAC3B,IAAI,EAAoB,GAAY,IAAS,SAAU,EAAM,GAC3D,EAAO,GAAQ,CAAC,EAEZ,GAAwB,iBAAT,IAEjB,GADA,EAAO,GACK,YACL,EAAK,MAGd,EAAO,EAAsB,CAAC,EAAG,EAAkB,WAAY,GAC/D,GAAQ,KAAK,KAAM,EAAM,EAC3B,IAaA,OAXA,EAAkB,kBAAoB,GAAQ,kBAAkB,QAChE,OAAO,KAAK,IAAS,SAAQ,SAAU,GAC/B,KAAO,IACX,EAAkB,GAAO,GAAQ,GAErC,IAIA,EAAkB,WAAa,EAAsB,CAAC,EAAG,KAAK,WAAY,GAEnE,CACT,EAEA,GAAQ,MAAQ,SAAU,EAAK,GAC7B,OAAO,GAAI,EAAK,EAClB,EAEA,GAAQ,UAAU,YAAc,GAAQ,YAAc,IAnKtD,MACE,WAAA,GACE,KAAK,MAAQ,CAAC,CAChB,CAEA,IAAA,GACE,OAAO,OAAO,OAAO,KAAK,MAC5B,CAEA,GAAA,CAAI,GACF,MAAM,EAAK,IAOX,OANA,KAAK,MAAM,GAAM,CACf,KACA,KAAM,EAAK,KACX,YAAa,EAAK,YAClB,YAAY,IAAI,MAAO,UAElB,CACT,CAEA,GAAA,CAAI,GACF,OAAO,KAAK,MAAM,EACpB,CAGA,MAAA,CAAO,EAAI,GAET,cADO,KAAK,MAAM,GACX,KAAK,KACd,CAEA,MAAA,CAAO,EAAI,GACT,MAAM,EAAO,KAAK,MAAM,GACxB,QAAoB,IAAT,EAAsB,CAC/B,MAAM,EAAa,CACjB,GAAI,EAAK,GACT,KAAM,EAAK,KACX,WAAY,EAAK,WACjB,YAAa,EAAY,aAAe,EAAK,YAC7C,gBAAiB,EAAY,iBAAmB,EAAK,gBACrD,YAAY,IAAI,MAAO,UAEzB,KAAK,MAAM,GAAM,CACnB,CACA,OAAO,KAAK,KACd,GA8HF,SAAS,GAAgB,EAAK,GAE5B,IADA,IAAI,EAAQ,EACH,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAAK,CAGtD,KADA,EAAQ,EADE,EAAY,KAGpB,KAEJ,CACA,OAAO,CACT,CAOA,SAAS,GAAW,GAIlB,IAFA,IAAI,EAAS,GACT,EAAU,GACL,EAAI,EAAG,EAAM,EAAU,OAAQ,EAAI,EAAK,IAAK,CACpD,IAAI,EAAK,EAAU,GACf,EAAI,GAA0B,OAArB,EAAU,EAAI,KAAuB,MAAP,GAAqB,MAAP,GAEvD,EAAU,EAAQ,UAAU,EAAG,EAAQ,OAAS,GAAK,EACrC,MAAP,GAET,EAAO,KAAK,GACZ,EAAU,IAEV,GAAW,CAEf,CAEA,OADA,EAAO,KAAK,GACL,CACT,CAEA,IAAI,GAAoB,CAAC,MAAO,OAAQ,QACxC,SAAS,GAAqB,GAC5B,OAAO,GAAkB,QAAQ,IAAU,CAC7C,CAEA,SAAS,GAAO,GACd,OAAO,OAAO,KAAK,GAAK,EAC1B,CAQA,SAAS,GAAoB,GAK3B,IAAI,EAAM,CAAC,EACP,EAAQ,CAAC,KAAK,EAAM,MAAM,GA4D9B,OA1DA,EAAU,SAAQ,SAAU,GAC1B,OAAO,KAAK,GAAU,SAAQ,SAAU,GACtC,IAAI,EAAU,EAAS,GAKvB,GAJuB,iBAAZ,IACT,EAAU,CAAC,IAAK,IAGd,GAAqB,GAEvB,GAAI,aAAmB,MAAO,CAC5B,GAAI,EAAM,GAGR,OAFA,EAAM,IAAS,OACf,EAAI,GAAS,GAIf,IAAI,EAAU,GACd,EAAI,GAAO,SAAQ,SAAU,GAC3B,OAAO,KAAK,GAAS,SAAQ,SAAU,GACrC,IAAI,EAAI,EAAQ,GACZ,EAAU,KAAK,IAAI,OAAO,KAAK,GAAU,OAAQ,OAAO,KAAK,GAAG,QAChE,EAAS,GAAoB,CAAC,EAAU,IACxC,OAAO,KAAK,GAAQ,QAAU,GAMlC,EAAQ,KAAK,EACf,GACF,IACA,EAAI,GAAS,CACf,MAEE,EAAI,GAAS,GAAoB,CAAC,QAE/B,CACL,IAAI,EAAgB,EAAI,GAAS,EAAI,IAAU,CAAC,EAChD,OAAO,KAAK,GAAS,SAAQ,SAAU,GACrC,IAAI,EAAQ,EAAQ,GAEpB,MAAiB,QAAb,GAAmC,SAAb,EAuBpC,SAAoB,EAAU,EAAO,GACnC,QAAiC,IAAtB,EAAc,IACvB,YAEgC,IAAvB,EAAc,KACN,SAAb,EACE,EAAQ,EAAc,OACxB,EAAc,KAAO,GAGnB,GAAS,EAAc,cAClB,EAAc,KACrB,EAAc,IAAM,QAGc,IAAtB,EAAc,IACb,SAAb,EACE,EAAQ,EAAc,aACjB,EAAc,IACrB,EAAc,KAAO,GAGnB,EAAQ,EAAc,MACxB,EAAc,IAAM,GAIxB,EAAc,GAAY,CAE9B,CAnDmB,CAAW,EAAU,EAAO,GACb,QAAb,GAAmC,SAAb,EAqD3C,SAAoB,EAAU,EAAO,GACnC,QAAiC,IAAtB,EAAc,IACvB,YAEgC,IAAvB,EAAc,KACN,SAAb,EACE,EAAQ,EAAc,OACxB,EAAc,KAAO,GAGnB,GAAS,EAAc,cAClB,EAAc,KACrB,EAAc,IAAM,QAGc,IAAtB,EAAc,IACb,SAAb,EACE,EAAQ,EAAc,aACjB,EAAc,IACrB,EAAc,KAAO,GAGnB,EAAQ,EAAc,MACxB,EAAc,IAAM,GAIxB,EAAc,GAAY,CAE9B,CAjFmB,CAAW,EAAU,EAAO,GACb,QAAb,EAmFrB,SAAiB,EAAO,GAClB,QAAS,EAEX,EAAc,IAAI,KAAK,GAEvB,EAAc,IAAM,CAAC,EAEzB,CAzFmB,CAAQ,EAAO,GACA,QAAb,EA2FrB,SAAiB,EAAO,UAGf,EAAc,WACd,EAAc,YACd,EAAc,WACd,EAAc,YACd,EAAc,IACrB,EAAc,IAAM,CACtB,CAnGmB,CAAQ,EAAO,GACA,WAAb,EAqGrB,SAAoB,EAAO,GACrB,WAAY,EAEd,EAAc,OAAO,KAAK,GAE1B,EAAc,OAAS,CAAC,EAE5B,CA3GmB,CAAW,EAAO,QAE3B,EAAc,GAAY,EAC5B,GACF,CACF,GACF,IAEO,CACT,CAqGA,SAAS,GAA0B,GAC/B,IAAK,IAAI,KAAQ,EAAK,CAClB,GAAI,MAAM,QAAQ,GACd,IAAK,IAAI,KAAK,EACN,EAAI,GAAS,OACb,EAAI,GAAK,GAAoB,EAAI,GAAS,OAItD,IAAI,EAAQ,EAAI,GACK,iBAAV,GACP,GAA0B,EAElC,CACA,OAAO,CACX,CAGA,SAAS,GAAgB,EAAK,GAC1B,IAAK,IAAI,KAAQ,EAAK,CACL,SAAT,IACA,GAAQ,GAEZ,IAAI,EAAQ,EAAI,GACK,iBAAV,IACP,EAAQ,GAAgB,EAAO,GAEvC,CACA,OAAO,CACX,CAKA,SAAS,GAAgB,GACvB,IAAI,EAAS,EAAM,GAGf,GAAgB,GAAQ,IAEtB,SADJ,EAAS,GAA0B,MAEjC,EAAS,GAAoB,EAAa,OAI9C,CAAC,MAAO,QAAQ,SAAQ,SAAU,GAC5B,KAAW,GAGb,EAAO,GAAS,SAAQ,SAAU,GAEhC,IADA,IAAI,EAAS,OAAO,KAAK,GAChB,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAI,EAAQ,EAAO,GACf,EAAU,EAAY,GACH,iBAAZ,GAAoC,OAAZ,IACjC,EAAY,GAAS,CAAC,IAAK,GAE/B,CACF,GAEJ,IAEI,SAAU,IAGZ,EAAa,KAAI,GAAoB,CAAC,EAAa,QAKrD,IAFA,IAAI,EAAS,OAAO,KAAK,GAEhB,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAI,EAAQ,EAAO,GACf,EAAU,EAAO,GAEE,iBAAZ,GAAoC,OAAZ,IACjC,EAAU,CAAC,IAAK,IAElB,EAAO,GAAS,CAClB,CAIA,OAFA,GAAwB,GAEjB,CACT,CAMA,SAAS,GAAwB,GAC/B,OAAO,KAAK,GAAU,SAAQ,SAAU,GACtC,IAAI,EAAU,EAAS,GAEnB,MAAM,QAAQ,GAChB,EAAQ,SAAQ,SAAU,GACpB,GAAsC,iBAAhB,GACxB,GAAwB,EAE5B,IACmB,QAAV,EACT,EAAS,IAAM,CAAC,GACG,WAAV,EACT,EAAS,OAAS,CAAC,GACV,GAA8B,iBAAZ,GAC3B,GAAwB,EAE5B,GACF,CAiBA,IAAI,IAAiB,IACjB,GAAmB,EACnB,GAAM,GAEV,SAAS,GAAQ,EAAG,GAElB,GAAI,IAAM,EACR,OAAO,EAGT,EAAI,GAAa,GACjB,EAAI,GAAa,GAEjB,IAAI,EAAK,GAAe,GACpB,EAAK,GAAe,GACxB,GAAK,EAAK,GAAQ,EAChB,OAAO,EAAK,EAEd,cAAe,GACb,IAAK,SACH,OAAO,EAAI,EACb,IAAK,UACH,OAAO,EAAI,GAAK,EAAI,EACtB,IAAK,SACH,OAsPN,SAAuB,EAAG,GAIxB,OAAQ,IAAM,EAAK,EAAM,EAAI,EAAK,GAAK,CACzC,CA3Pa,CAAc,EAAG,GAE5B,OAAO,MAAM,QAAQ,GAyOvB,SAAsB,EAAG,GAEvB,IADA,IAAI,EAAM,KAAK,IAAI,EAAE,OAAQ,EAAE,QACtB,EAAI,EAAG,EAAI,EAAK,IAAK,CAC5B,IAAI,EAAO,GAAQ,EAAE,GAAI,EAAE,IAC3B,GAAa,IAAT,EACF,OAAO,CAEX,CACA,OAAQ,EAAE,SAAW,EAAE,OAAU,EAC9B,EAAE,OAAS,EAAE,OAAU,GAAK,CACjC,CAnP4B,CAAa,EAAG,GA0P5C,SAAuB,EAAG,GAGxB,IAFA,IAAI,EAAK,OAAO,KAAK,GAAI,EAAK,OAAO,KAAK,GACtC,EAAM,KAAK,IAAI,EAAG,OAAQ,EAAG,QACxB,EAAI,EAAG,EAAI,EAAK,IAAK,CAE5B,IAAI,EAAO,GAAQ,EAAG,GAAI,EAAG,IAC7B,GAAa,IAAT,EACF,OAAO,EAIT,GAAa,KADb,EAAO,GAAQ,EAAE,EAAG,IAAK,EAAE,EAAG,MAE5B,OAAO,CAGX,CACA,OAAQ,EAAG,SAAW,EAAG,OAAU,EAChC,EAAG,OAAS,EAAG,OAAU,GAAK,CACnC,CA5QiD,CAAc,EAAG,EAClE,CAIA,SAAS,GAAa,GACpB,cAAe,GACb,IAAK,YACH,OAAO,KACT,IAAK,SACH,OAAI,IAAQ,KAAY,KAAS,KAAY,MAAM,GAC1C,KAEF,EACT,IAAK,SACH,IAAI,EAAU,EACd,GAAI,MAAM,QAAQ,GAAM,CACtB,IAAI,EAAM,EAAI,OACd,EAAM,IAAI,MAAM,GAChB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IACvB,EAAI,GAAK,GAAa,EAAQ,GAGlC,KAAO,IAAI,aAAe,KACxB,OAAO,EAAI,SACN,GAAY,OAAR,EAET,IAAK,IAAI,KADT,EAAM,CAAC,EACO,EACZ,GAAI,OAAO,UAAU,eAAe,KAAK,EAAS,GAAI,CACpD,IAAI,EAAM,EAAQ,QACC,IAAR,IACT,EAAI,GAAK,GAAa,GAE1B,CAEJ,EAEJ,OAAO,CACT,CAEA,SAAS,GAAS,GAChB,GAAY,OAAR,EACF,cAAe,GACb,IAAK,UACH,OAAO,EAAM,EAAI,EACnB,IAAK,SACH,OA2PR,SAA8B,GAE5B,GAAY,IAAR,EACF,MAAO,IAKT,IAAI,EAAY,EAAI,gBAAgB,MAAM,QACtC,EAAY,SAAS,EAAU,GAAI,IAEnC,EAAM,EAAM,EAEZ,EAAS,EAAM,IAAM,IAKrB,GA1VW,IAyVU,GAAO,EAAY,GAAa,IACd,WA1VvB,EA0VmC,IA1V1B,EA0V+B,GApW9D,SAAa,EAAK,EAAS,GAIzB,IAHA,IAAI,EAAU,GACV,EAAe,EAAa,EAAI,OAE7B,EAAQ,OAAS,GACtB,GAAW,EAEb,OAAO,CACT,CAGgB,CAAI,EAAK,EAAS,GACf,GAFnB,IAAiB,EAAK,EAAS,EA4V7B,GAAU,GAAM,EAGhB,IAAI,EAAS,KAAK,IAAI,WAAW,EAAU,KAEvC,IACF,EAAS,GAAK,GAGhB,IAAI,EAAY,EAAO,QAAQ,IAO/B,OAJA,EAAY,EAAU,QAAQ,SAAU,IAExC,GAAU,GAAM,EAET,CACT,CAhSe,CAAqB,GAC9B,IAAK,SAOH,OAAO,EACJ,QAAQ,UAAW,MACnB,QAAQ,UAAW,MACnB,QAAQ,UAAW,MAExB,IAAK,SACH,IAAI,EAAU,MAAM,QAAQ,GACxB,EAAM,EAAU,EAAM,OAAO,KAAK,GAClC,GAAK,EACL,EAAM,EAAI,OACV,EAAS,GACb,GAAI,EACF,OAAS,EAAI,GACX,GAAU,GAAkB,EAAI,SAGlC,OAAS,EAAI,GAAK,CAChB,IAAI,EAAS,EAAI,GACjB,GAAU,GAAkB,GACxB,GAAkB,EAAI,GAC5B,CAEF,OAAO,EAGb,MAAO,EACT,CAKA,SAAS,GAAkB,GAGzB,OAAO,GADP,EAAM,GAAa,IACU,GAAM,GAAS,GAFjC,IAGb,CAEA,SAAS,GAAY,EAAK,GACxB,IACI,EADA,EAAc,EAGlB,GADsB,MAAX,EAAI,GAEb,EAAM,EACN,QACK,CACL,IAAI,EAAiB,MAAX,EAAI,GACd,IACA,IAAI,EAAc,GACd,EAAc,EAAI,UAAU,EAAG,EAAI,IACnC,EAAY,SAAS,EAAa,IAAM,GAM5C,IAJI,IACF,GAAa,GAEf,GAAK,KACQ,CACX,IAAI,EAAK,EAAI,GACb,GAAW,OAAP,EACF,MAEA,GAAe,EAEjB,GACF,CAGE,EADyB,KAD3B,EAAc,EAAY,MAAM,MAChB,OACR,SAAS,EAAa,IAGtB,WAAW,EAAY,GAAK,IAAM,EAAY,IAGlD,IACF,GAAY,IAGI,IAAd,IAIF,EAAM,WAAW,EAAM,IAAM,GAEjC,CACA,MAAO,CAAC,IAAK,EAAK,OAAS,EAAI,EACjC,CAIA,SAAS,GAAI,EAAO,GAClB,IAAI,EAAM,EAAM,MAEhB,GAAI,EAAU,OAAQ,CACpB,IAAI,EAAkB,EAAU,EAAU,OAAS,GAC/C,IAAQ,EAAgB,UAE1B,EAAU,MACV,EAAkB,EAAU,EAAU,OAAS,IAEjD,IAAI,EAAU,EAAgB,QAC1B,EAAmB,EAAgB,MACvC,GAAI,MAAM,QAAQ,GAChB,EAAQ,KAAK,QACR,GAAI,IAAqB,EAAM,OAAS,EAAG,CAEhD,EADU,EAAM,OACD,CACjB,MACE,EAAM,KAAK,EAEf,CACF,CA8GA,SAAS,GAAe,GACtB,IACI,EADK,CAAC,UAAW,SAAU,SAAU,UAC5B,eAAe,GAE5B,OAAK,EACO,OAAN,EACK,EAEL,MAAM,QAAQ,GACT,EAEF,EAAM,EAAK,EAAM,EAAM,EAAM,EAGlC,MAAM,QAAQ,GACT,OADT,CAGF,CAsEA,SAAS,GAAqB,EAAM,EAAY,GAK9C,GAJA,EAAO,EAAK,QAAO,SAAU,GAC3B,OAAO,GAAU,EAAI,IAAK,EAAW,SAAU,EACjD,IAEI,EAAW,KAAM,CAEnB,IAAI,EA9BR,SAA2B,GAEzB,SAAS,EAAsB,GAC7B,OAAO,EAAK,KAAI,SAAU,GACxB,IACI,EAAc,GADF,GAAO,IAGvB,OADoB,GAAgB,EAAK,EAE3C,GACF,CAEA,OAAO,SAAU,EAAM,GACrB,IApsBe,EAAM,EAssBjB,EAAY,GAFG,EAAsB,EAAK,KAC3B,EAAsB,EAAK,MAE9C,OAAkB,IAAd,EACK,GAxsBM,EA2sBE,EAAK,IAAI,MA3sBL,EA2sBU,EAAK,IAAI,MA1sBnB,EAAI,EAAO,EAAQ,EAAI,CA2sB9C,CACF,CASsB,CAAkB,EAAW,MAC/C,EAAO,EAAK,KAAK,GACiB,iBAAvB,EAAW,KAAK,IACU,UAtrBvB,EAsrBD,EAAW,KAAK,IArrBpB,GAAO,MAsrBd,EAAO,EAAK,UAEhB,CAzrBF,IAAkB,EA2rBhB,GAAI,UAAW,GAAc,SAAU,EAAY,CAEjD,IAAI,EAAO,EAAW,MAAQ,EAC1B,GAAS,UAAW,EAAa,EAAW,MAAQ,EAAK,QAAU,EACvE,EAAO,EAAK,MAAM,EAAM,EAC1B,CACA,OAAO,CACT,CAEA,SAAS,GAAU,EAAK,EAAU,GAChC,OAAO,EAAe,OAAM,SAAU,GACpC,IAAI,EAAU,EAAS,GACnB,EAAc,GAAW,GACzB,EAAgB,GAAgB,EAAK,GACzC,OAAI,GAAqB,GAkD7B,SAAmC,EAAO,EAAS,GAEjD,GAAc,QAAV,EACF,OAAO,EAAQ,MAAK,SAAU,GAC5B,OAAO,GAAU,EAAK,EAAY,OAAO,KAAK,GAChD,IAGF,GAAc,SAAV,EACF,OAAQ,GAAU,EAAK,EAAS,OAAO,KAAK,IAI9C,OAAQ,EAAQ,MAAK,SAAU,GAC7B,OAAO,GAAU,EAAK,EAAY,OAAO,KAAK,GAChD,GAEF,CAlEa,CAA0B,EAAO,EAAS,GAG5C,GAAc,EAAS,EAAK,EAAa,EAClD,GACF,CAEA,SAAS,GAAc,EAAS,EAAK,EAAa,GAChD,OAAK,IAMkB,iBAAZ,EACF,OAAO,KAAK,GAAS,OAAM,SAAU,GAC1C,IAAI,EAAY,EAAS,GAEzB,GAAuC,IAAnC,EAAkB,QAAQ,KAC5B,OAAO,GAAM,EAAmB,EAAK,EAAW,EAAa,GAE7D,IAAI,EAAiB,GAAW,GAEhC,QACoB,IAAlB,GACqB,iBAAd,GACP,EAAe,OAAS,EAGxB,OAAO,EAGT,IAAI,EAAmB,GAAgB,EAAe,GAEtD,MAAyB,iBAAd,EAEF,GAAc,EAAW,EAAK,EAAa,GAI7C,GAAM,MAAO,EAAK,EAAW,EAAgB,EAExD,IAIK,IAAY,EACrB,CAqBA,SAAS,GAAM,EAAc,EAAK,EAAW,EAAa,GACxD,IAAK,GAAS,GAEZ,MAAM,IAAI,MAAM,qBAAuB,EAAvB,sIAIlB,OAAO,GAAS,GAAc,EAAK,EAAW,EAAa,EAC7D,CAEA,SAAS,GAAY,GACnB,OAAO,MAAO,CAChB,CAEA,SAAS,GAAoB,GAC3B,YAAgC,IAAlB,CAChB,CAcA,SAAS,GAAmB,EAAe,GACzC,OAAO,EAAU,MAAK,SAAU,GAC9B,OAAI,aAAyB,MACpB,EAAc,MAAK,SAAU,GAClC,OAA2C,IAApC,GAAQ,EAAK,EACtB,IAGqC,IAAhC,GAAQ,EAAK,EACtB,GACF,CAsCA,IAAI,GAAW,CAEb,WAAc,SAAU,EAAK,EAAW,EAAa,GACnD,QAAK,MAAM,QAAQ,KAIU,IAAzB,EAAc,SAIc,iBAArB,EAAc,IAAyC,OAArB,EAAc,GAClD,EAAc,MAAK,SAAU,GAClC,OAAO,GAAU,EAAK,EAAW,OAAO,KAAK,GAC/C,IAGK,EAAc,MAAK,SAAU,GAClC,OAAO,GAAc,EAAW,EAAK,EAAa,EACpD,KACF,EAEA,UAAa,SAAU,EAAK,EAAW,EAAa,GAClD,QAAK,MAAM,QAAQ,KAKU,IAAzB,EAAc,SAIc,iBAArB,EAAc,IAAyC,OAArB,EAAc,GAClD,EAAc,OAAM,SAAU,GACnC,OAAO,GAAU,EAAK,EAAW,OAAO,KAAK,GAC/C,IAGK,EAAc,OAAM,SAAU,GACnC,OAAO,GAAc,EAAW,EAAK,EAAa,EACpD,KACF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAwD,IAAtC,GAAQ,EAAe,EACtE,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,IAAc,CACpF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,GAAa,CACnF,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,IAAc,CACpF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,GAAa,CACnF,EAEA,QAAW,SAAU,EAAK,EAAW,EAAa,GAEhD,OAAI,EACK,GAAoB,IAGrB,GAAoB,EAC9B,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAY,IArIvB,SAAkB,EAAe,GAC/B,MAA6B,iBAAlB,GACT,SAAS,EAAe,MAAQ,GAO3B,EAHO,EAAU,KACd,EAAU,EAGtB,CA2HyC,CAAS,EAAe,EAC/D,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,EAAU,OAAM,SAAU,GAC/B,OAA2C,IAApC,GAAQ,EAAe,EAChC,GACF,EACA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAY,IAAkB,GAAmB,EAAe,EACzE,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAY,KAAmB,GAAmB,EAAe,EAC1E,EAEA,MAAS,SAAU,EAAK,EAAW,EAAa,GAC9C,OAAO,GAAY,IACjB,MAAM,QAAQ,IAvHpB,SAAmB,EAAe,GAChC,OAAO,EAAc,SAAW,CAClC,CAsHM,CAAU,EAAe,EAC7B,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,MAAM,QAAQ,IApIzB,SAAgC,EAAe,GAC7C,OAAO,EAAU,OAAM,SAAU,GAC/B,OAAO,EAAc,MAAK,SAAU,GAClC,OAA2C,IAApC,GAAQ,EAAK,EACtB,GACF,GACF,CA8H2C,CAAuB,EAAe,EAC/E,EAEA,OAAU,SAAU,EAAK,EAAW,EAAa,GAC/C,OAAO,GAAY,IACO,iBAAjB,GACP,EAAU,OAAM,SAAU,GACxB,OA/HR,SAAoB,EAAe,GAGjC,OAFS,IAAI,OAAO,GAEV,KAAK,EACjB,CA2He,CAAW,EAAe,EACnC,GACJ,EAEA,MAAS,SAAU,EAAK,EAAW,EAAa,GAC9C,OA9HJ,SAAmB,EAAe,GAEhC,OAAQ,GACN,IAAK,OACH,OAAyB,OAAlB,EACT,IAAK,UACH,MAAkC,kBAApB,EAChB,IAAK,SACH,MAAkC,iBAApB,EAChB,IAAK,SACH,MAAkC,iBAApB,EAChB,IAAK,QACH,OAAO,aAAyB,MAClC,IAAK,SACH,MAA6C,oBAAtC,CAAG,EAAE,SAAS,KAAK,GAEhC,CA8GW,CAAU,EAAe,EAClC,GA2CF,SAAS,GAAS,EAAM,GACtB,GAAI,EAAK,UACH,EAAK,QAA0B,cAAhB,EAAK,OAAwB,CAC9C,IAAI,EAAoC,iBAAhB,EAAK,OAC3B,EAAK,OAAS,WAChB,OAAO,EAAS,IAAI,MAAM,gCAAkC,EAAa,KAC3E,CAEF,GACF,CAEA,SAAS,GAAU,GACb,EAAK,OAAS,EAAK,SACrB,EAAK,OAAS,SAGZ,EAAK,WAAa,EAAK,SACzB,EAAK,OAAS,aAGZ,EAAK,QAAiC,iBAAhB,EAAK,SACT,UAAhB,EAAK,OACP,EAAK,KAAO,GAA+B,EAAK,MAEhD,EAAK,OAAS,GAA+B,EAAK,QAGxD,CAEA,SAAS,GAAa,EAAgB,GACpC,OAAO,EAAK,QAAiC,iBAAhB,EAAK,SAC/B,EAAK,UAAY,GAAS,EAAe,GAC9C,CAEA,SAAS,GAAO,EAAgB,GAC9B,IAAI,EAAW,EAAK,SACpB,GAAoB,UAAhB,EAAK,OAAoB,CAC3B,IAAK,EAAK,MAA6B,iBAAd,EAAK,KAAmB,CAC/C,IAAI,EAAM,GAAY,GACpB,iDACF,OAAO,EAAS,EAClB,CAEA,IAAI,EAAW,GAA2B,EAAK,MAC/C,EAAe,GAAG,IAAI,WAAa,EAAS,IAAI,SAAU,EAAK,GAE7D,GAAI,EAAe,YACjB,OAAO,EAAS,KAAM,CAAC,OAAQ,cAGjC,GAAI,EACF,OAAO,EAAS,GAA0B,IAE5C,IAAI,EAAS,GAAQ,EAAK,OAAS,EAAK,MAAM,EAAS,KACrD,EAAK,MAAM,EAAS,IAAI,IAC1B,IAAK,EACH,OAAO,EAAS,GAAY,EACzB,EAAK,MAAQ,qBAAuB,EAAS,GAC5C,4BAEN,EAAK,OA/DF,GAfI,CACT,yBACA,kBACA,yBACA,iCACA,sBACA,OACA,gBAuEyB,EAvEC,IAC1B,eACA,mBACA,mBACA,MACA,MACA,KAAK,MAEgB,CAAC,GAgEpB,EAAe,UAAU,EAC3B,GACF,MAAO,GAAI,EAAK,SACd,EAAK,OAAS,SAAU,GACtB,OAxGN,SAAyB,EAAK,GAE5B,GAAwB,iBAAb,EAET,MAAM,IAAI,MAAM,0CAIlB,IAII,EAAc,GAAqB,CAJ7B,CACR,IAAO,IAGqC,CAAE,SALhD,EAAW,GAAgB,IAK6C,OAAO,KAAK,IACpF,OAAO,GAAsC,IAAvB,EAAY,MACpC,CA0Fa,CAAgB,EAAK,EAAK,SACnC,EACA,EAAe,UAAU,OACpB,CAEL,IAAI,EAAa,GAA2B,EAAK,QACjD,EAAe,GAAG,IAAI,WAAa,EAAW,IAAI,SAAU,EAAK,GAE/D,GAAI,EAAe,YACjB,OAAO,EAAS,KAAM,CAAC,OAAQ,cAGjC,GAAI,EACF,OAAO,EAAS,GAA0B,IAE5C,IAAI,EAAY,GAAQ,EAAK,SAAW,EAAK,QAAQ,EAAW,IAChE,IAAK,EACH,OAAO,EAAS,GAAY,EACxB,GAAQ,EAAK,QAAW,qBAAuB,EAAW,GACxD,8BAER,EAAK,OA5GF,GAAU,yBA4GY,EA5GuB,IAAK,CAAC,GA6GtD,EAAe,UAAU,EAC3B,GACF,CACF,CAgBA,SAAS,GAAS,GAChB,OAAO,EAAM,QAAO,SAAU,EAAK,GAEjC,OADA,EAAI,IAAQ,EACL,CACT,GAAG,CAAC,EACN,CATA,GAAQ,QAVR,SAAkC,GAChC,EAAQ,qBAAuB,CAC7B,SAAU,GACV,UAAW,GACX,aAAc,GACd,OAAQ,GAEZ,IAKA,GAAQ,QA/oCM,QAwpCd,IAAI,GAAgB,GAAS,CAC3B,MACA,OACA,UACA,eACA,WACA,aACA,aACA,aACA,qBACA,aACA,YAEA,kBACA,qBACA,0BACA,4BACA,qBAEA,aAIE,GAAY,GAAS,CACvB,UACA,eAEA,kBACA,qBACA,0BACA,4BACA,uBAGF,SAAS,GAAkB,GACzB,IAAK,QAAQ,KAAK,GAChB,OAAO,GAAY,IAErB,IAAI,EAAM,EAAI,QAAQ,KAClB,EAAO,EAAI,UAAU,EAAG,GACxB,EAAQ,EAAI,UAAU,EAAM,GAChC,MAAO,CACL,OAAQ,SAAS,EAAM,IACvB,GAAI,EAER,CAoBA,SAAS,GAAS,EAAK,EAAU,GAO/B,IAAI,EACA,EACA,EARC,IACH,EAAS,CACP,oBAAoB,IAOxB,IAAI,EAAO,CAAC,OAAQ,aAKpB,GAJI,EAAI,WACN,EAAK,SAAU,GAGb,EAKF,GAJK,EAAI,MACP,EAAI,IAAM,MAEZ,EAAW,GAAO,EAAK,EAAO,oBAC1B,EAAI,KAAM,CAEZ,IADA,EAAU,GAAkB,EAAI,OACpB,MACV,OAAO,EAET,EAAI,UAAY,CAAC,CACf,IAAK,EAAQ,OACb,IAAK,CAAC,EAAQ,GAAI,CAAC,OAAQ,WAAY,CAAC,CAAC,EAAU,EAAM,QAE3D,EAAU,EAAQ,OAAS,CAC7B,MACE,EAAI,UAAY,CAAC,CACf,IAAK,EACL,IAAM,CAAC,EAAU,EAAM,MAEzB,EAAU,OAQZ,GALI,EAAI,aACN,EAAI,UAzDV,SAAkC,EAAW,GAM3C,IALA,IAAI,EAAM,EAAU,MAAQ,EAAU,IAAI,OAAS,EAE/C,EAAc,EAAU,IACxB,EAAM,CAAC,EAAY,GAAI,EAAM,IAExB,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IACjD,EAAM,CAAC,EAAY,GAAI,CAAC,OAAQ,WAAY,CAAC,IAG/C,MAAO,CAAC,CACN,IAAK,EACL,IAAK,GAET,CA2CsB,CAAyB,EAAI,WAAY,GACzD,EAAU,EAAI,WAAW,MACzB,EAAW,EAAI,WAAW,IAAI,KAE3B,EAAI,UAAW,CAElB,IADA,EAAU,GAAkB,EAAI,OACpB,MACV,OAAO,EAET,EAAU,EAAQ,OAClB,EAAW,EAAQ,GACnB,EAAI,UAAY,CAAC,CACf,IAAK,EACL,IAAK,CAAC,EAAU,EAAM,KAE1B,CAGF,GAAe,EAAI,KAEnB,EAAI,KAAO,EAAU,IAAM,EAE3B,IAAI,EAAS,CAAC,SAAW,CAAC,EAAG,KAAO,CAAC,GACrC,IAAK,IAAI,KAAO,EAEd,GAAI,OAAO,UAAU,eAAe,KAAK,EAAK,GAAM,CAClD,IAAI,EAAwB,MAAX,EAAI,GACrB,GAAI,IAAe,GAAc,GAAM,CACrC,IAAI,EAAQ,GAAY,GAAgB,GAExC,MADA,EAAM,QAAU,GAAe,QAAU,KAAO,EAC1C,CACR,CAAW,IAAe,GAAU,GAClC,EAAO,SAAS,EAAI,MAAM,IAAM,EAAI,GAEpC,EAAO,KAAK,GAAO,EAAI,EAE3B,CAEF,OAAO,CACT,CAYA,SAAS,GAAiB,EAAK,EAAU,GACvC,IAAI,EAXN,SAAqB,GACnB,IACE,OAAO,GAAS,EAClB,CAAE,MAAO,GAGP,MAAO,CAAC,MAFE,GAAY,EACpB,2CAEJ,CACF,CAGiB,CAAY,EAAI,MAC/B,GAAI,EAAS,MACX,OAAO,EAAS,EAAS,OAG3B,EAAI,OAAS,EAAS,OAEpB,EAAI,KADW,SAAb,EACS,GAAmB,EAAU,EAAI,cACtB,WAAb,EACE,GAAS,GAET,EAEb,GAAU,GAAU,SAAU,GAC5B,EAAI,OAAS,OAAS,EACtB,GACF,GACF,CAuBA,SAAS,GAAqB,EAAK,EAAU,GAC3C,GAAI,EAAI,KACN,OAAO,IAEe,iBAAb,EAAI,KACb,GAAiB,EAAK,EAAU,GA1BpC,SAAwB,EAAK,EAAU,GACrC,GAAU,EAAI,MAAM,SAAU,GAC5B,EAAI,OAAS,OAAS,EAEtB,EAAI,OAAS,EAAI,KAAK,MAAQ,EAAI,KAAK,QAAU,EAChC,WAAb,EACF,GAAmB,EAAI,MAAM,SAAU,GACrC,EAAI,KAAO,EACX,GACF,IACsB,WAAb,EACT,GAAa,EAAI,MAAM,SAAU,GAC/B,EAAI,KAAO,EACX,GACF,IAEA,GAEJ,GACF,CASI,CAAe,EAAK,EAAU,EAElC,CAgDA,SAAS,GAAU,EAAU,EAAM,EAAS,EACzB,EAAG,EAAI,EAAU,GAElC,GA9/FF,SAAmB,EAAM,GAOvB,IANA,IAKI,EALA,EAAU,EAAK,QACf,EAAW,EAAI,MAAM,KACrB,EAAY,SAAS,EAAS,GAAI,IAClC,EAAW,EAAS,GAGhB,EAAO,EAAQ,OAAQ,CAC7B,GAAI,EAAK,MAAQ,GAAa,EAAK,IAAI,KAAO,EAC5C,OAAO,EAGT,IADA,IAAI,EAAW,EAAK,IAAI,GACf,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAC9C,EAAQ,KAAK,CAAC,IAAK,EAAK,IAAM,EAAG,IAAK,EAAS,IAEnD,CACA,OAAO,CACT,CA6+FM,CAAU,EAAK,SAAU,EAAQ,SAAS,OAAS,EAErD,OADA,EAAQ,GAAK,EACN,IAIT,IAAI,EAAqB,EAAK,YAAc,GAAW,GACnD,EAAoB,YAAa,EAAO,EAAK,QAC/C,GAAU,EAAM,GACd,EAAU,YAAa,EAAQ,SAAW,EAAQ,SAAS,QAC7D,GAAU,EAAQ,UAChB,EAAS,MAAM,KAAK,EAAQ,SAAS,KAEzC,GAAI,IAAsB,GAAW,GAAY,EAAQ,CACvD,IAAI,EAAS,EAAQ,KACrB,EAAO,KAAO,EACd,EAAO,IAAM,EAAQ,SAAS,GAC9B,EAAU,GAAS,EAAQ,EAC7B,CAEA,IAAI,EAAS,GAAM,EAAK,SAAU,EAAQ,SAAS,SAAS,GAAI,GAOhE,GALiB,IACd,GAAqB,GAAgC,aAArB,EAAO,YACtC,GAA0C,aAArB,EAAO,WAC7B,IAAsB,GAAgC,eAArB,EAAO,WAE3B,CACd,IAAI,EAAM,GAAY,GAEtB,OADA,EAAQ,GAAK,EACN,GACT,CAEA,IAAI,EAAS,EAAQ,SAAS,IAC9B,EAAQ,SAAS,SAAW,EAAO,KACnC,EAAQ,YAAc,EAAO,aAAe,GAExC,EAAK,UACP,EAAQ,SAAS,QAAU,EAAK,SAIlC,IAAI,EAAgB,GAAW,EAAQ,UACnC,EAAsB,GAAU,EAAQ,SAAU,GAIlD,EAAS,IAAsB,EAAuB,EACxD,EAAoB,GAAuB,EAAI,EAWjD,EAAS,EAAS,EAAe,EAR7B,IAAW,EAEK,EAGA,GAAU,EAAQ,SAAU,IAI9C,EAAM,EAAO,EAAG,EACpB,CAMA,SAAS,GAAY,EAAU,EAAU,EAAK,EAAa,EAAI,EAC1C,EAAU,EAAM,GAGnC,EAAW,GAAY,IA0BvB,IAAI,EAAW,EAAK,UAChB,EAAY,IAAI,EAEhB,EAAW,EACX,EAAW,EAAS,OAExB,SAAS,MACD,IAAa,GAAY,GAC7B,GAEJ,CAEA,EAAS,SAAQ,SAAU,EAAY,GAErC,GAAI,EAAW,KAAO,GAAU,EAAW,KAA3C,CACE,IAAI,EAAM,EAAW,SAAW,eAAiB,YACjD,EAAI,GAAK,EAAY,CAAC,IAAK,IAAK,SAAU,EAAK,GAC7C,EAAQ,GAAc,GAAO,EAC7B,GACF,GAEF,KAPA,CASA,IAAI,EAAK,EAAW,SAAS,GACzB,EAAU,IAAI,IAChB,IACA,EAAU,IAAI,GAAI,KAAK,CAAC,EAAY,KAEpC,EAAU,IAAI,EAAI,CAAC,CAAC,EAAY,IAPlC,CASF,IAIA,EAAU,SAAQ,SAAU,EAAM,GAChC,IAAI,EAAU,EAEd,SAAS,MACD,EAAU,EAAK,OACnB,IAEA,GAEJ,CACA,SAAS,IACP,IAAI,EAAQ,EAAK,GACb,EAAa,EAAM,GACnB,EAAa,EAAM,GAEvB,GAAI,EAAY,IAAI,GAClB,GAAU,EAAU,EAAY,IAAI,GAAK,EAAY,EACnD,EAAY,EAAY,EAAU,OAC/B,CAEL,IAAI,EAAS,GAAM,GAAI,EAAW,SAAS,SAAS,GAAI,GACxD,EAAW,SAAS,SAAW,EAAO,KACtC,EAAW,YAAc,EAAO,aAAe,GAhFrD,SAAmB,EAAS,EAAY,GAEtC,IAAI,EAAgB,GAAW,EAAQ,UACnC,EAAU,GAAU,EAAQ,SAAU,GAC1C,GAAI,eAAgB,GAAQ,EAE1B,OADA,EAAQ,GAAc,GAAY,EAAa,WACxC,IAMT,GAFiB,GApBrB,SAAuB,GACrB,MAAsD,YAA/C,EAAQ,SAAS,SAAS,GAAG,IAAI,GAAG,MAC7C,CAkBiC,CAAc,GAE3B,CACd,IAAI,EAAM,GAAY,GAEtB,OADA,EAAQ,GAAc,EACf,GACT,CAIA,EAAS,EAAS,EAAe,EAAS,GAAS,EAFvC,EAAU,EAAI,EAGjB,EAAY,EACvB,CA2DM,CAAU,EAAY,EAAY,EACpC,CACF,CACA,GACF,GACF,CAIA,IAAI,GAAkB,EAKlB,GAAY,iBAGZ,GAAe,cAEf,GAAe,eAGf,GAAuB,mBAIvB,GAAa,aAEb,GAAc,cAEd,GAA4B,sBAchC,SAAS,GAAkB,GACzB,IACE,OAAO,KAAK,UAAU,EACxB,CAAE,MAAO,GAEP,OAAO,EAAS,UAAU,EAC5B,CACF,CAEA,SAAS,GAAS,GAChB,OAAO,SAAU,GACf,IAAI,EAAU,gBACV,EAAI,QAAU,EAAI,OAAO,QAC3B,EAAU,EAAI,OAAO,MAAM,MAAQ,EAAI,OAAO,MAAM,SAEtD,EAAS,GAAY,GAAW,EAAS,EAAI,MAC/C,CACF,CASA,SAAS,GAAe,EAAU,EAAY,GAC5C,MAAO,CACL,KAAM,GAAkB,GACxB,WAAY,EACZ,eAAgB,EAAU,IAAM,IAChC,IAAK,EAAS,IACd,GAAI,EAAS,GAEjB,CAEA,SAAS,GAAe,GACtB,IAAK,EACH,OAAO,KAET,IAAI,EApDN,SAAuB,GAIrB,IACE,OAAO,KAAK,MAAM,EACpB,CAAE,MAAO,GAEP,OAAO,EAAS,MAAM,EACxB,CACF,CA0CiB,CAAc,EAAa,MAI1C,OAHA,EAAS,WAAa,EAAa,WACnC,EAAS,QAA0C,MAAhC,EAAa,eAChC,EAAS,IAAM,EAAa,IACrB,CACT,CAIA,SAAS,GAAU,GACjB,IAAK,EACH,OAAO,EAET,IAAI,EAAM,EAAI,YAAY,YAAY,KAItC,OAHA,EAAI,IAAM,EAAI,YAAY,UAAU,EAAG,EAAM,GAC7C,EAAI,KAAO,EAAI,YAAY,UAAU,EAAM,UACpC,EAAI,YACJ,CACT,CAKA,SAAS,GAAa,EAAM,EAAM,EAAQ,GACpC,EAIA,EAHG,EAEsB,iBAAT,EACP,EAEA,GAAa,EAAM,GAJnB,GAAW,CAAC,IAAK,CAAC,KAAM,KAO9B,EAEsB,iBAAT,EAChB,GAAmB,GAAM,SAAU,GACjC,EAAS,GAAS,GACpB,IAEA,EAAS,GANT,EAAS,GASf,CAEA,SAAS,GAA4B,EAAK,EAAM,EAAK,GACnD,IAAI,EAAc,OAAO,KAAK,EAAI,cAAgB,CAAC,GACnD,IAAK,EAAY,OACf,OAAO,GAAM,IAEf,IAAI,EAAU,EAEd,SAAS,MACD,IAAY,EAAY,QAAU,GACtC,GAEJ,CAYA,EAAY,SAAQ,SAAU,GACxB,EAAK,aAAe,EAAK,aAX/B,SAAyB,EAAK,GAC5B,IAAI,EAAS,EAAI,aAAa,GAC1B,EAAS,EAAO,OACV,EAAI,YAAY,IAAc,IAAI,GACxC,UAAY,SAAU,GACxB,EAAO,KAAO,EAAE,OAAO,OAAO,KAC9B,GACF,CACF,CAII,CAAgB,EAAK,IAErB,EAAI,aAAa,GAAK,MAAO,EAC7B,IAEJ,GACF,CAMA,SAAS,GAAuB,EAAS,GACvC,OAAO,QAAQ,IAAI,EAAQ,KAAI,SAAU,GACvC,GAAI,EAAI,KAAO,EAAI,IAAI,aAAc,CACnC,IAAI,EAAW,OAAO,KAAK,EAAI,IAAI,cACnC,OAAO,QAAQ,IAAI,EAAS,KAAI,SAAU,GACxC,IAAI,EAAS,EAAI,IAAI,aAAa,GAClC,GAAM,SAAU,EAAhB,CAGA,IAAI,EAAO,EAAO,KACd,EAAO,EAAO,aAClB,OAAO,IAAI,SAAQ,SAAU,GAC3B,GAAa,EAAM,EAAM,GAAQ,SAAU,GACzC,EAAI,IAAI,aAAa,GAAO,EAC1B,EAAK,EAAQ,CAAC,SAAU,iBACxB,CAAC,KAAM,IAET,GACF,GACF,GAXA,CAYF,IACF,CACF,IACF,CAEA,SAAS,GAAY,EAAM,EAAO,GAEhC,IAAI,EAA0B,GAC1B,EAAW,EAAI,YAAY,IAC3B,EAAW,EAAI,YAAY,IAC3B,EAAiB,EAAI,YAAY,IACjC,EAAQ,EAAK,OAEjB,SAAS,MACP,GAMF,WACE,IAAK,EAAwB,OAC3B,OAEF,EAAwB,SAAQ,SAAU,GACzB,EAAe,MAAM,aAAa,MAC/C,YAAY,MACV,EAAS,KAAM,EAAS,OAAY,GAAO,IACtC,UAAY,SAAU,GACjB,EAAE,OAAO,QAGnB,EAAS,OAAO,EAEpB,CACF,GACF,CApBI,EAEJ,CAoBA,EAAK,SAAQ,SAAU,GACrB,IAAI,EAAQ,EAAS,MAAM,eACvB,EAAM,EAAQ,KAAO,EACzB,EAAM,OAAO,GAAK,UAAY,SAAU,GACtC,IAAI,EAAM,EAAE,OAAO,OACnB,GAAmB,iBAAR,EACT,OAAO,IAET,EAAS,OAAO,GAEH,EAAe,MAAM,OAC/B,WAAW,YAAY,KAAK,IAExB,UAAY,SAAU,GAC3B,IAAI,EAAS,EAAM,OAAO,OAC1B,GAAI,EAAQ,CACV,IAAI,EAAS,EAAO,MAAM,UAAU,MAAM,MAAM,GAChD,EAAwB,KAAK,GAC7B,EAAe,OAAO,EAAO,YAC7B,EAAO,UACT,MACE,GAEJ,CACF,CACF,GACF,CAEA,SAAS,GAAsB,EAAK,EAAQ,GAC1C,IACE,MAAO,CACL,IAAK,EAAI,YAAY,EAAQ,GAEjC,CAAE,MAAO,GACP,MAAO,CACL,MAAO,EAEX,CACF,CAEA,IAAI,GAAiB,IAAI,EAEzB,SAAS,GAAY,EAAQ,EAAK,EAAM,EAAK,EAAK,GAWhD,IAVA,IACI,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EARA,EAAW,EAAI,KAUV,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAAK,CACnD,IAAI,EAAM,EAAS,GACf,EAAI,KAAO,GAAU,EAAI,OAG7B,EAAM,EAAS,GAAK,GAAS,EAAK,EAAK,UAAW,IAC1C,QAAU,IAChB,EAAe,EAEnB,CAEA,GAAI,EACF,OAAO,EAAS,GAGlB,IAAI,GAAmB,EACnB,EAAgB,EAChB,EAAU,IAAI,MAAM,EAAS,QAC7B,EAAc,IAAI,EAClB,GAAsB,EACtB,EAAW,EAAI,MAAM,YAAc,OAAS,SA6ChD,SAAS,IACP,GAAmB,EACnB,GACF,CAOA,SAAS,IACF,GAAY,IAKjB,EAAQ,UAAY,EACpB,EAAU,IAAI,GAChB,CAoCA,SAAS,IACH,IAIJ,GAAe,OAAO,EAAI,MAAM,MAChC,EAAS,KAAM,GACjB,CAqDA,SAAS,EAAS,EAAS,EAAe,EAAqB,EAC7C,EAAU,EAAO,EAAY,GAE7C,EAAQ,SAAS,WAAa,EAC9B,EAAQ,SAAS,QAAU,EAE3B,IAAI,EAAM,EAAQ,KAUlB,GATA,EAAI,IAAM,EAAQ,SAAS,GAC3B,EAAI,KAAO,EAAQ,SAAS,IAExB,IACF,EAAI,UAAW,GAGI,EAAI,cACvB,OAAO,KAAK,EAAI,cAAc,OAE9B,OAqEJ,SAA0B,EAAS,EAAe,EACxB,EAAU,EAAY,GAG9C,IAAI,EAAM,EAAQ,KAEd,EAAU,EACV,EAAc,OAAO,KAAK,EAAI,cAElC,SAAS,IACH,IAAY,EAAY,QAC1B,EAAU,EAAS,EAAe,EAChC,EAAU,EAAY,EAE5B,CAEA,SAAS,IACP,IACA,GACF,CAEA,EAAY,SAAQ,SAAU,GAC5B,IAAI,EAAM,EAAQ,KAAK,aAAa,GACpC,GAAK,EAAI,KAOP,IACA,QARa,CACb,IAAI,EAAO,EAAI,YACR,EAAI,KACX,EAAI,OAAS,SAAS,EAAe,IAiD3C,SAAwB,EAAQ,EAAM,GAGpC,IAAI,EAAY,EAAY,MAAM,GAClC,EAAU,UAAY,SAAU,GAE9B,GADY,EAAE,OAAO,OAEnB,OAAO,IAET,IAAI,EAAS,CACX,OAAQ,EACR,KAAM,GAEK,EAAY,IAAI,GACtB,UAAY,CACrB,CACF,CA/DM,CADa,EAAI,OACM,EAAM,EAC/B,CAIF,GACF,CAvGW,CAAiB,EAAS,EAAe,EAC9C,EAAU,EAAY,GAG1B,GAAiB,EACjB,IAEA,EAAU,EAAS,EAAe,EAChC,EAAU,EAAY,EAC1B,CAEA,SAAS,EAAU,EAAS,EAAe,EACxB,EAAU,EAAY,GAEvC,IAAI,EAAM,EAAQ,KACd,EAAW,EAAQ,SAMvB,SAAS,EAAY,GACnB,IAAI,EAAe,EAAQ,aAAe,GAEtC,GAAY,EAAI,kBAClB,EAAe,EAAa,OAx9HpC,SAAqB,GACnB,IAAI,EAAO,GAQX,OAPA,GAAgB,EAAS,UAAU,SAAU,EAAQ,EACR,EAAS,EAAK,GACrC,cAAhB,EAAK,QAA2B,IAClC,EAAK,KAAK,EAAM,IAAM,GACtB,EAAK,OAAS,UAElB,IACO,CACT,CA88H2C,CAAY,EAAQ,YAGrD,GAAgB,EAAa,QAC/B,GAAY,EAAc,EAAQ,SAAS,GAAI,GAGjD,EAAS,IAAM,EAAE,OAAO,OAGxB,IAAI,EAAkB,GAAe,EAAU,EAC7C,GACgB,EAAS,IAAI,GACnB,UAAY,CAC1B,CAcA,SAAS,IACP,EAAQ,GAAc,CACpB,IAAI,EACJ,GAAI,EAAS,GACb,IAAK,EAAS,KAEhB,EAAY,IAAI,EAAQ,SAAS,GAAI,EAAQ,UAgDjD,SAAkC,EAAS,EAAK,GAE9C,IAAI,EAAY,EACZ,EAAY,OAAO,KAAK,EAAQ,KAAK,cAAgB,CAAC,GAE1D,IAAK,EAAU,OACb,OAAO,IAGT,SAAS,MACD,IAAc,EAAU,QAC5B,GAEJ,CAEA,SAAS,EAAI,GACX,IAAI,EAAS,EAAQ,KAAK,aAAa,GAAK,OACxC,EAAM,EAAkB,IAAI,CAC9B,IAAK,EACL,UAAW,EAAS,KAAO,IAG7B,EAAI,UAAY,EAChB,EAAI,QAAU,SAAU,GAItB,EAAE,iBACF,EAAE,kBACF,GACF,CACF,CACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAU,OAAQ,IACpC,EAAI,EAAU,GAElB,CAlFI,CAAyB,EAAS,EAAS,IAAK,EAClD,CA5CA,EAAI,YAAc,EAAS,GAAK,KAAO,EAAS,WACzC,EAAI,WACJ,EAAI,KA4CX,IAAI,EAAS,EAAW,IAAI,GAE5B,EAAO,UAAY,EACnB,EAAO,QAzBP,SAA0B,GAExB,EAAE,iBACF,EAAE,kBACU,EAAW,MAAM,eACP,OAAO,EAAI,aACvB,UAAY,SAAU,GACjB,EAAW,IAAI,EAAK,EAAE,OAAO,QACnC,UAAY,CACrB,CACF,CAgBF,EAvuBF,SAA+B,EAAU,EAAU,GAEjD,IAAK,EAAS,OACZ,OAAO,IAGT,IACI,EADA,EAAO,EA4BX,SAAS,IACP,IACI,EAAS,SAAW,IAClB,EACF,EAAS,GAET,IAGN,CAlCA,EAAS,SAAQ,SAAU,GACzB,IAAI,EAAc,EAAQ,MAAQ,EAAQ,KAAK,aAC7C,OAAO,KAAK,EAAQ,KAAK,cAAgB,GACvC,EAAO,EAEX,IAAK,EAAY,OACf,OAAO,IAGT,SAAS,EAAoB,GAC3B,EAAa,IACb,IACa,EAAY,QACvB,GAEJ,CAEA,IAAK,IAAI,KAAO,EAAQ,KAAK,aACvB,OAAO,UAAU,eAAe,KAAK,EAAQ,KAAK,aAAc,IAClE,GAAqB,EAAQ,KAAK,aAAa,GAC7C,EAAU,EAGlB,GAYF,CA0cE,CAAsB,EAAU,GAAU,SAAU,GAClD,GAAI,EACF,OAAO,EAAS,IAKpB,WAEE,IAMI,EAAY,GAAsB,EANzB,CACX,GAAW,GACX,GACA,GAAa,GACb,IAEiD,aACnD,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,QAE5B,EAAM,EAAU,KACZ,QAAU,GAAS,GACvB,EAAI,UAAY,GAAS,GACzB,EAAI,WAAa,EACjB,EAAW,EAAI,YAAY,IAC3B,EAAa,EAAI,YAAY,IAC7B,EAAc,EAAI,YAAY,IAC9B,EAAoB,EAAI,YAAY,KACpC,EAAY,EAAI,YAAY,KAElB,IAAI,IAAY,UAAY,SAAU,GAC9C,EAAU,EAAE,OAAO,OACnB,GACF,EA0FF,SAA2B,GAGzB,IAAI,EAAU,GAWd,GAVA,EAAS,SAAQ,SAAU,GACrB,EAAQ,MAAQ,EAAQ,KAAK,cAC/B,OAAO,KAAK,EAAQ,KAAK,cAAc,SAAQ,SAAU,GACvD,IAAI,EAAM,EAAQ,KAAK,aAAa,GAChC,EAAI,MACN,EAAQ,KAAK,EAAI,OAErB,GAEJ,KACK,EAAQ,OACX,OAAO,IAET,IACI,EADA,EAAU,EAGd,SAAS,MACD,IAAY,EAAQ,QACxB,EAAO,EAEX,CACA,EAAQ,SAAQ,SAAU,IAzC5B,SAA0B,EAAQ,GAEhC,IAAI,EAAM,EAAY,IAAI,GAC1B,EAAI,UAAY,SAAU,GACxB,GAAK,EAAE,OAAO,OAOZ,QAPoB,CACpB,IAAI,EAAM,GAAY,GACpB,uCACA,GACF,EAAI,OAAS,IACb,EAAS,EACX,CAGF,CACF,CA4BI,CAAiB,GAAQ,SAAU,GAC7B,IAAW,IACb,EAAM,GAER,GACF,GACF,GACF,CAzHE,EAAkB,SAAU,GAC1B,GAAI,EAEF,OADA,GAAsB,EACf,EAAS,IA0BtB,WAEE,IAAK,EAAS,OACZ,OAGF,IAAI,EAAa,EAEjB,SAAS,MACD,IAAe,EAAS,QAvBhC,GAAY,EAAO,WAAY,EAAU,EAAK,EAClC,EAAK,EAAS,EAAU,EAAM,EAyB1C,CAEA,SAAS,EAAa,GACpB,IAAI,EAAW,GAAe,EAAM,OAAO,QAEvC,GACF,EAAY,IAAI,EAAS,GAAI,GAE/B,GACF,CAEA,IAAK,IAAI,EAAI,EAAG,EAAM,EAAS,OAAQ,EAAI,EAAK,IAAK,CACnD,IAAI,EAAU,EAAS,GACvB,GAAI,EAAQ,KAAO,GAAU,EAAQ,KACnC,SAGQ,EAAS,IAAI,EAAQ,SAAS,IACpC,UAAY,CAClB,CACF,CAxDI,EACF,GACF,CArCE,EACF,GA0UF,CAMA,SAAS,GAAiB,EAAa,EAAU,EAAY,EAAW,GAWtE,IAII,EACA,EACA,EAEJ,SAAS,EAAS,GAChB,EAAc,EAAE,OAAO,OACnB,GACF,EAAQ,EAAW,EAAa,EAEpC,CAEA,SAAS,EAAa,GACpB,EAAY,EAAE,OAAO,OACjB,GACF,EAAQ,EAAW,EAAa,EAEpC,CA4BA,SAAS,EAAS,GAChB,IAAI,EAAS,EAAE,OAAO,OACtB,IAAK,EACH,OAAO,IAGT,EAAQ,CAAC,EAAO,KAAM,CAAC,EAAO,OAAQ,EACxC,EAhEmB,IAAf,IACF,EAAY,KAQgC,mBAAvB,EAAY,QACC,mBAA3B,EAAY,YACnB,EAAY,IAAM,GAwDlB,EAAe,CAAC,SApClB,WACE,IAAK,EAAU,OACb,OAAO,IAGT,IACI,EADA,EAAU,EAAU,EAAU,OAAS,GAE3C,GAAI,GAAY,EAAS,MACvB,IACE,EAAc,YAAY,MAAM,EAAS,EAAS,OAChD,EAAM,EAAS,UACnB,CAAE,MAAO,GACP,GAAe,cAAX,EAAE,MAAmC,IAAX,EAAE,KAC9B,OAAO,GAEX,MAEA,EAAc,YAAY,WAAW,GAAS,GAEhD,EAAW,EACX,EAAY,KACZ,EAAc,KACd,EAAY,OAAO,EAAU,GAAW,UAAY,EACpD,EAAY,WAAW,EAAU,GAAW,UAAY,CAC1D,GAaE,EAAY,OAAO,EAAU,GAAW,UAAY,EACpD,EAAY,WAAW,EAAU,GAAW,UAAY,GAC/C,EACT,EAAY,WAAW,EAAU,QAAQ,UAAY,EAErD,EAAY,WAAW,GAAU,UAAY,CAEjD,CA6EA,SAAS,GAAW,EAAM,EAAK,GAC7B,IAQI,EACA,EATA,EAAQ,aAAc,GAAO,EAAK,SAClC,EAAM,WAAY,GAAO,EAAK,OAC9B,EAAM,QAAS,GAAO,EAAK,IAC3B,EAAO,SAAU,GAAO,EAAK,KAC7B,EAAO,EAAK,MAAQ,EACpB,EAA8B,iBAAf,EAAK,MAAqB,EAAK,OAAS,EACvD,GAAsC,IAAvB,EAAK,cAIxB,IAAK,IACH,EAzCJ,SAAwB,EAAO,EAAK,EAAc,EAAK,GACrD,IACE,GAAI,GAAS,EACX,OAAI,EACK,YAAY,MAAM,EAAK,GAAQ,GAAc,GAE7C,YAAY,MAAM,EAAO,GAAK,GAAQ,GAE1C,GAAI,EACT,OAAI,EACK,YAAY,WAAW,GAEvB,YAAY,WAAW,GAE3B,GAAI,EACT,OAAI,EACK,YAAY,WAAW,GAAM,GAE7B,YAAY,WAAW,GAAM,GAEjC,GAAI,EACT,OAAO,YAAY,KAAK,EAE5B,CAAE,MAAO,GACP,MAAO,CAAC,MAAO,EACjB,CACA,OAAO,IACT,CAce,CAAe,EAAO,EAAK,EAAc,EAAK,EAAK,aAC9D,EAAgB,GAAY,EAAS,SAEV,cAAvB,EAAc,MAA+C,IAAvB,EAAc,OAGtD,OAAO,EAAS,GAAY,GAC1B,EAAc,KAAM,EAAc,UAIxC,IAAI,EAAS,CAAC,GAAW,GAAc,IAEnC,EAAK,aACP,EAAO,KAAK,IAEd,IAAI,EAAY,GAAsB,EAAK,EAAQ,YACnD,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,IAAI,EAAM,EAAU,IACpB,EAAI,WAgIJ,WACM,EAAK,YACP,GAAuB,EAAS,EAAK,QAAQ,KAAK,GAElD,GAEJ,EArIA,EAAI,QAAU,GAAS,GACvB,IAKI,EACA,EANA,EAAW,EAAI,YAAY,IAC3B,EAAW,EAAI,YAAY,IAC3B,EAAY,EAAI,YAAY,IAC5B,EAAgB,EAAS,MAAM,eAC/B,EAAU,GAiDd,SAAS,EAAa,EAAe,GACnC,IAAI,EAAM,CACR,GAAI,EAAS,GACb,IAAK,EAAS,GACd,MAAO,CACL,IAAK,IAGK,EAAS,QAEjB,IACF,EAAQ,KAAK,GAEb,EAAI,MAAM,SAAU,EACpB,EAAI,IAAM,MAEH,KAAU,IACnB,EAAQ,KAAK,GACT,EAAK,cAhCb,SAAgC,EAAU,EAAK,GAC7C,IAAI,EAAM,EAAS,GAAK,KAAO,EAC/B,EAAc,IAAI,GAAK,UAAa,SAAkB,GAEpD,GADA,EAAI,IAAM,GAAU,EAAE,OAAO,SAAW,CAAC,EACrC,EAAK,UAAW,CAClB,IAAI,EAAY,GAAiB,GAC7B,EAAU,SACZ,EAAI,IAAI,WAAa,EAEzB,CACA,GAA4B,EAAI,IAAK,EAAM,EAC7C,CACF,CAqBM,CAAuB,EAAU,EAAK,GAG5C,CAEA,SAAS,EAAa,GACpB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,GACxC,EAAQ,SAAW,EAD0B,IAAK,CAItD,IAAI,EAAa,EAAY,GAC7B,GAAI,EAAW,OAAS,EAEtB,EAAQ,KAAK,OAFf,CAKA,IAAI,EAAW,GAAe,GAE9B,EADoB,EAAS,WACD,EAH5B,CAIF,CACF,CAEA,SAAS,EAAQ,EAAW,EAAa,GAClC,IAGL,EAAa,GACT,EAAQ,OAAS,GACnB,EAAO,WAEX,CAUA,SAAS,IACP,IAAI,EAAY,CACd,WAAY,EACZ,OAAQ,EAAK,KACb,KAAM,GAIJ,EAAK,iBAA4B,IAAd,IACrB,EAAU,WAAa,GAEzB,EAAS,KAAM,EACjB,CAWA,OA/HA,EAAU,IAAI,IAAY,UAAY,SAAU,GAC9C,EAAW,EAAE,OAAO,OAAO,QAC7B,EAGI,EAAK,YAQT,SAAyB,EAAa,GACpC,SAAS,EAAS,GAChB,IAAI,EAAS,EAAE,OAAO,OAClB,OAAS,EAIb,OAHI,GAAU,EAAO,MACnB,EAAS,EAAO,KAEX,EAAU,CACf,OAAQ,CACN,OAAQ,CAAC,KAGf,CACA,EAAY,WAAW,KAAM,QAAQ,UAAY,CACnD,CArBE,CAAgB,GAAU,SAAU,GAC9B,EAAE,OAAO,QAAU,EAAE,OAAO,OAAO,OAAS,IAC9C,EAAY,EAAE,OAAO,OAAO,GAEhC,IAqHE,GAA2B,IAAV,OAArB,EAGI,EA7NN,SAAqB,EAAM,EAAU,GAEnC,IAAI,EAAc,IAAI,MAAM,EAAK,QAC7B,EAAQ,EACZ,EAAK,SAAQ,SAAU,EAAK,GAC1B,EAAS,IAAI,GAAK,UAAY,SAAU,GAClC,EAAM,OAAO,OACf,EAAY,GAAS,EAAM,OAAO,OAElC,EAAY,GAAS,CAAC,IAAK,EAAK,MAAO,eAEzC,IACc,EAAK,QACjB,EAAQ,EAAM,EAAa,CAAC,EAEhC,CACF,GACF,CA6MW,CAAY,EAAK,KAAM,EAAU,IAE3B,IAAX,EA1PN,SAAgB,EAAa,EAAU,GACrC,GAAkC,mBAAvB,EAAY,OAAvB,CAMA,IAAI,EAAS,GAgBb,EAAY,WAAW,GAAU,UAdjC,SAAkB,GAChB,IAAI,EAAS,EAAE,OAAO,OAClB,GACF,EAAO,KAAK,EAAO,OACnB,EAAO,YAEP,EAAU,CACR,OAAQ,CACN,OAAQ,IAIhB,CAhBA,MAFE,EAAY,OAAO,GAAU,UAAY,CAqB7C,CAmOW,CAAO,EAAU,GAtC1B,SAAkB,GAChB,IAAI,EAAS,EAAE,OAAO,OAClB,EAAK,aACP,EAAS,EAAO,WAElB,EAAa,EACf,SAoCA,GAAiB,EAAU,EAAU,EAAK,WAAY,EAAQ,EAAM,EACtE,CAiDA,IAAI,IAAU,EACV,GAAQ,GAaZ,SAAS,MACH,IAAY,GAAM,SAGtB,IAAU,EACV,GAAM,OAAN,GACF,CAeA,SAAS,GAAQ,EAAM,EAAK,EAAQ,GAGlC,IAFA,EAAO,EAAM,IAEJ,WAAY,CACnB,IAAI,EAAK,EAAS,IAAM,KAGxB,OAFA,GAAe,YAAY,EAAQ,EAAI,EAAK,GAC5C,GAAe,OAAO,GACf,CACL,OAAQ,WACN,GAAe,eAAe,EAAQ,EACxC,EAEJ,CAEA,IAAI,EAAS,EAAK,SAAW,IAAI,EAAY,EAAK,SAElD,EAAK,MAAQ,EAAK,OAAS,EAC3B,IAAI,EAAU,EAAK,MAEf,EAAQ,UAAW,EAAO,EAAK,OAAS,EAC9B,IAAV,IACF,EAAQ,GAGV,IAKI,EACA,EACA,EACA,EARA,EAAU,GACV,EAAa,EACb,EAAS,GAAa,GACtB,EAAmB,IAAI,EA0F3B,SAAS,EAAc,EAAK,EAAK,EAAU,GACzC,GAAI,EAAS,MAAQ,EAEnB,OAAO,IAGT,GAAI,EAAS,aAAe,EAAI,KAE9B,OAAO,EAAG,EAAU,GAItB,IAAI,EAAW,EAAI,IAAM,KAAO,EAAS,WAC/B,EAAc,IAAI,GACxB,UAAY,SAAU,GACxB,EAAG,EAAU,GAAU,EAAE,OAAO,QAClC,CACF,CAmBA,SAAS,IACP,EAAK,SAAS,KAAM,CAClB,QAAS,EACT,SAAU,GAEd,CAYA,IAAI,EAAe,CAAC,GAAW,IAC3B,EAAK,aACP,EAAa,KAAK,IAEpB,IAAI,EAAY,GAAsB,EAAK,EAAc,YACzD,GAAI,EAAU,MACZ,OAAO,EAAK,SAAS,EAAU,QAEjC,EAAM,EAAU,KACZ,QAAU,GAAS,EAAK,UAC5B,EAAI,WApBJ,YACO,EAAK,YAAc,EAAK,YAG3B,GAAuB,GAAS,KAAK,GAErC,GAEJ,EAcA,EAAa,EAAI,YAAY,IAC7B,EAAW,EAAI,YAAY,IAC3B,EAAgB,EAAW,MAAM,eAKjC,GAAiB,EAHD,EAAK,QAAU,EAAK,WAClC,YAAY,WAAW,EAAK,OAAO,GAAQ,KAEN,EAAK,WAAY,GA3JxD,SAAiB,EAAW,EAAa,GACvC,GAAK,GAAW,EAAU,OAA1B,CAIA,IAAI,EAAc,IAAI,MAAM,EAAU,QAClC,EAAY,IAAI,MAAM,EAAU,QA+DhC,EAAU,EACd,EAAY,SAAQ,SAAU,EAAO,IAgCvC,SAAoC,EAAK,EAAK,GAC5C,GAAI,IAAW,EAAO,IAAI,EAAI,KAC5B,OAAO,IAGT,IAAI,EAAW,EAAiB,IAAI,EAAI,KACxC,GAAI,EACF,OAAO,EAAc,EAAK,EAAK,EAAU,GAG3C,EAAS,IAAI,EAAI,KAAK,UAAY,SAAU,GAC1C,EAAW,GAAe,EAAE,OAAO,QACnC,EAAiB,IAAI,EAAI,IAAK,GAC9B,EAAc,EAAK,EAAK,EAAU,EACpC,CACF,CA5CI,CAFU,GAAU,GACV,EAAU,IACiB,SAAU,EAAU,GACvD,EAAU,GAAK,EACf,EAAY,GAAK,IACX,IAAY,EAAU,QArChC,WAEE,IADA,IAAI,EAAW,GACN,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,GACxC,IAAe,EAD8B,IAAK,CAItD,IAAI,EAAa,EAAY,GAC7B,GAAK,EAAL,CAGA,IAAI,EAAW,EAAU,GACzB,EAAS,KAAK,EAA6B,EAAU,GAFrD,CAGF,CAEA,QAAQ,IAAI,GAAU,MAAK,SAAU,GACnC,IAAK,IAAI,EAAI,EAAG,EAAM,EAAQ,OAAQ,EAAI,EAAK,IACzC,EAAQ,IACV,EAAK,SAAS,EAAQ,GAG5B,IAAG,MAAM,EAAK,UAEV,IAAe,GACjB,EAAO,UAEX,CAaM,EAEJ,GACF,GA7EA,CAKA,SAAS,EAA6B,EAAU,GAC9C,IAAI,EAAS,EAAK,cAAc,EAAY,EAAU,GACtD,EAAU,EAAO,IAAM,EAAS,IAEhC,IAAI,EAAW,EAAO,GACtB,MAAwB,iBAAb,EACF,QAAQ,OAAO,GAGnB,GAGL,IACI,EAAK,aACP,EAAQ,KAAK,GAIX,EAAK,aAAe,EAAK,aACpB,IAAI,SAAQ,SAAU,GAC3B,GAA4B,EAAY,EAAM,GAAK,WACjD,GAAuB,CAAC,GAAS,EAAK,QAAQ,MAAK,WACjD,EAAQ,EACV,GACF,GACF,IAEO,QAAQ,QAAQ,IAjBhB,QAAQ,SAmBnB,CA4CF,GA2EF,CAEA,IACI,GADA,GAAY,IAAI,EAEhB,GAAc,IAAI,EAEtB,SAAS,GAAS,EAAM,GACtB,IAAI,EAAM,MAlNZ,SAAqB,EAAQ,EAAU,GACrC,GAAM,MAAK,WACT,GAAO,SAAqB,EAAK,IArBrC,SAAiB,EAAK,EAAK,EAAK,GAC9B,IACE,EAAI,EAAK,EACX,CAAE,MAAO,GAIP,EAAQ,KAAK,QAAS,EACxB,CACF,CAaM,CAAQ,EAAU,EAAK,EAAK,GAC5B,IAAU,EACV,KAAU,WACR,IACF,GACF,GACF,IACA,IACF,CAyME,EAAY,SAAU,IAKxB,SAAc,EAAK,EAAM,GAEvB,IAAI,EAAS,EAAK,KAEd,EAAM,KACN,EAAwB,KAG5B,SAAS,EAAoB,GAC3B,OAAO,SAAU,EAAO,GAClB,GAAS,aAAiB,QAAU,EAAM,QACxC,IACF,EAAM,OAAS,GAInB,EAAS,EAAO,EAClB,CACF,CAGA,SAAS,EAAa,GACpB,IAAI,EAAW,EAAG,kBAAkB,GAAW,CAAC,QAAU,OAC1D,EAAG,kBAAkB,GAAc,CAAC,eAAe,IAChD,YAAY,cAAe,cAAe,CAAC,QAAQ,IACtD,EAAG,kBAAkB,GAAc,CAAC,QAAS,WAC7C,EAAG,kBAAkB,GAAY,CAAC,QAAS,KAAM,eAAe,IAChE,EAAG,kBAAkB,IAGrB,EAAS,YAAY,iBAAkB,iBAAkB,CAAC,QAAS,IAGnE,EAAG,kBAAkB,GAAa,CAAC,QAAS,QAG5C,IAAI,EAAiB,EAAG,kBAAkB,GACxC,CAAC,eAAe,IAClB,EAAe,YAAY,MAAO,OAClC,EAAe,YAAY,YAAa,YAAa,CAAC,QAAQ,GAChE,CAKA,SAAS,EAAuB,EAAK,GACnC,IAAI,EAAW,EAAI,YAAY,IAC/B,EAAS,YAAY,iBAAkB,iBAAkB,CAAC,QAAS,IAEnE,EAAS,aAAa,UAAY,SAAU,GAC1C,IAAI,EAAS,EAAM,OAAO,OAC1B,GAAI,EAAQ,CACV,IAAI,EAAW,EAAO,MAClB,EAAU,GAAU,GACxB,EAAS,eAAiB,EAAU,IAAM,IAC1C,EAAS,IAAI,GACb,EAAO,UACT,MACE,GAEJ,CACF,CAGA,SAAS,EAAuB,GAC9B,EAAG,kBAAkB,GAAa,CAAC,QAAS,QACzC,YAAY,cAAe,cAAe,CAAC,QAAQ,GACxD,CAGA,SAAS,EAAkB,EAAK,GAC9B,IAAI,EAAa,EAAI,YAAY,IAC7B,EAAW,EAAI,YAAY,IAC3B,EAAW,EAAI,YAAY,IAElB,EAAS,aACf,UAAY,SAAU,GAC3B,IAAI,EAAS,EAAM,OAAO,OAC1B,GAAI,EAAQ,CACV,IAAI,EAAW,EAAO,MAClB,EAAQ,EAAS,GACjB,EAAQ,GAAU,GAClB,EAAM,GAAW,GACrB,GAAI,EAAO,CACT,IAAI,EAAW,EAAQ,KAAO,EAG1B,EAAQ,EAAQ,KAChB,EAAM,EAAQ,MACd,EAAQ,EAAS,MAAM,eACvB,EAAQ,YAAY,MAAM,EAAO,GAAK,GAAO,GAC7C,EAAY,EAAM,WAAW,GACjC,EAAU,UAAY,SAAU,GAE9B,GADA,EAAY,EAAE,OAAO,OAKd,CACL,IAAI,EAAO,EAAU,MACjB,EAAK,cAAgB,GACvB,EAAW,IAAI,GAEjB,EAAS,OAAO,EAAU,YAC1B,EAAU,UACZ,MATE,EAAS,OAAO,EAAO,YACvB,EAAO,UASX,CACF,MACE,EAAO,UAEX,MAAW,GACT,GAEJ,CACF,CAGA,SAAS,EAAqB,GAC5B,IAAI,EAAiB,EAAG,kBAAkB,GACxC,CAAC,eAAe,IAClB,EAAe,YAAY,MAAO,OAClC,EAAe,YAAY,YAAa,YAAa,CAAC,QAAQ,GAChE,CAGA,SAAS,EAAmB,EAAK,GAC/B,IAAI,EAAW,EAAI,YAAY,IAC3B,EAAW,EAAI,YAAY,IAC3B,EAAiB,EAAI,YAAY,IAK3B,EAAS,QACf,UAAY,SAAU,GAExB,IADY,EAAE,OAAO,OAEnB,OAAO,IAGT,EAAS,aAAa,UAAY,SAAU,GAC1C,IAAI,EAAS,EAAE,OAAO,OACtB,IAAK,EACH,OAAO,IAMT,IAJA,IAAI,EAAM,EAAO,MACb,EAAM,EAAO,WACb,EAAO,OAAO,KAAK,EAAI,cAAgB,CAAC,GACxC,EAAY,CAAC,EACR,EAAI,EAAG,EAAI,EAAK,OAAQ,IAAK,CAEpC,EADU,EAAI,aAAa,EAAK,IAClB,SAAU,CAC1B,CACA,IAAI,EAAU,OAAO,KAAK,GAC1B,IAAK,EAAI,EAAG,EAAI,EAAQ,OAAQ,IAAK,CACnC,IAAI,EAAS,EAAQ,GACrB,EAAe,IAAI,CACjB,IAAK,EACL,UAAW,EAAS,KAAO,GAE/B,CACA,EAAO,UACT,CACF,CACF,CAQA,SAAS,EAAgB,GAEvB,SAAS,EAAqB,GAC5B,OAAK,EAAa,KAKX,GAAe,IAHpB,EAAa,QAA0C,MAAhC,EAAa,eAC7B,EAGX,CAIA,IAAI,EAAa,EAAI,YAAY,IAC7B,EAAW,EAAI,YAAY,IAClB,EAAS,aACf,UAAY,SAAU,GAC3B,IAAI,EAAS,EAAE,OAAO,OACtB,GAAK,EAAL,CAGA,IAAI,EAAW,EAAqB,EAAO,OAsC3C,GApCA,EAAS,WAAa,EAAS,YAC7B,GAAW,GAmCT,EAAS,IACX,OAAO,IAGT,GA3CA,CAMA,SAAS,IAGP,IAAI,EAAQ,EAAS,GAAK,KACtB,EAAM,EAAS,GAAK,MACpB,EAAM,EAAW,MAAM,eAAe,WACxC,YAAY,MAAM,EAAO,IAEvB,EAAc,EAClB,EAAI,UAAY,SAAU,GACxB,IAAI,EAAS,EAAE,OAAO,OACtB,IAAK,EAEH,OADA,EAAS,IAAM,EACR,IAET,IAAI,EAAM,EAAO,WACb,EAAM,IACR,EAAc,GAEhB,EAAO,UACT,CACF,CAEA,SAAS,IACP,IAAI,EAAkB,GAAe,EACnC,EAAS,WAAY,EAAS,SAEtB,EAAS,IAAI,GACnB,UAAY,WACd,EAAO,UACT,CACF,CAOF,CAEF,CAxOA,EAAI,MAAQ,KA0OZ,EAAI,SAAU,EACd,EAAI,KAAO,WACT,MAAO,KACT,EAEA,EAAI,IAAM,GAAU,SAAU,GAC5B,EAAS,KAAM,EAAI,MAAM,WAC3B,IAEA,EAAI,UAAY,SAAsB,EAAK,EAAS,GAClD,GAAY,EAAM,EAAK,EAAS,EAAK,EAAK,EAAoB,GAChE,EAIA,EAAI,KAAO,SAAiB,EAAI,EAAM,GACpC,IAAI,EACA,EACA,EACA,EAAM,EAAK,IACf,IAAK,EAAK,CACR,IAAI,EAAY,GAAsB,EACpC,CAAC,GAAW,GAAc,IAAe,YAC3C,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,EAAM,EAAU,GAClB,CAEA,SAAS,IACP,EAAS,EAAK,CAAC,IAAK,EAAK,SAAU,EAAU,IAAK,GACpD,CAEA,EAAI,YAAY,IAAW,IAAI,GAAI,UAAY,SAAU,GAOvD,KANA,EAAW,GAAe,EAAE,OAAO,SAQjC,OADA,EAAM,GAAY,EAAa,WACxB,IAGT,IAAI,EACJ,GAAK,EAAK,IAQR,EAAM,EAAK,OA/nJnB,SAAgB,EAAK,GAGnB,IAFA,IACI,EADA,EAAU,EAAS,SAAS,QAExB,EAAO,EAAQ,OAAQ,CAC7B,IAAI,EAAM,EAAK,IACX,EAAO,EAAK,IACZ,EAAK,EAAK,GACV,EAAO,EAAK,GACZ,EAAW,EAAK,GAChB,EAA6B,IAApB,EAAS,OAElB,EAAU,EAAK,QAAU,EAAK,QAAQ,QAAU,GAGpD,GAFA,EAAQ,KAAK,CAAC,GAAI,EAAI,IAAK,EAAK,KAAM,IAElC,EACF,IAAK,IAAI,EAAI,EAAG,EAAM,EAAQ,OAAQ,EAAI,EAAK,IAAK,CAClD,IAAI,EAAc,EAAQ,GAG1B,GAFiB,EAAY,IAAM,IAAM,EAAY,KAElC,EAEjB,OAAO,EAAM,IAAM,CAEvB,CAGF,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,OAAQ,EAAI,EAAG,IAC1C,EAAQ,KAAK,CAAC,IAAK,EAAM,EAAG,IAAK,EAAS,GAAI,QAAS,GAE3D,CAGA,MAAM,IAAI,MAAM,4CAA8C,EAAS,GAAK,SAAW,EACzF,CA8lJ4B,CAAO,EAAK,IAAK,GAAY,EAAK,SALtD,GAFA,EAAM,EAAS,WACD,GAAU,GAGtB,OADA,EAAM,GAAY,EAAa,WACxB,IAMX,IAAI,EAAc,EAAI,YAAY,IAC9B,EAAM,EAAS,GAAK,KAAO,EAE/B,EAAY,MAAM,eAAe,IAAI,GAAK,UAAY,SAAU,GAK9D,IAJA,EAAM,EAAE,OAAO,UAEb,EAAM,GAAU,KAEb,EAEH,OADA,EAAM,GAAY,EAAa,WACxB,IAET,GACF,CACF,CACF,EAEA,EAAI,eAAiB,SAAU,EAAO,EAAU,EAAY,EAAM,GAChE,IAAI,EACJ,GAAI,EAAK,IACP,EAAM,EAAK,QACN,CACL,IAAI,EAAY,GAAsB,EACpC,CAAC,GAAW,GAAc,IAAe,YAC3C,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,EAAM,EAAU,GAClB,CACA,IAAI,EAAS,EAAW,OACpB,EAAO,EAAW,aAEtB,EAAI,YAAY,IAAc,IAAI,GAAQ,UAAY,SAAU,GAE9D,GADW,EAAE,OAAO,OAAO,KACR,EAAM,EAAK,QAAQ,SAAU,GAC9C,EAAS,KAAM,EACjB,GACF,CACF,EAEA,EAAI,MAAQ,SAAkB,GAC5B,IAAI,EACA,EAEA,EAAY,GAAsB,EAAK,CAAC,GAAY,IAAe,YACvE,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,IAAI,EAAM,EAAU,IACpB,EAAI,YAAY,IAAY,IAAI,IAAY,UAAY,SAAU,GAChE,EAAW,EAAE,OAAO,OAAO,QAC7B,EACA,EAAI,YAAY,IAAc,WAAW,KAAM,QAAQ,UAAY,SAAU,GAC3E,IAAI,EAAS,EAAE,OAAO,OACtB,EAAY,EAAS,EAAO,IAAM,CACpC,EAEA,EAAI,WAAa,WACf,EAAS,KAAM,CACb,UAAW,EACX,WAAY,EAEZ,sBAAwB,EAAI,MAAM,YAAc,SAAW,UAE/D,CACF,EAEA,EAAI,SAAW,SAAqB,EAAM,GACxC,GAAW,EAAM,EAAK,EAAoB,GAC5C,EAEA,EAAI,SAAW,SAAoB,GACjC,OAAO,GAAQ,EAAM,EAAK,EAAQ,EACpC,EAEA,EAAI,OAAS,SAAU,GAGrB,EAAI,QACJ,GAAU,OAAO,GACjB,GACF,EAEA,EAAI,iBAAmB,SAAU,EAAO,GACtC,IAAI,EAAY,GAAsB,EAAK,CAAC,IAAY,YACxD,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAElB,EAAU,IACN,YAAY,IAAW,IAAI,GACrC,UAAY,SAAU,GACxB,IAAI,EAAM,GAAe,EAAM,OAAO,QACjC,EAGH,EAAS,KAAM,EAAI,UAFnB,EAAS,GAAY,GAIzB,CACF,EAKA,EAAI,cAAgB,SAAU,EAAO,EAAM,GACzC,IAMI,EAAY,GAAsB,EANzB,CACX,GACA,GACA,GACA,IAEiD,aACnD,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,IAAI,EAAM,EAAU,IAEL,EAAI,YAAY,IAEtB,IAAI,GAAO,UAAY,SAAU,GACxC,IAAI,EAAW,GAAe,EAAM,OAAO,QAC3C,GAAgB,EAAS,UAAU,SAAU,EAAQ,EACF,EAAS,EAAK,GAC/D,IAAI,EAAM,EAAM,IAAM,GACK,IAAvB,EAAK,QAAQ,KACf,EAAK,OAAS,UAElB,IACA,GAAY,EAAM,EAAO,GACzB,IAAI,EAAgB,EAAS,WACzB,EAAU,EAAS,QACvB,EAAI,YAAY,IAAW,IACzB,GAAe,EAAU,EAAe,GAC5C,EACA,EAAI,QAAU,GAAS,GACvB,EAAI,WAAa,WACf,GACF,CACF,EAGA,EAAI,UAAY,SAAU,EAAI,GAC5B,IAAI,EAAY,GAAsB,EAAK,CAAC,IAAc,YAC1D,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,OAE5B,IACI,EADK,EAAU,IACN,YAAY,IAAa,IAAI,GAE1C,EAAI,QAAU,GAAS,GACvB,EAAI,UAAY,SAAU,GACxB,IAAI,EAAM,EAAE,OAAO,OACd,UAGI,EAAiB,YACxB,EAAS,KAAM,IAHf,EAAS,GAAY,GAKzB,CACF,EAEA,EAAI,UAAY,SAAU,EAAK,EAAM,GACf,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,UAEH,EAAI,WACX,IAAI,EAAS,EAAI,KACb,EAAK,EAAI,IAIX,EAAI,KAHD,EAGQ,MAAQ,SAAS,EAAO,MAAM,KAAK,GAAI,IAAM,GAF7C,MAKb,IACI,EADA,EAAK,EAAK,IAEd,IAAK,EAAI,CACP,IAAI,EAAY,GAAsB,EAAK,CAAC,IAAc,aAC1D,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,QAE5B,EAAK,EAAU,KACZ,QAAU,GAAS,GACtB,EAAG,WAAa,WACV,GACF,EAAS,KAAM,EAEnB,CACF,CAEA,IACI,EADA,EAAS,EAAG,YAAY,IAExB,GACF,EAAM,EAAO,IAAI,IACb,UAAY,SAAU,GACxB,IAAI,EAAS,EAAE,OAAO,OACjB,GAAU,EAAO,OAAS,EAGnB,EAAO,IAAI,GACjB,UAAY,WACd,EAAM,CAAC,IAAI,EAAM,GAAI,EAAI,IAAK,IAAK,EAAI,MACnC,EAAK,KACP,EAAS,KAAM,EAEnB,EARA,EAAS,GAAY,GAUzB,IAEA,EAAM,EAAO,IAAI,IACb,QAAU,SAAU,GAEtB,EAAS,GAAY,IACrB,EAAE,iBACF,EAAE,iBACJ,EACA,EAAI,UAAY,WACd,EAAM,CAAC,IAAI,EAAM,GAAI,EAAI,IAAK,IAAK,EAAI,MACnC,EAAK,KACP,EAAS,KAAM,EAEnB,EAEJ,EAEA,EAAI,aAAe,SAAU,EAAK,EAAM,GAClB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,IAaI,EAbA,EAAK,EAAK,IACd,IAAK,EAAI,CACP,IAAI,EAAY,GAAsB,EAAK,CAAC,IAAc,aAC1D,GAAI,EAAU,MACZ,OAAO,EAAS,EAAU,QAE5B,EAAK,EAAU,KACZ,WAAa,WACV,GACF,EAAS,KAAM,EAEnB,CACF,CAEA,IAAI,EAAK,EAAI,IACT,EAAS,EAAG,YAAY,IACxB,EAAM,EAAO,IAAI,GAErB,EAAI,QAAU,GAAS,GACvB,EAAI,UAAY,SAAU,GACxB,IAAI,EAAS,EAAE,OAAO,OACjB,GAAU,EAAO,OAAS,EAAI,MAGjC,EAAO,OAAO,GACd,EAAM,CAAC,IAAI,EAAM,GAAI,EAAI,IAAK,OAC1B,EAAK,KACP,EAAS,KAAM,IALjB,EAAS,GAAY,GAQzB,CACF,EAEA,EAAI,SAAW,SAAU,EAAM,GAC7B,GAAe,mBAAmB,GAGlC,IAAI,EAAU,GAAY,IAAI,GAC1B,GAAW,EAAQ,SACrB,EAAQ,OAAO,QACf,GAAU,OAAO,IAEnB,IAAI,EAAM,UAAU,eAAe,GAEnC,EAAI,UAAY,WAEd,GAAY,OAAO,GACf,KAAsB,KAAU,qBAC3B,aAAa,GAEtB,EAAS,KAAM,CAAE,IAAM,GACzB,EAEA,EAAI,QAAU,GAAS,EACzB,EAEA,IAAI,EAAS,GAAU,IAAI,GAE3B,GAAI,EAGF,OAFA,EAAM,EAAO,IACb,EAAI,MAAQ,EAAO,OACZ,KAAU,WACf,EAAS,KAAM,EACjB,IAGF,IAAI,EAAM,UAAU,KAAK,EAAQ,IACjC,GAAY,IAAI,EAAQ,GAExB,EAAI,gBAAkB,SAAU,GAC9B,IAAI,EAAK,EAAE,OAAO,OAClB,GAAI,EAAE,WAAa,EACjB,OAAO,EAAa,GAItB,IAAI,EAAM,EAAE,cAAc,YAItB,EAAE,WAAa,GACjB,EAAuB,GAErB,EAAE,WAAa,GACjB,EAAqB,GAGvB,IAAI,EAAa,CACf,EACA,EACA,EACA,GAGE,EAAI,EAAE,WAEV,SAAS,IACP,IAAI,EAAY,EAAW,EAAI,GAC/B,IACI,GACF,EAAU,EAAK,EAEnB,CAEA,GACF,EAEA,EAAI,UAAY,SAAU,IAExB,EAAM,EAAE,OAAO,QAEX,gBAAkB,WACpB,EAAI,QACJ,GAAU,OAAO,EACnB,EAEA,EAAI,QAAU,SAAU,GACtB,EAAe,QAAS,gCAAiC,EAAE,OAAO,OAClE,EAAwB,EAAE,OAAO,MACjC,EAAI,QACJ,GAAU,OAAO,EACnB,EASA,IAOI,EACA,EACA,EACA,EAVA,EAAM,EAAI,YAAY,CACxB,GACA,GACA,IACC,aAEC,GAAgB,EAMpB,SAAS,SACoB,IAAhB,GAAgC,IAG3C,EAAI,MAAQ,CACV,KAAM,EACN,WAAY,EACZ,YAAa,GAGf,GAAU,IAAI,EAAQ,CACpB,IAAK,EACL,OAAQ,EAAI,QAEd,EAAS,KAAM,GACjB,CAEA,SAAS,IACP,QAAwB,IAAb,QAA+C,IAAZ,EAA9C,CAGA,IAAI,EAAc,EAAS,MACvB,KAAe,EACjB,EAAa,EAAQ,GAErB,EAAQ,GAAe,EAAa,KAEtC,EAAQ,SAAW,EACnB,EAAI,YAAY,IAAY,IAAI,EARhC,CASF,CAKA,EAAI,YAAY,IAAY,IAAI,IAAY,UAAY,SAAU,GAChE,EAAU,EAAE,OAAO,QAAU,CAAE,GAAI,IACnC,GACF,EA17BJ,SAAmB,EAAK,GACV,EAAI,YAAY,IAAW,MAAM,kBACvC,MAAM,YAAY,KAAK,MAAM,UAAY,SAAU,GACvD,EAAG,EAAE,OAAO,OACd,CACF,CA07BI,CAAU,GAAK,SAAU,GACvB,EAAW,EACX,GACF,IAKK,KAEH,GAn+BN,SAA0B,GACxB,OAAO,IAAI,SAAQ,SAAU,GAC3B,IAAI,EAAU,GAAW,CAAC,KACtB,EAAM,EAAI,YAAY,IAA2B,IAAI,EAAS,OAElE,EAAI,UAAY,WACd,IAAI,EAAgB,UAAU,UAAU,MAAM,iBAC1C,EAAc,UAAU,UAAU,MAAM,UAG5C,EAAQ,IAAgB,GACtB,SAAS,EAAc,GAAI,KAAO,GACtC,EAEA,EAAI,QAAU,EAAI,QAAU,SAAU,GAGpC,EAAE,iBACF,EAAE,kBACF,GAAQ,EACV,CACF,IAAG,OAAM,WACP,OAAO,CACT,GACF,CA28B2B,CAAiB,IAGxC,GAAmB,MAAK,SAAU,GAChC,EAAc,EACd,GACF,IAIA,EAAI,WAAa,WACf,GAAgB,EAChB,GACF,EACA,EAAI,QAAU,GAAS,EACzB,EAEA,EAAI,QAAU,SAAU,GACtB,IAAI,EAAM,EAAE,OAAO,OAAS,EAAE,OAAO,MAAM,QAEtC,GAE8D,IAAxD,EAAI,QAAQ,yCACrB,EAAM,IAAI,MAAM,uHAFhB,EAAM,8DAKR,EAAe,QAAS,GACxB,EAAS,GAAY,GAAW,GAClC,CACF,CAlvBI,CAAK,EAAK,EAAM,EAClB,GAAG,EAAU,EAAI,YACnB,CAkvBA,GAAS,MAAQ,WAMf,IAGE,MAA4B,oBAAd,WAAoD,oBAAhB,WACpD,CAAE,MAAO,GACP,OAAO,CACT,CACF,EA0DA,MAAM,GAAqB,GACrB,GAAwB,GACxB,GAAyB,IACzB,GAAoB,IAE1B,IAAI,GAAqB,CAAC,EAE1B,SAAS,GAA8B,GACrC,IAAI,EAAM,EAAI,KAAO,EAAI,GACrB,EAAO,GAAO,EAAI,aACjB,GAGL,OAAO,KAAK,GAAM,SAAQ,SAAU,GAClC,IAAI,EAAM,EAAK,GACf,EAAI,KAAO,GAAa,EAAI,KAAM,EAAI,aACxC,GACF,CAEA,SAAS,GAAY,GACnB,MAAI,WAAW,KAAK,GACX,WAAa,mBAAmB,EAAG,MAAM,IAE9C,UAAU,KAAK,GACV,UAAY,mBAAmB,EAAG,MAAM,IAE1C,mBAAmB,EAC5B,CAEA,SAAS,GAAwB,GAC/B,OAAK,EAAI,cAAiB,OAAO,KAAK,EAAI,cAInC,QAAQ,IAAI,OAAO,KAAK,EAAI,cAAc,KAAI,SAAU,GAC7D,IAAI,EAAa,EAAI,aAAa,GAClC,GAAI,EAAW,MAAmC,iBAApB,EAAW,KACvC,OAAO,IAAI,SAAQ,SAAU,GAC3B,GAAa,EAAW,KAAM,EAChC,IAAG,MAAK,SAAU,GAChB,EAAW,KAAO,CACpB,GAEJ,KAZS,QAAQ,SAanB,CAYA,SAAS,GAAQ,EAAM,GAErB,GAZF,SAAsB,GACpB,IAAK,EAAK,OACR,OAAO,EAET,IAAI,EAAW,GAAS,EAAK,QAAQ,SACrC,MAAoB,SAAb,GAAoC,UAAb,CAChC,CAMM,CAAa,GAAO,CACtB,IAAI,EAAS,EAAK,KAAK,OAAO,EAAK,OAAO,QAG1C,EADa,EAAK,OAAO,QAAQ,OAAQ,KACzB,mBAAmB,EACrC,CAEA,IAAI,EAAM,GAAS,IACf,EAAI,MAAQ,EAAI,YAClB,EAAI,KAAO,CAAC,SAAU,EAAI,KAAM,SAAU,EAAI,WAKhD,IAAI,EAAQ,EAAI,KAAK,QAAQ,aAAc,IAAI,MAAM,KAUrD,OARA,EAAI,GAAK,EAAM,OAEc,IAAzB,EAAI,GAAG,QAAQ,OACjB,EAAI,GAAK,mBAAmB,EAAI,KAGlC,EAAI,KAAO,EAAM,KAAK,KAEf,CACT,CAGA,SAAS,GAAS,EAAM,GACtB,OAAO,GAAO,EAAM,EAAK,GAAK,IAAM,EACtC,CAGA,SAAS,GAAO,EAAM,GAGpB,IAAI,EAAW,EAAK,KAAY,IAAL,GAI3B,OAAO,EAAK,SAAW,MAAQ,EAAK,MAC5B,EAAK,KAAQ,IAAM,EAAK,KAAQ,IACjC,IAAM,EAAK,KAAO,EAAU,CACrC,CAEA,SAAS,GAAY,GACnB,MAAO,IAAM,OAAO,KAAK,GAAQ,KAAI,SAAU,GAC7C,OAAO,EAAI,IAAM,mBAAmB,EAAO,GAC7C,IAAG,KAAK,IACV,CAaA,SAAS,GAAU,EAAM,GAGvB,IAAI,EAAM,KAEN,EAAO,GAAQ,EAAK,KAAM,GAC1B,EAAQ,GAAS,EAAM,IAE3B,EAAO,EAAM,GAEb,MAAM,EAAW,eAAgB,EAAK,GAOpC,IALA,EAAU,GAAW,CAAC,GACd,QAAU,EAAQ,SAAW,IAAI,GAEzC,EAAQ,YAAc,UAElB,EAAK,MAAQ,EAAK,KAAM,CAC1B,IAAI,EAAQ,EAAK,MAAQ,EAAK,KAC1B,EAAM,EAAM,SAAW,IAAM,EAAM,SACnC,EAAQ,GAAS,SAAS,mBAAmB,KACjD,EAAQ,QAAQ,IAAI,gBAAiB,SAAW,EAClD,CAEA,IAAI,EAAU,EAAK,SAAW,CAAC,EAC/B,OAAO,KAAK,GAAS,SAAQ,SAAU,GACrC,EAAQ,QAAQ,OAAO,EAAK,EAAQ,GACtC,IAtCJ,SAAyB,GACvB,IAAI,EAA2B,oBAAd,WAA6B,UAAU,UACpD,UAAU,UAAU,cAAgB,GACpC,GAA+B,IAAxB,EAAG,QAAQ,QAClB,GAAuC,IAA3B,EAAG,QAAQ,WACvB,GAAiC,IAAxB,EAAG,QAAQ,QACpB,IAAU,WAAY,IAAyB,QAAhB,EAAK,OACxC,OAAQ,GAAQ,GAAa,IAAW,CAC1C,CAiCQ,CAAgB,KAClB,KAA8B,IAAtB,EAAI,QAAQ,KAAc,IAAM,KAAO,UAAY,KAAK,OAGlE,IAAI,EAAW,EAAK,OAAS,GAC7B,aAAa,EAAS,EAAK,EAC7B,EAEA,SAAS,EAAc,EAAM,GAC3B,OAAO,EAAW,GAAM,YAAa,GACnC,IAAQ,MAAK,WACX,OAAO,EAAI,MAAM,KAAM,EACzB,IAAG,OAAM,SAAU,GACF,EAAK,KACpB,CAAS,EACX,GACF,IAAG,KAAK,EACV,CAEA,eAAe,EAAU,EAAK,GAE5B,IAAI,EAAS,CAAC,GAEd,EAAU,GAAW,CAAC,GACd,QAAU,EAAQ,SAAW,IAAI,GAEpC,EAAQ,QAAQ,IAAI,iBACvB,EAAQ,QAAQ,IAAI,eAAgB,oBAEjC,EAAQ,QAAQ,IAAI,WACvB,EAAQ,QAAQ,IAAI,SAAU,oBAGhC,MAAM,QAAiB,EAAS,EAAK,GACrC,EAAO,GAAK,EAAS,GACrB,EAAO,OAAS,EAAS,OACzB,MAAM,QAAa,EAAS,OAG5B,GADA,EAAO,KAAO,GACT,EAAO,GAAI,CAGd,MAFA,EAAO,KAAK,OAAS,EAAO,OAClB,GAA0B,EAAO,KAE7C,CAYA,OAVI,MAAM,QAAQ,EAAO,QACvB,EAAO,KAAO,EAAO,KAAK,KAAI,SAAU,GACtC,OAAI,EAAE,OAAS,EAAE,QACR,GAA0B,GAE1B,CAEX,KAGK,CACT,CAEA,IAAI,EAEJ,eAAe,IACb,OAAI,EAAK,WACA,QAAQ,UAMb,IAIJ,EAAe,EAAU,GAAO,OAAM,SAAU,GAC9C,OAAI,GAAO,EAAI,QAAyB,MAAf,EAAI,QAE3B,EAAa,IAAK,mDACX,EAAU,EAAO,CAAC,OAAQ,SAE1B,QAAQ,OAAO,EAE1B,IAAG,OAAM,SAAU,GAIjB,SAAI,IAAO,EAAI,QAAyB,MAAf,EAAI,SAGtB,QAAQ,OAAO,EACxB,IAEA,EAAa,OAAM,WACjB,EAAe,IACjB,IAEO,EACT,CAsUA,SAAS,EAAmB,GAC1B,OAAO,EAAa,MAAM,KAAK,IAAI,oBAAoB,KAAK,IAC9D,CAtUA,KAAU,WACR,EAAS,KAAM,EACjB,IAEA,EAAI,SAAU,EAGd,EAAI,KAAO,WACT,MAAO,MACT,EAEA,EAAI,GAAK,EAAc,MAAM,eAAgB,GAC3C,IAAI,EACJ,IACE,MAAM,QAAiB,EAAS,GAAO,EAAM,KAC7C,QAAe,EAAS,MAC1B,CAAE,MAAO,GACP,EAAS,CAAC,CACZ,CAIA,EAAS,KADM,GAAU,EAAO,KAAS,EAAO,KAAO,EAAK,GAAM,GAAS,EAAM,IAEnF,IAIA,EAAI,QAAU,EAAc,WAAW,eAAgB,EAAM,GACvC,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,EAAO,EAAM,SAEP,EAAU,GAAS,EAAM,YAAa,CAAC,OAAQ,SAErD,SAAS,IACP,EAAI,MAAK,SAAU,EAAK,GAIlB,IAAQ,EAAI,gBACd,EAAS,KAAM,CAAC,IAAI,IAEpB,WAAW,EAAM,EAAK,UAAY,IAEtC,GACF,CAEA,EACF,IAEA,EAAI,QAAU,EAAW,WAAW,SAAU,EAAM,GAClD,IAAI,EAAO,KAEX,eAAe,EAAU,GACvB,IAAI,EAAS,CAAC,EACV,EAAK,OACP,EAAO,MAAO,GAEZ,EAAK,cAEP,EAAO,aAAc,GAEnB,EAAK,SACP,EAAO,QAAS,GAElB,IACE,MAAM,QAAe,EAAU,GAAS,EAAM,YAAc,GAAY,IAAU,CAChF,OAAQ,OACR,KAAM,KAAK,UAAU,CAAE,KAAM,EAAK,SAGhC,EAAK,aAAe,EAAK,QAC3B,EAAO,KAAK,QAAQ,SAAQ,SAAU,GACpC,EAAI,KAAK,QAAQ,GACnB,IAEF,EAAG,KAAM,EAAO,KAClB,CAAE,MAAO,GACP,EAAG,EACL,CACF,CAGA,SAAS,IAEP,IAAI,EAAY,GACZ,EAAa,KAAK,KAAK,EAAK,KAAK,OAAS,GAC1C,EAAU,EACV,EAAU,IAAI,MAAM,GAExB,SAAS,EAAS,GAChB,OAAO,SAAU,EAAK,GAEpB,EAAQ,GAAY,EAAI,UAClB,IAAY,GAChB,EAAS,KAAM,CAAC,QAAS,GAAQ,IAErC,CACF,CAEA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,IAAK,CACnC,IAAI,EAAU,EAAK,EAAM,CAAC,OAAQ,cAAe,SAAU,WAC3D,EAAQ,KAAO,EAAK,KAAK,MAAM,EAAI,EACjC,KAAK,IAAI,EAAK,KAAK,QAAS,EAAI,GAAK,IACvC,EAAQ,EAAM,EAAS,EAAS,GAClC,CACF,CAGA,IAAI,EAAQ,GAAO,EAAM,IACrB,EAAkB,GAAmB,GAGV,kBAApB,EAET,GAAU,SAAU,EAAK,GACnB,GACF,GAAmB,IAAS,EAC5B,EACE,EAAI,OACJ,uEAGF,MAEA,GAAmB,IAAS,EAC5B,EAAS,KAAM,GAEnB,IACS,EACT,EAAU,GAEV,GAEJ,IAKA,EAAI,MAAQ,eAAgB,GAC1B,UACQ,IACN,MAAM,QAAiB,EAAS,GAAS,EAAM,KACzC,QAAa,EAAS,OAC5B,EAAK,KAAO,GAAS,EAAM,IAC3B,EAAS,KAAM,EACjB,CAAE,MAAO,GACP,EAAS,EACX,CACF,EAEA,EAAI,MAAQ,eAAgB,EAAM,SAC1B,IACN,MAAM,EAA+B,MAAzB,EAAK,UAAU,EAAG,GAC9B,GAAO,EAAM,EAAK,UAAU,IAC5B,GAAS,EAAM,GACf,OAAO,EAAS,EAAK,EACvB,EAKA,EAAI,IAAM,EAAc,OAAO,eAAgB,EAAI,EAAM,GAEnC,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAKV,IAAI,EAAS,CAAC,EAoCd,SAAS,EAAiB,GACxB,IAAI,EAAO,EAAI,aACX,EAAY,GAAQ,OAAO,KAAK,GACpC,GAAK,GAAS,EAAU,OAgDxB,OA3iBN,SAAc,EAAkB,GAC9B,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,IAII,EAJA,EAAU,EACV,EAAU,EACV,EAAO,EACP,EAAM,EAAiB,OAQ3B,SAAS,MACD,IAAS,EAET,EACF,EAAO,GAEP,IAGF,GAEJ,CAEA,SAAS,IACP,IACA,GACF,CAGA,SAAS,EAAQ,GACf,IACA,EAAM,GAAO,EACb,GACF,CAEA,SAAS,IACP,KAAO,EAAU,GAAS,EAAU,GA9BpC,IACA,EAAiB,OAAa,KAAK,EAAW,EAgChD,CAEA,GACF,GACF,CA6fa,CARgB,EAAU,KAAI,SAAU,GAC7C,OAAO,WACL,OAnCJ,eAAyB,GACvB,MAAM,EAAM,EAAK,GACX,EAAO,GAAY,EAAI,KAAO,IAAM,EAAmB,GACzD,QAAU,EAAI,KAEZ,QAAiB,EAAS,GAAS,EAAM,IAE/C,IAAI,EAQA,EACJ,GAPE,EADE,WAAY,QACD,EAAS,eAGT,EAAS,OAIpB,EAAK,OAAQ,CACf,IAAI,EAAsB,OAAO,yBAAyB,EAAK,UAAW,QACrE,IAAuB,EAAoB,MAC9C,EAAK,KAAO,EAAI,cAElB,EAAO,CACT,MACE,QAAa,IAAI,SAAQ,SAAU,GACjC,GAAa,EAAM,EACrB,WAGK,EAAI,YACJ,EAAI,OACX,EAAI,KAAO,CACb,CAIW,CAAU,EACnB,CACF,IAI8B,EAChC,EA3FA,EAAO,EAAM,IAKJ,OACP,EAAO,MAAO,GAGZ,EAAK,YACP,EAAO,WAAY,GAGjB,EAAK,SACP,EAAO,QAAS,GAGd,EAAK,YACgB,QAAnB,EAAK,YACP,EAAK,UAAY,KAAK,UAAU,EAAK,YAEvC,EAAO,UAAY,EAAK,WAGtB,EAAK,MACP,EAAO,IAAM,EAAK,KAGhB,EAAK,YACP,EAAO,UAAY,EAAK,WAItB,EAAK,aACP,EAAO,WAAa,EAAK,YAG3B,EAAK,GAAY,GAmEjB,MAAM,EAAM,GAAS,EAAM,EAAK,GAAY,IAC5C,IACE,MAAM,QAAY,EAAU,GACxB,EAAK,mBAdkB,EAeC,EAAI,KAd5B,MAAM,QAAQ,GACT,QAAQ,IAAI,EAAU,KAAI,SAAU,GACzC,GAAI,EAAI,GACN,OAAO,EAAiB,EAAI,GAEhC,KAEK,EAAiB,IASxB,EAAS,KAAM,EAAI,KACrB,CAAE,MAAO,GACP,EAAM,MAAQ,EACd,EAAS,EACX,CArBA,IAA6B,CAsB/B,IAIA,EAAI,OAAS,EAAc,UAAU,eAAgB,EAAS,EAAW,EAAM,GAC7E,IAAI,EACqB,iBAAd,GAET,EAAM,CACJ,IAAK,EACL,KAAM,GAEY,mBAAT,IACT,EAAK,EACL,EAAO,CAAC,KAIV,EAAM,EACmB,mBAAd,GACT,EAAK,EACL,EAAO,CAAC,IAER,EAAK,EACL,EAAO,IAIX,MAAM,EAAO,EAAI,MAAQ,EAAK,IACxB,EAAM,GAAS,EAAM,GAAY,EAAI,MAAQ,QAAU,EAE7D,IAEE,EAAG,YADkB,EAAU,EAAK,CAAC,OAAQ,YAC7B,KAClB,CAAE,MAAO,GACP,EAAG,EACL,CACF,IAOA,EAAI,cAAgB,EAAc,iBAAiB,eAAgB,EAAO,EAChB,EAAM,GAC1C,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,MAAM,EAAS,EAAK,IAAO,QAAU,EAAK,IAAO,GAC3C,EAAM,GAAS,EAAM,GAAY,IAAU,IAC7C,EAAmB,GAAgB,EACvC,IAAI,EACJ,IACE,MAAM,QAAiB,EAAS,EAAK,CAAC,OAAQ,QAE9C,IAAK,EAAS,GACZ,MAAM,EAIR,IAAI,EASJ,GAVA,EAAc,EAAS,QAAQ,IAAI,gBAMjC,EAJqB,oBAAZ,SAA4B,QAAQ,SAAsC,mBAApB,EAAS,aAI3D,EAAS,aAHT,EAAS,SAOD,oBAAZ,UAA4B,QAAQ,QAAS,CACtD,IAAI,EAAsB,OAAO,yBAAyB,EAAK,UAAW,QACrE,IAAuB,EAAoB,MAC9C,EAAK,KAAO,EAEhB,CACA,EAAS,KAAM,EACjB,CAAE,MAAO,GACP,EAAS,EACX,CACF,IAGA,EAAI,iBAAoB,EAAc,oBAAoB,eACxD,EACA,EACA,EACA,GAEA,MAAM,EAAM,GAAS,EAAM,GAAY,GAAS,IAAM,EAAmB,IAAiB,QAAU,EAEpG,IAEE,EAAS,YADY,EAAU,EAAK,CAAC,OAAQ,YACvB,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,IAKA,EAAI,cAAgB,EAAc,iBAAiB,eACjD,EACA,EACA,EACA,EACA,EACA,GAEoB,mBAAT,IACT,EAAW,EACX,EAAO,EACP,EAAO,EACP,EAAM,MAER,MAAM,EAAK,GAAY,GAAS,IAAM,EAAmB,GACzD,IAAI,EAAM,GAAS,EAAM,GAKzB,GAJI,IACF,GAAO,QAAU,GAGC,iBAAT,EAAmB,CAE5B,IAAI,EACJ,IACE,EAAS,GAAS,EACpB,CAAE,MAAO,GACP,OAAO,EAAS,GAAY,EACZ,2CAClB,CACA,EAAO,EAAS,GAAmB,EAAQ,GAAQ,EACrD,CAEA,IAOE,EAAS,YALY,EAAU,EAAK,CAClC,QAAS,IAAI,GAAE,CAAC,eAAgB,IAChC,OAAQ,MACR,KAAM,KAEc,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,IAIA,EAAI,UAAY,eAAgB,EAAK,EAAM,GAIzC,EAAI,UAAY,EAAK,UAErB,UACQ,UACA,QAAQ,IAAI,EAAI,KAAK,IAAI,KAO/B,EAAS,YAJY,EAAU,GAAS,EAAM,cAAe,CAC3D,OAAQ,OACR,KAAM,KAAK,UAAU,MAED,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,EAGA,EAAI,KAAO,eAAgB,EAAK,EAAM,GACpC,UACQ,UACA,GAAwB,GAM9B,EAAS,YAJY,EAAU,GAAS,EAAM,GAAY,EAAI,MAAO,CACnE,OAAQ,MACR,KAAM,KAAK,UAAU,MAED,KACxB,CAAE,MAAO,GACP,EAAM,MAAQ,GAAO,EAAI,IACzB,EAAS,EACX,CACF,EAKA,EAAI,QAAU,EAAc,WAAW,eAAgB,EAAM,GACvC,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAKV,IACI,EADA,EAAS,CAAC,EAEV,EAAS,OALb,EAAO,EAAM,IAOJ,YACP,EAAO,WAAY,GAIjB,EAAK,aACP,EAAO,YAAa,GAGlB,EAAK,aACP,EAAO,YAAa,GAGlB,EAAK,eACP,EAAO,cAAe,GAIpB,EAAK,cACP,EAAO,aAAc,GAGnB,EAAK,MACP,EAAO,IAAM,KAAK,UAAU,EAAK,MAG/B,EAAK,YACP,EAAK,SAAW,EAAK,WAGnB,EAAK,WACP,EAAO,SAAW,KAAK,UAAU,EAAK,WAGpC,EAAK,UACP,EAAK,OAAS,EAAK,SAGjB,EAAK,SACP,EAAO,OAAS,KAAK,UAAU,EAAK,cAGJ,IAAvB,EAAK,gBACd,EAAO,gBAAkB,EAAK,oBAGN,IAAf,EAAK,QACd,EAAO,MAAQ,EAAK,YAGG,IAAd,EAAK,OACd,EAAO,KAAO,EAAK,MAGrB,IAAI,EAAW,GAAY,QAEF,IAAd,EAAK,OACd,EAAS,OACT,EAAO,CAAC,KAAM,EAAK,OAGrB,IACE,MAAM,QAAe,EAAU,GAAS,EAAM,YAAc,GAAW,CACrE,OAAQ,EACR,KAAM,KAAK,UAAU,KAEnB,EAAK,cAAgB,EAAK,aAAe,EAAK,QAChD,EAAO,KAAK,KAAK,QAAQ,IAE3B,EAAS,KAAM,EAAO,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,IAKA,EAAI,SAAW,SAAU,GAMvB,IAAI,EAAY,eAAgB,EAAO,EAAK,WAAa,IAEzD,EAAO,EAAM,IAEJ,cAAgB,cAAe,KACtC,EAAK,UAAY,IAGnB,IAAI,EAAkB,YAAa,EAAQ,EAAK,QAAU,IAGtD,YAAa,GAAQ,EAAK,SAC3B,EAAiB,EAAK,QAAW,KAChC,EAAiB,EAAK,QAAU,IAIhC,cAAe,GAAQ,EAAK,WAC5B,EAAiB,EAAK,UAAa,KACnC,EAAiB,EAAK,UAAY,IAGtC,IAAI,EAAS,CAAC,EACV,YAAa,GAAQ,EAAK,UAC5B,EAAO,QAAU,EAAK,SAGxB,IAAI,OAA+B,IAAf,EAAK,OAAyB,EAAK,MACnD,EAAc,EAqDlB,GAnDI,EAAK,QACP,EAAO,MAAQ,EAAK,QAGlB,EAAK,cAAgB,EAAK,QAAiC,mBAAhB,EAAK,UAClD,EAAO,cAAe,GAGpB,EAAK,cACP,EAAO,aAAc,GAGnB,EAAK,aACP,EAAO,KAAO,YAGZ,EAAK,eACP,EAAO,aAAe,EAAK,cAGzB,EAAK,YACP,EAAO,WAAY,GAGjB,EAAK,aACP,EAAO,YAAa,GAIlB,EAAK,aACP,EAAO,YAAa,GAGlB,cAAe,GAEb,EAAK,YACP,EAAO,UAAY,EAAK,WAIxB,EAAK,QAAiC,iBAAhB,EAAK,SAC7B,EAAO,OAAS,EAAK,QAGnB,EAAK,MAA6B,iBAAd,EAAK,OAC3B,EAAO,OAAS,QAChB,EAAO,KAAO,EAAK,MAKjB,EAAK,cAA6C,iBAAtB,EAAK,aACnC,IAAK,IAAI,KAAc,EAAK,aAEtB,OAAO,UAAU,eAAe,KAAK,EAAK,aAAc,KAC1D,EAAO,GAAc,EAAK,aAAa,IAK7C,IACI,EADA,EAAS,MAGT,EAAK,SAGP,EAAO,OAAS,WAChB,EAAS,OACT,EAAO,CAAC,QAAS,EAAK,UAGf,EAAK,WAEZ,EAAO,OAAS,YAChB,EAAS,OACT,EAAO,CAAC,SAAU,EAAK,WAGzB,IACI,EADA,EAAa,IAAI,GAKrB,MAAM,EAAY,eAAgB,EAAO,GACvC,GAAI,EAAK,QACP,OAEF,EAAO,MAAQ,EAGa,iBAAjB,EAAO,QAChB,EAAO,MAAQ,KAAK,UAAU,EAAO,QAGnC,EAAK,WACH,IACF,EAAO,MAAQ,GAGjB,EAAO,OAAU,GAAS,EAAc,EACtC,EAAY,EAIhB,IAAI,EAAM,GAAS,EAAM,WAAa,GAAY,IAC9C,EAAY,CACd,OAAQ,EAAW,OACnB,OAAQ,EACR,KAAM,KAAK,UAAU,IAKvB,GAHA,EAAiB,GAGb,EAAK,QAKT,UACQ,IAEN,EAAS,YADY,EAAU,EAAK,IACd,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,EAKA,IAAI,EAAU,CAAC,QAAS,IAExB,MAAM,EAAU,SAAU,EAAK,GAC7B,GAAI,EAAK,QACP,OAEF,IAAI,EAAqB,EAEzB,GAAI,GAAO,EAAI,QAAS,CACtB,EAAqB,EAAI,QAAQ,OACjC,EAAQ,SAAW,EAAI,SACvB,IAAI,EAAU,KACV,EAAU,KAGa,iBAAhB,EAAI,UACb,EAAU,EAAI,SAEgB,iBAArB,EAAQ,UAAqD,iBAArB,EAAQ,WACzD,EAAU,EAAQ,UAGV,CAAC,EACP,MAAQ,EAAK,aACjB,EAAI,QAAU,EAAI,QAAQ,QAAO,SAAU,GACzC,IACA,IAAI,EAAM,GAAa,EAAb,CAAmB,GAU7B,OATI,IACE,EAAK,cAAgB,EAAK,aAAe,EAAK,QAChD,GAA8B,GAE5B,EAAK,aACP,EAAQ,QAAQ,KAAK,GAEvB,EAAK,SAAS,EAAG,EAAS,IAErB,CACT,GACF,MAAO,GAAI,EAKT,OAFA,EAAK,SAAU,OACf,EAAK,SAAS,GAMZ,GAAO,EAAI,WACb,EAAiB,EAAI,UAGvB,IAAI,EAAY,GAAS,GAAe,GACrC,GAAO,EAAqB,GAC5B,EAAe,aAEb,EAAK,YAAgB,GAAS,GAAe,IAAQ,EAKxD,EAAK,SAAS,KAAM,GAHpB,KAAU,WAAc,EAAU,EAAgB,EAAU,GAKhE,EAKA,OAHA,EAAU,EAAK,OAAS,EAAG,GAGpB,CACL,OAAQ,WACN,EAAK,SAAU,EACf,EAAW,OACb,EAEJ,EAKA,EAAI,SAAW,EAAc,YAAY,eAAgB,EAAK,EAAM,GAE9C,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAGV,IAME,EAAS,YAJY,EAAU,GAAS,EAAM,cAAe,CAC3D,OAAQ,OACR,KAAM,KAAK,UAAU,MAED,KACxB,CAAE,MAAO,GACP,EAAS,EACX,CACF,IAEA,EAAI,OAAS,SAAU,GACrB,GACF,EAEA,EAAI,SAAW,eAAgB,EAAS,GACtC,IAEE,EAAS,WADU,EAAU,GAAS,EAAM,IAAK,CAAC,OAAQ,WAE5D,CAAE,MAAO,GACc,MAAjB,EAAM,OACR,EAAS,KAAM,CAAC,IAAI,IAEpB,EAAS,EAEb,CACF,CACF,CAGA,GAAU,MAAQ,WAChB,OAAO,CACT,EAOA,MAAM,WAAwB,MAC5B,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,oBACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,MAAM,WAAsB,MAC1B,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,YACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,MAAM,WAAqB,MACzB,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,gBACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,SAAS,GAAiB,EAAS,GAYjC,OAXI,GACF,EAAQ,MAAK,SAAU,GACrB,KAAU,WACR,EAAS,KAAM,EACjB,GACF,IAAG,SAAU,GACX,KAAU,WACR,EAAS,EACX,GACF,IAEK,CACT,CA0BA,SAAS,GAAc,EAAO,GAC5B,OAAO,WACL,IAAI,EAAO,UACP,EAAO,KACX,OAAO,EAAM,KAAI,WACf,OAAO,EAAe,MAAM,EAAM,EACpC,GACF,CACF,CAIA,SAAS,GAAK,GACZ,IAAI,EAAS,IAAI,EAAY,GACzB,EAAS,IAAI,MAAM,EAAO,MAC1B,GAAS,EAIb,OAHA,EAAO,SAAQ,SAAU,GACvB,IAAS,GAAS,CACpB,IACO,CACT,CAEA,SAAS,GAAe,GACtB,IAAI,EAAS,IAAI,MAAM,EAAI,MACvB,GAAS,EAIb,OAHA,EAAI,SAAQ,SAAU,EAAO,GAC3B,IAAS,GAAS,CACpB,IACO,CACT,CAEA,SAAS,GAAmB,GAI1B,OAAO,IAAI,GAHG,WAAa,EAAb,+DAIhB,CAEA,SAAS,GAAI,GAEX,IADA,IAAI,EAAS,EACJ,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAAK,CACjD,IAAI,EAAM,EAAO,GACjB,GAAmB,iBAAR,EAAkB,CAC3B,IAAI,MAAM,QAAQ,GAchB,MAAM,GAAmB,QAZzB,EAA2B,iBAAX,EAAsB,CAAC,GAAU,EACjD,IAAK,IAAI,EAAI,EAAG,EAAO,EAAI,OAAQ,EAAI,EAAM,IAAK,CAChD,IAAI,EAAO,EAAI,GACf,GAAoB,iBAAT,EACT,MAAM,GAAmB,aACK,IAAd,EAAO,GACvB,EAAO,KAAK,GAEZ,EAAO,IAAM,CAEjB,CAIJ,KAA6B,iBAAX,EAChB,GAAU,EAEV,EAAO,IAAM,CAEjB,CACA,OAAO,CACT,CAEA,IAAI,GAAM,EAAe,KAAK,KAAM,OAChC,GAAU,MAAM,QAChB,GAAS,KAAK,MAElB,SAAS,GAAqB,EAAM,GAClC,OAAO,GACL,WAAa,EAAK,QAAQ,QAAS,IAAM,KACzC,CACE,KAAM,EACN,IAAK,GACL,IAAK,GACL,QAAS,GACT,OAAQ,IAGd,CAQA,MAAM,GACJ,WAAA,GACE,KAAK,QAAU,IAAI,SAAQ,SAAU,GAAU,GAAW,GAC5D,CAEA,GAAA,CAAI,GAMF,OALA,KAAK,QAAU,KAAK,QAAQ,OAAM,WAElC,IAAG,MAAK,WACN,OAAO,GACT,IACO,KAAK,OACd,CAEA,MAAA,GACE,OAAO,KAAK,OACd,EAGF,SAAS,GAAU,GACjB,IAAK,EACH,MAAO,YAIT,cAAe,GACb,IAAK,WAGL,IAAK,SAEH,OAAO,EAAM,WACf,QAEE,OAAO,KAAK,UAAU,GAE5B,CAQA,eAAe,GAAW,EAAU,EAAU,EAAQ,EAAW,EAAW,GAC1E,MAAM,EANR,SAA6B,EAAQ,GAEnC,OAAO,GAAU,GAAU,GAAU,GAAa,WACpD,CAGwB,CAAoB,EAAQ,GAElD,IAAI,EACJ,IAAK,IAEH,EAAc,EAAS,aAAe,EAAS,cAAgB,CAAC,EAC5D,EAAY,IACd,OAAO,EAAY,GAIvB,MAAM,EAAiB,EAAS,OAAO,MAAK,eAAgB,GAC1D,MAAM,EAAY,EAAK,QAAU,YAChC,EAAY,OAAS,GAAU,UAkB1B,GAAO,EAAU,UAAY,GAdnC,SAAsB,GACpB,EAAI,MAAQ,EAAI,OAAS,CAAC,EAC1B,IAAI,EAAe,GACgB,IAA/B,EAAa,QAAQ,OACvB,EAAe,EAAW,IAAM,GAElC,MAAM,EAAS,EAAI,MAAM,GAAgB,EAAI,MAAM,IAAiB,CAAC,EAErE,IAAI,EAAO,GAIX,OADA,EAAO,IAAa,EACb,CACT,IAEA,MACM,SADY,EAAS,0BAA0B,IACtC,GACf,EAAG,iBAAkB,EACrB,MAAM,EAAO,CACX,KAAM,EACN,GAAI,EACJ,SAAU,EACV,QAAS,EAAS,QAClB,OAAQ,EACR,UAAW,GAGb,IAAI,EACJ,IACE,QAAmB,EAAK,GAAG,IAAI,iBACjC,CAAE,MAAO,GAEP,GAAmB,MAAf,EAAI,OACN,MAAM,CAEV,CAQA,OANA,EAAK,IAAM,EAAa,EAAW,IAAM,EACrC,GACF,EAAK,GAAG,KAAK,aAAa,kBACjB,EAAY,EACrB,IAEK,CACT,IAKA,OAHI,IACF,EAAY,GAAiB,GAExB,CACT,CAEA,IAAI,GAAmB,CAAC,EACpB,GAAgB,IAAI,GAGxB,SAAS,GAAc,GAGrB,OAA8B,IAAvB,EAAK,QAAQ,KAAc,CAAC,EAAM,GAAQ,EAAK,MAAM,IAC9D,CAQA,SAAS,GAAU,EAAI,EAAG,GACxB,IACE,EAAG,KAAK,QAAS,EACnB,CAAE,MAAO,GACP,EAAe,QACb,qMAIF,EAAe,QAAS,EAAG,EAC7B,CACF,CA+hCA,IAAI,GAAgB,CAClB,KAAM,SAAU,EAAM,GACpB,OAAO,GAAI,EACb,EAEA,OAAQ,SAAU,EAAM,GACtB,OAAO,EAAO,MAChB,EAEA,OAAQ,SAAU,EAAM,GAWtB,MAAO,CACL,IAAU,GAAI,GACd,IAAU,KAAK,IAAI,MAAM,KAAM,GAC/B,IAAU,KAAK,IAAI,MAAM,KAAM,GAC/B,MAAU,EAAO,OACjB,OAbF,SAAgB,GAEd,IADA,IAAI,EAAU,EACL,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAAK,CACjD,IAAI,EAAM,EAAO,GACjB,GAAY,EAAM,CACpB,CACA,OAAO,CACT,CAMW,CAAO,GAEpB,GA6CF,IACI,GA5kCJ,SAAiC,EAAc,EAAQ,EAAS,GAE9D,SAAS,EAAO,EAAI,EAAK,GAGvB,IACE,EAAI,EACN,CAAE,MAAO,GACP,GAAU,EAAI,EAAG,CAAC,IAAK,EAAK,IAAK,GACnC,CACF,CAEA,SAAS,EAAU,EAAI,EAAK,EAAM,EAAQ,GAKxC,IACE,MAAO,CAAC,OAAS,EAAI,EAAM,EAAQ,GACrC,CAAE,MAAO,GAEP,OADA,GAAU,EAAI,EAAG,CAAC,IAAK,EAAK,KAAM,EAAM,OAAQ,EAAQ,SAAU,IAC3D,CAAC,MAAO,EACjB,CACF,CAEA,SAAS,EAAmB,EAAG,GAC7B,MAAM,EAAa,GAAQ,EAAE,IAAK,EAAE,KACpC,OAAsB,IAAf,EAAmB,EAAa,GAAQ,EAAE,MAAO,EAAE,MAC5D,CAEA,SAAS,EAAa,EAAS,EAAO,GAEpC,OADA,EAAO,GAAQ,EACM,iBAAV,EACF,EAAQ,MAAM,EAAM,EAAQ,GAC1B,EAAO,EACT,EAAQ,MAAM,GAEhB,CACT,CAEA,SAAS,EAAW,GAClB,MAAM,EAAM,EAAI,MAIhB,OADe,GAAsB,iBAAR,GAAoB,EAAI,KAAQ,EAAI,EAEnE,CAeA,SAAS,EAAuB,GAC9B,OAAO,SAAU,GAIf,OAHI,EAAK,cAAgB,EAAK,aAAe,EAAK,QAftD,SAAuC,GACrC,EAAI,KAAK,SAAQ,SAAU,GACzB,MAAM,EAAO,EAAI,KAAO,EAAI,IAAI,aAC3B,GAGL,OAAO,KAAK,GAAM,SAAQ,SAAU,GAClC,MAAM,EAAM,EAAK,GACjB,EAAK,GAAU,KAAO,GAAa,EAAI,KAAM,EAAI,aACnD,GACF,GACF,CAKM,CAA8B,GAEzB,CACT,CACF,CAEA,SAAS,EAAa,EAAW,EAAM,EAAQ,GAE7C,IAAI,EAAM,EAAK,QACI,IAAR,IACL,IACF,EAAM,mBAAmB,KAAK,UAAU,KAE1C,EAAO,KAAK,EAAY,IAAM,GAElC,CAEA,SAAS,EAAc,GACrB,QAAgC,IAArB,EAAkC,CAC3C,MAAM,EAAW,OAAO,GAExB,OAAK,MAAM,IAAa,IAAa,SAAS,EAAkB,IAGvD,EAFA,CAIX,CACF,CAoBA,SAAS,EAAqB,EAAS,GACrC,MAAM,EAAe,EAAQ,WAAa,SAAW,WAC/C,EAAa,EAAQ,WAAa,WAAa,SAErD,QAAqC,IAA1B,EAAQ,SACc,IAAxB,EAAQ,IACf,GAAQ,EAAQ,GAAe,EAAQ,IAAe,EACtD,MAAM,IAAI,GAAgB,mGAErB,GAAI,EAAI,SAA6B,IAAnB,EAAQ,OAAkB,CACjD,GAAI,EAAQ,aACV,MAAM,IAAI,GAAgB,6CACrB,GAAI,EAAQ,MAAQ,EAAQ,KAAK,OAAS,IAC9C,EAAQ,QAAU,EAAQ,YAC3B,MAAM,IAAI,GAAgB,4DAG9B,CACA,CAAC,cAAe,QAAS,QAAQ,SAAQ,SAAU,GACjD,MAAM,EA9BV,SAA8B,GAC5B,GAAI,EAAQ,CACV,GAAsB,iBAAX,EACT,OAAQ,IAAI,GAAgB,+BAA+B,MAE7D,GAAI,EAAS,EACX,OAAO,IAAI,GAAgB,wCAAwC,KAEvE,CACF,CAqBkB,CAAqB,EAAQ,IAC3C,GAAI,EACF,MAAM,CAEV,GACF,CAiJA,SAAS,EAAW,GAClB,OAAO,SAAU,GAEf,GAAsB,MAAlB,EAAO,OACT,OAAO,EAEP,MAAM,CAEV,CACF,CAyGA,SAAS,EAAc,EAAM,EAAyB,GACpD,IAAI,EAAW,iBACf,OAAO,EAAK,GAAG,IAAI,GAChB,MAAM,EAAW,CAAC,IAAK,EAAU,IAAK,KACtC,MAAK,SAAU,GACd,IAAI,EAAS,GAAe,GAC5B,OAAO,QAAQ,IAAI,EAAO,KAAI,SAAU,GACtC,OA3GR,eAAgC,EAAO,EAAM,GAC3C,MAAM,EAAY,cAAgB,EAC5B,EAAiB,CAAC,IAAK,EAAW,KAAM,IACxC,EAAU,EAAwB,IAAI,GACtC,EAA2B,EAAQ,GACnC,EAAU,EAAQ,GA8DlB,QAtZV,SAAkB,GAGhB,OAA0B,IAAnB,EAAQ,QAAgB,MAAM,KAAK,EAAQ,GAAG,IACvD,CAuVU,CAAS,GAGJ,QAAQ,QAAQ,GAElB,EAAK,GAAG,IAAI,GAAW,MAAM,EAAW,KAuD3C,QApDN,SAAyB,GACvB,OAAK,EAAQ,KAAK,OAIX,EAAK,GAAG,QAAQ,CACrB,KAAM,EAAQ,KACd,cAAc,IAJP,QAAQ,QAAQ,CAAC,KAAM,IAMlC,CA2C2B,CAAgB,GAC3C,OA1CA,SAA6B,EAAS,GACpC,MAAM,EAAS,GACT,EAAU,IAAI,EAEpB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAU,KAAK,OAAQ,EAAI,EAAK,IAAK,CACzD,MACM,EADM,EAAU,KAAK,GACX,IAChB,GAAK,IAGL,EAAO,KAAK,GACZ,EAAQ,IAAI,EAAI,KAChB,EAAI,UAAY,EAAyB,IAAI,EAAI,MAC5C,EAAI,UAAU,CACjB,MAAM,EAAW,EAAyB,IAAI,EAAI,KAC9C,UAAW,IACb,EAAI,MAAQ,EAAS,MAEzB,CACF,CACA,MAAM,EAAU,GAAe,GAiB/B,OAhBA,EAAQ,SAAQ,SAAU,GACxB,IAAK,EAAQ,IAAI,GAAM,CAErB,MAAM,EAAQ,CACZ,IAAK,GAED,EAAW,EAAyB,IAAI,GAC1C,UAAW,IACb,EAAM,MAAQ,EAAS,OAEzB,EAAO,KAAK,EACd,CACF,IACA,EAAQ,KAAO,GAAK,EAAQ,OAAO,EAAQ,OAC3C,EAAO,KAAK,GAEL,CACT,CAIO,CAAoB,EAAS,EACtC,CAqCe,CAAiB,EAAO,EAAM,EACvC,KAAI,MAAK,SAAU,GACjB,IAAI,EAAgB,GAAQ,GAI5B,OAHA,EAAW,IAAM,EACjB,EAAc,KAAK,GAEZ,EAAK,GAAG,SAAS,CAAC,KAAO,GAClC,IAGG,MAAK,IA7Cd,SAAwB,GAGtB,OAAO,EAAK,SAAS,IAAI,iBAAiB,MAAK,SAAU,GACvD,MAAM,EAAW,EAAI,SACrB,OAAO,EAAK,GAAG,IAAI,mBAAmB,MAAK,SAAU,GACnD,OAAO,EAAI,IACb,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,CAGV,IAAG,MAAK,SAAU,GAChB,OAAO,EAAK,GAAG,IAAI,CACjB,IAAK,kBACL,KAAM,EACN,YAEJ,GACF,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,CAEV,GACF,CAqBoB,CAAe,IAC/B,GACJ,CAEA,SAAS,EAAS,GAChB,MAAM,EAA2B,iBAAT,EAAoB,EAAO,EAAK,KACxD,IAAI,EAAQ,GAAiB,GAI7B,OAHK,IACH,EAAQ,GAAiB,GAAY,IAAI,IAEpC,CACT,CAEA,eAAe,EAAW,EAAM,GAC9B,OAAO,GAAc,EAAS,IAAO,WACnC,OAIJ,eAAiC,EAAM,GAErC,IAAI,EACA,EACA,EAEJ,SAAS,EAAK,EAAK,GACjB,MAAM,EAAS,CAAC,GAAI,EAAI,IAAK,IAAK,GAAa,IAG3C,MAAO,IACT,EAAO,MAAQ,GAAa,IAE9B,EAAW,KAAK,EAClB,CAEA,MAAM,EAAS,EAAO,EAAK,OAAQ,GAEnC,IAAI,EAAa,EAAK,KAAO,EAE7B,SAAS,IACP,OAAO,EAAK,SAAS,OAAO,MAAK,SAAU,GACzC,EAAS,EAAK,SAAS,YAAY,IAAI,CACrC,KAAM,gBACN,YAAa,EAAK,WAAa,GAEnC,GACF,CAEA,SAAS,EAAc,EAAyB,GAC9C,OAAO,WACL,OAAO,EAAc,EAAM,EAAyB,EACtD,CACF,CAEA,IAAI,EAAe,EACnB,MAAM,EAAW,CACf,KAAM,EAAK,KACX,aAAc,GAEhB,EAAK,SAAS,KAAK,WAAY,GAE/B,MAAM,EAAQ,IAAI,GAElB,eAAe,IAUb,OAAO,QATgB,EAAK,SAAS,QAAQ,CAC3C,aAAa,EACb,WAAW,EACX,cAAc,EACd,MAAO,WACP,MAAO,EACP,MAAO,EAAK,2BAEO,IAEvB,CAEA,SAAS,IACP,OAAO,EAAK,GAAG,IAAI,mBAAmB,MAAK,SAAU,GACnD,OAAO,EAAI,QACb,IAAG,OAAM,SAAU,GACjB,GAAI,GAAsB,MAAf,EAAI,OACb,MAAM,EAER,OAAQ,CACV,IAAG,MAAK,SAAU,GAChB,OAAO,EAAK,SAAS,IAAI,iBAAiB,MAAK,SAAU,GACvD,MAAM,EAAe,EAAI,OAAO,QAAO,SAAU,EAAO,GACtD,OAAO,EAAQ,CACjB,IAAG,KAAK,GAAU,EAAM,QAElB,EAAe,EAAa,QAAO,SAAU,EAAO,GACxD,OAAO,EAAa,QAAQ,KAAW,CACzC,IAEA,OAAO,QAAQ,IAAI,EAAa,KAAI,SAAU,GAC5C,OAAO,EAAK,SAAS,IAAI,GAAO,MAAK,SAAU,GAC7C,MAAO,CAAE,QAAO,MAClB,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,MAAO,CAAE,QACX,GACF,IACF,IAAG,OAAM,SAAU,GACjB,GAAI,GAAsB,MAAf,EAAI,OACb,MAAM,EAER,MAAO,EACT,GACF,GACF,CAEA,SAAS,EAAa,EAAU,GAC9B,IAAI,EAAU,EAAS,QACvB,IAAK,EAAQ,SAAW,EAAO,OAC7B,OAGF,IAAK,IAAI,KAAS,EAAQ,CAIxB,GAHc,EAAQ,WAAU,SAAU,GACxC,OAAO,EAAO,KAAO,EAAM,KAC7B,IACY,EAAG,CAEb,MAAM,EAAQ,CACZ,IAAK,EAAM,MACX,IAAK,CACH,IAAK,EAAM,MACX,SAAU,GAEZ,QAAS,IAGP,EAAM,MAER,EAAM,IAAM,EAAM,IAClB,EAAM,QAAQ,KAAK,CAAE,IAAK,EAAM,IAAI,QAGtC,EAAQ,KAAK,EACf,CACF,CAEA,IAAI,EAA0B,EAA8B,GAE5D,EAAM,IAAI,EAAc,EAAyB,IAEjD,GAA8B,EAAQ,OACtC,MAAM,EAAW,CACf,KAAM,EAAK,KACX,SAAU,EAAS,SACnB,cAAe,EAAQ,OACvB,aAAc,GAKhB,OAHA,EAAK,SAAS,KAAK,WAAY,GAC/B,EAAK,SAAS,YAAY,OAAO,EAAQ,CAAC,gBAAiB,IAEvD,EAAQ,OAAS,EAAK,wBAA1B,EAGO,GACT,CAEA,SAAS,EAA8B,GACrC,MAAM,EAA0B,IAAI,EACpC,IAAK,IAAI,EAAI,EAAG,EAAM,EAAQ,OAAQ,EAAI,EAAK,IAAK,CAClD,MAAM,EAAS,EAAQ,GACvB,GAA0B,MAAtB,EAAO,IAAI,IAAI,GAAY,CAC7B,EAAa,GACb,EAAM,EAAO,IAER,EAAI,UACP,EAAO,EAAK,SAAU,EAAQ,GAEhC,EAAW,KAAK,GAEhB,MAAM,EAA2B,EAA+B,GAChE,EAAwB,IAAI,EAAO,IAAI,IAAK,CAC1C,EACA,EAAO,SAEX,CACA,EAAa,EAAO,GACtB,CACA,OAAO,CACT,CAEA,SAAS,EAA+B,GACtC,MAAM,EAA2B,IAAI,EACrC,IAAI,EACJ,IAAK,IAAI,EAAI,EAAG,EAAM,EAAW,OAAQ,EAAI,EAAK,IAAK,CACrD,MAAM,EAAkB,EAAW,GAC7B,EAAa,CAAC,EAAgB,IAAK,EAAgB,IACrD,EAAI,GAA+C,IAA1C,GAAQ,EAAgB,IAAK,IACxC,EAAW,KAAK,GAElB,EAAyB,IAAI,GAAkB,GAAa,GAC5D,EAAU,EAAgB,GAC5B,CACA,OAAO,CACT,CAEA,UACQ,UACA,UACA,EAAM,SACZ,EAAK,IAAM,EACX,EAAK,SAAS,YAAY,OAAO,EACnC,CAAE,MAAO,GACP,EAAK,SAAS,YAAY,OAAO,EAAQ,EAC3C,CACF,CArMW,CAAkB,EAAM,EACjC,GAFO,EAGT,CAuPA,SAAS,EAAU,EAAM,GACvB,OAAO,GAAc,EAAS,IAAO,WACnC,OAIJ,eAAgC,EAAM,GACpC,IAAI,EACJ,MAAM,EAAe,EAAK,YAA6B,IAAhB,EAAK,OACtC,EAAO,EAAK,MAAQ,OACD,IAAd,EAAK,MAAyB,EAAK,KAAK,SAEjD,EAAK,MAAQ,SACN,EAAK,MAGd,eAAe,EAAc,GAC3B,EAAS,cAAe,EACxB,MAAM,QAAY,EAAK,GAAG,QAAQ,GAGlC,OAFA,EAAY,EAAI,WAET,EAAI,KAAK,KAAI,SAAU,GAK5B,GAAI,UAAW,EAAO,KAAmC,iBAArB,EAAO,IAAI,OACxB,OAArB,EAAO,IAAI,MAAgB,CAC3B,MAAM,EAAO,OAAO,KAAK,EAAO,IAAI,OAAO,OAGrC,EAAe,CAAC,KAAM,MAAO,SACnC,KAAM,EAAO,GAAgB,EAAO,GAClC,OAAO,EAAO,IAAI,KAEtB,CAEA,MAAM,EAxqKd,SAA8B,GAM5B,IALA,IAAI,EAAQ,GACR,EAAY,GACZ,EAAI,IAGK,CACX,IAAI,EAAiB,EAAI,KACzB,GAAuB,OAAnB,EAQJ,OAAQ,GACN,IAAK,IACH,EAAM,KAAK,MACX,MACF,IAAK,IACH,EAAM,KAAgB,MAAX,EAAI,IACf,IACA,MACF,IAAK,IACH,IAAI,EAAY,GAAY,EAAK,GACjC,EAAM,KAAK,EAAU,KACrB,GAAK,EAAU,OACf,MACF,IAAK,IAGH,IAFA,IAAI,EAAY,KAEH,CACX,IAAI,EAAK,EAAI,GACb,GAAW,OAAP,EACF,MAEF,GAAa,EACb,GACF,CAIA,EAAY,EAAU,QAAQ,gBAAiB,MAC5C,QAAQ,gBAAiB,KACzB,QAAQ,gBAAiB,KAE5B,EAAM,KAAK,GACX,MACF,IAAK,IACH,IAAI,EAAe,CAAE,QAAS,GAAI,MAAO,EAAM,QAC/C,EAAM,KAAK,EAAa,SACxB,EAAU,KAAK,GACf,MACF,IAAK,IACH,IAAI,EAAa,CAAE,QAAS,CAAC,EAAG,MAAO,EAAM,QAC7C,EAAM,KAAK,EAAW,SACtB,EAAU,KAAK,GACf,MAEF,QACE,MAAM,IAAI,MACR,4DACE,OAvDR,CACE,GAAqB,IAAjB,EAAM,OACR,OAAO,EAAM,MAEb,GAAI,EAAO,EAGf,CAkDF,CACF,CAsmKkC,CAAqB,EAAO,IAAI,KAC1D,MAAO,CACL,IAAK,EAAkB,GACvB,GAAI,EAAkB,GACtB,MAAQ,UAAW,EAAO,IAAM,EAAO,IAAI,MAAQ,KAEvD,GACF,CAEA,eAAe,EAAkB,GAC/B,IAAI,EAqBJ,GAnBE,EADE,EAlGR,SAAoB,EAAM,EAAS,GACL,IAAxB,EAAQ,oBACH,EAAQ,YAGjB,MAAM,EAAc,EAAQ,OAAS,EAAQ,YAEvC,EAAY,EAAQ,EAAK,WAEzB,EAAS,GACT,EAAM,MAAM,EAAQ,aAAe,OAAO,kBAC9C,EAAQ,YACV,EAAQ,SAAQ,SAAU,GACxB,MAAM,EAAO,EAAO,EAAO,OAAS,GACpC,IAAI,EAAW,EAAc,EAAE,IAAM,KAOrC,GAJI,GAAe,MAAM,QAAQ,KAC/B,EAAW,EAAS,MAAM,EAAG,IAG3B,GAA6C,IAArC,GAAQ,EAAK,SAAU,GAGjC,OAFA,EAAK,KAAK,KAAK,CAAC,EAAE,IAAK,EAAE,UACzB,EAAK,OAAO,KAAK,EAAE,OAGrB,EAAO,KAAK,CACV,KAAM,CAAC,CAAC,EAAE,IAAK,EAAE,KACjB,OAAQ,CAAC,EAAE,OACX,SAAU,GAEd,IACA,EAAU,GACV,IAAK,IAAI,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAAK,CACjD,MAAM,EAAI,EAAO,GACX,EAAY,EAAU,EAAK,SAAU,EAAW,EAAE,KAAM,EAAE,QAAQ,GACxE,GAAI,EAAU,OAAS,EAAU,iBAAiB,GAEhD,MAAM,EAAU,MAElB,EAAQ,KAAK,CAEX,MAAO,EAAU,MAAQ,KAAO,EAAU,OAC1C,IAAK,EAAE,UAEX,CAEA,MAAO,CAAC,KAAM,EAAa,EAAS,EAAQ,MAAO,EAAQ,MAC7D,CAmDqB,CAAW,EAAM,EAAM,QACR,IAAd,EAAK,KACN,CACb,WAAY,EACZ,OAAQ,EACR,KAAM,GAIO,CACb,WAAY,EACZ,OAAQ,EACR,KAAM,EAAa,EAAK,EAAK,MAAM,EAAK,OAIxC,EAAK,aACP,EAAa,WAAa,EAAK,KAE7B,EAAK,aAAc,CACrB,MAAM,EAAS,GAAK,EAAK,IAAI,IAEvB,QAAmB,EAAK,SAAS,QAAQ,CAC7C,KAAM,EACN,cAAc,EACd,UAAW,EAAK,UAChB,YAAa,EAAK,YAClB,OAAQ,EAAK,SAEf,IAAI,EAAe,IAAI,EAWvB,OAVA,EAAW,KAAK,SAAQ,SAAU,GAChC,EAAa,IAAI,EAAI,GAAI,EAAI,IAC/B,IACA,EAAK,SAAQ,SAAU,GACrB,IAAI,EAAQ,EAAW,GACnB,EAAM,EAAa,IAAI,GACvB,IACF,EAAI,IAAM,EAEd,IACO,CACT,CACE,OAAO,CAEX,CAEA,QAAyB,IAAd,EAAK,KAAsB,CACpC,MACM,EADO,EAAK,KACS,KAAI,SAAU,GACvC,MAAM,EAAW,CACf,SAAW,GAAkB,CAAC,IAC9B,OAAW,GAAkB,CAAC,EAAK,CAAC,KAMtC,OAHI,EAAK,aACP,EAAS,YAAa,GAEjB,EAAc,EACvB,IAGA,OAAO,EADiB,SADH,QAAQ,IAAI,IAGnC,CAAO,CACL,MAAM,EAAW,CACf,WAAa,EAAK,YAMpB,IAAI,EACA,EAkBJ,GAtBI,EAAK,aACP,EAAS,YAAa,GAIpB,cAAe,IACjB,EAAW,EAAK,WAEd,aAAc,IAChB,EAAW,EAAK,UAEd,YAAa,IACf,EAAS,EAAK,SAEZ,WAAY,IACd,EAAS,EAAK,aAEQ,IAAb,IACT,EAAS,SAAW,EAAK,WACvB,GAAkB,CAAC,EAAU,CAAC,IAC9B,GAAkB,CAAC,UAED,IAAX,EAAwB,CACjC,IAAI,GAAsC,IAAvB,EAAK,cACpB,EAAK,aACP,GAAgB,GAGlB,EAAS,OAAS,GAChB,EAAe,CAAC,EAAQ,CAAC,GAAK,CAAC,GACnC,CACA,QAAwB,IAAb,EAAK,IAAqB,CACnC,MAAM,EAAW,GAAkB,CAAC,EAAK,MACnC,EAAS,GAAkB,CAAC,EAAK,IAAK,CAAC,IACzC,EAAS,YACX,EAAS,OAAS,EAClB,EAAS,SAAW,IAEpB,EAAS,SAAW,EACpB,EAAS,OAAS,EAEtB,CACK,IACuB,iBAAf,EAAK,QACd,EAAS,MAAQ,EAAK,OAExB,EAAS,KAAO,GAIlB,OAAO,QADc,EAAc,GAErC,CACF,CAtKW,CAAiB,EAAM,EAChC,GAFO,EAGT,CA+OA,eAAe,EAAc,EAAI,EAAK,GAEpC,GAAyB,mBAAd,EAAG,OACZ,OA1pBJ,SAAqB,EAAI,EAAK,GAC5B,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,EAAG,OAAO,EAAK,GAAM,SAAU,EAAK,GAClC,GAAI,EACF,OAAO,EAAO,GAEhB,EAAQ,EACV,GACF,GACF,CAipBW,CAAY,EAAI,EAAK,GAE9B,GAAI,GAAS,GACX,OAnxBJ,eAAyB,EAAI,EAAK,GAEhC,IACI,EAEA,EAHA,EAAS,GAET,EAAS,MA+Bb,GAxBA,EAAa,SAAU,EAAM,GAC7B,EAAa,eAAgB,EAAM,GACnC,EAAa,cAAe,EAAM,GAClC,EAAa,QAAS,EAAM,GAC5B,EAAa,aAAc,EAAM,GACjC,EAAa,QAAS,EAAM,GAC5B,EAAa,cAAe,EAAM,GAClC,EAAa,OAAQ,EAAM,GAC3B,EAAa,QAAS,EAAM,GAC5B,EAAa,YAAa,EAAM,GAChC,EAAa,WAAY,EAAM,GAAQ,GACvC,EAAa,YAAa,EAAM,GAAQ,GACxC,EAAa,SAAU,EAAM,GAAQ,GACrC,EAAa,UAAW,EAAM,GAAQ,GACtC,EAAa,gBAAiB,EAAM,GACpC,EAAa,MAAO,EAAM,GAAQ,GAClC,EAAa,aAAc,EAAM,GAGjC,EAAS,EAAO,KAAK,KACrB,EAAoB,KAAX,EAAgB,GAAK,IAAM,OAIX,IAAd,EAAK,KAAsB,CACpC,MAAM,EAAiB,IAIjB,EAAe,QAAQ,mBAAmB,KAAK,UAAU,EAAK,SAChE,EAAa,OAAS,EAAO,OAAS,GAAK,EAG7C,IAAyB,MAAd,EAAO,GAAa,IAAM,KAAO,GAE5C,EAAS,OACU,iBAAR,EACT,EAAO,CAAC,KAAM,EAAK,MAEnB,EAAI,KAAO,EAAK,KAGtB,CAGA,GAAmB,iBAAR,EAAkB,CAC3B,MAAM,EAAQ,GAAc,GAEtB,QAAiB,EAAG,MAAM,WAAa,EAAM,GAAK,UAAY,EAAM,GAAK,EAAQ,CACrF,QAAS,IAAI,GAAE,CAAC,eAAgB,qBAChC,OAAQ,EACR,KAAM,KAAK,UAAU,KAEvB,EAAK,EAAS,GAEd,MAAM,QAAe,EAAS,OAE9B,IAAK,EAEH,MADA,EAAO,OAAS,EAAS,OACnB,GAA0B,GAWlC,OAPA,EAAO,KAAK,SAAQ,SAAU,GAE5B,GAAI,EAAI,OAAS,EAAI,MAAM,OAA6B,yBAApB,EAAI,MAAM,MAC5C,MAAM,IAAI,MAAM,EAAI,OAExB,IAEO,IAAI,SAAQ,SAAU,GAC3B,EAAQ,EACV,IAAG,KAAK,EAAuB,GACjC,CAGA,EAAO,GAAQ,CAAC,EAChB,OAAO,KAAK,GAAK,SAAQ,SAAU,GAC7B,MAAM,QAAQ,EAAI,IACpB,EAAK,GAAO,EAAI,GAEhB,EAAK,GAAO,EAAI,GAAK,UAEzB,IAEA,MAAM,QAAiB,EAAG,MAAM,aAAe,EAAQ,CACrD,QAAS,IAAI,GAAE,CAAC,eAAgB,qBAChC,OAAQ,OACR,KAAM,KAAK,UAAU,KAGvB,EAAK,EAAS,GAEd,MAAM,QAAe,EAAS,OAC9B,IAAK,EAEH,MADA,EAAO,OAAS,EAAS,OACnB,GAA0B,GAGlC,OAAO,IAAI,SAAQ,SAAU,GAC3B,EAAQ,EACV,IAAG,KAAK,EAAuB,GACjC,CAkqBW,CAAU,EAAI,EAAK,GAG5B,MAAM,EAAiB,CACrB,mBAAoB,EAAG,OAAO,gCAr9BT,IAw9BvB,GAAmB,iBAAR,EAkBT,OAhBA,EAAqB,EAAM,GAE3B,GAAc,KAAI,iBAChB,MAAM,QAAa,GACF,EACA,sBACF,EAAI,IACD,EAAI,QACJ,EACG,GAErB,OAhsCK,EAgsCM,EAAW,EAAM,GAAgB,MAC1C,WAAc,OAAO,EAAU,EAAM,EAAO,IAjsChC,EAksCZ,WAAc,OAAO,EAAK,GAAG,SAAW,EAjsCzC,EAAQ,MAAK,SAAU,GAC5B,OAAO,IAAsB,MAAK,WAChC,OAAO,CACT,GACF,IAAG,SAAU,GACX,OAAO,IAAsB,MAAK,WAChC,MAAM,CACR,GACF,IATF,IAAa,EAAS,CAosChB,IACO,GAAc,SAChB,CAEL,MAAM,EAAe,EACf,EAAQ,GAAc,GACtB,EAAgB,EAAM,GACtB,EAAW,EAAM,GAEjB,QAAY,EAAG,IAAI,WAAa,GAGtC,KAFA,EAAM,EAAI,OAAS,EAAI,MAAM,IAI3B,MAAM,IAAI,GAAc,QAAQ,EAAI,yBAAyB,KAG/D,EAAc,EAAK,GACnB,EAAqB,EAAM,GAE3B,MAAM,QAAa,GACF,EACA,EACF,EAAI,IACD,EAAI,QACJ,EACG,GAErB,MAAmB,OAAf,EAAK,OAAiC,iBAAf,EAAK,OACX,iBAAf,EAAK,OACP,KAAU,WACR,EAAW,EAAM,EACnB,IAEK,EAAU,EAAM,WAEjB,EAAW,EAAM,GAChB,EAAU,EAAM,GAE3B,CACF,CAqBA,MAAM,GA7wCa,EA6wCqB,WACtC,MAAM,EAAK,KAEX,MAA+B,mBAApB,EAAG,aAvuBhB,SAA2B,GACzB,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,EAAG,cAAa,SAAU,EAAK,GAC7B,GAAI,EACF,OAAO,EAAO,GAEhB,EAAQ,EACV,GACF,GACF,CA+tBW,CAAkB,GAEvB,GAAS,GA1Kf,eAA+B,GAK7B,aAJuB,EAAG,MAAM,gBAAiB,CAC/C,QAAS,IAAI,GAAE,CAAC,eAAgB,qBAChC,OAAQ,UAEM,MAClB,CAqKW,CAAgB,GAnK3B,eAAgC,GAC9B,IACE,MAAM,QAAgB,EAAG,IAAI,UAAY,GACnC,EAAc,IAAI,EAExB,OAAO,KAAK,EAAQ,OAAO,SAAQ,SAAU,GAC3C,MAAM,EAAQ,GAAc,GACtB,EAAgB,WAAa,EAAM,GACnC,EAAW,EAAM,GACvB,IAAI,EAAQ,EAAY,IAAI,GACvB,IACH,EAAQ,IAAI,EACZ,EAAY,IAAI,EAAe,IAEjC,EAAM,IAAI,EACZ,IACA,MAAM,EAAO,CACX,KAAO,GAAe,GACtB,cAAe,GAGX,QAAY,EAAG,QAAQ,GACvB,EAAgB,CAAC,EACvB,EAAI,KAAK,SAAQ,SAAU,GACzB,MAAM,EAAW,EAAI,IAAI,UAAU,GACnC,EAAY,IAAI,EAAI,KAAK,SAAQ,SAAU,GACzC,IAAI,EAAe,EAAW,IAAM,EAE/B,EAAQ,MAAM,KAGjB,EAAe,GAEjB,MAAM,EAAc,OAAO,KAAK,EAAQ,MAAM,IAExC,EAAe,EAAI,KAAO,EAAI,IAAI,OACtC,EAAI,IAAI,MAAM,GAChB,EAAY,SAAQ,SAAU,GAC5B,EAAc,GACZ,EAAc,IAAe,CACjC,GACF,GACF,IAEA,MAGM,EAHc,OAAO,KAAK,GAC7B,QAAO,SAAU,GAAc,OAAQ,EAAc,EAAa,IAEjC,KAAI,SAAU,GAChD,OAAO,GAAc,EAAS,IAAa,WACzC,OAAO,IAAI,EAAG,YAAY,EAAY,EAAG,QAAQ,SACnD,GAFO,EAGT,IAEA,OAAO,QAAQ,IAAI,GAAiB,MAAK,WACvC,MAAO,CAAC,IAAI,EACd,GACF,CAAE,MAAO,GACP,GAAmB,MAAf,EAAI,OACN,MAAO,CAAC,IAAI,GAEZ,MAAM,CAEV,CACF,CAsGS,CAAiB,EAC1B,EAtxCO,YAAa,GAClB,IAAI,EAAK,EAAK,MACV,EAAU,EAAI,MAAM,KAAM,GAI9B,MAHkB,mBAAP,GACT,GAAiB,EAAS,GAErB,CACT,GARF,IAAqB,EAyxCnB,MAAO,CACL,MAhCF,SAAuB,EAAK,EAAM,GAChC,MAAM,EAAK,KACS,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,EAAO,EAv4BT,SAAuB,GAIrB,OAHA,EAAK,YAAc,EAAc,EAAK,aACtC,EAAK,MAAQ,EAAc,EAAK,OAChC,EAAK,KAAO,EAAc,EAAK,MACxB,CACT,CAk4BgB,CAAc,GAAQ,CAAC,EAElB,mBAAR,IACT,EAAM,CAAC,IAAM,IAGf,MAAM,EAAU,QAAQ,UAAU,MAAK,WACrC,OAAO,EAAc,EAAI,EAAK,EAChC,IAEA,OADA,GAAiB,EAAS,GACnB,CACT,EAgBE,YAAa,EAEjB,CA2Ee,CADI,WA9BnB,SAAgB,EAAQ,GAEtB,GAAsB,mBAAX,GAA2C,IAAlB,EAAO,OAAc,CACvD,IAAI,EAAU,EACd,OAAO,SAAU,GACf,OAAO,EAAQ,EAAK,EACtB,CACF,CACE,OAAO,GAAqB,EAAO,WAAY,EAEnD,IAEA,SAAiB,GACf,IAAI,EAAkB,EAAU,WAC5B,EA1BN,SAAoB,GAClB,GAAI,QAAQ,KAAK,GACf,OAAO,GAAc,KAChB,GAAI,UAAU,KAAK,GACxB,OAAO,GAAc,OAChB,GAAI,UAAU,KAAK,GACxB,OAAO,GAAc,OAChB,GAAI,KAAK,KAAK,GACnB,MAAM,IAAI,MAAM,EAAkB,uCAEtC,CAgBgB,CAAW,GACzB,OAAI,GAGK,GAAqB,EAEhC,IAEA,SAAuB,EAAM,GAC3B,IAAI,EAAM,EAAK,OAAS,EAAK,MAAM,GACnC,GAAuB,iBAAZ,EAAI,IACb,MAAM,IAAI,GAAc,QAAU,EAAK,IAAM,6BAC3C,EAAW,0CAA4C,EAAI,IAEjE,IAaA,IAAI,GAAY,CACd,MATF,SAAe,EAAK,EAAM,GACxB,OAAO,GAAS,MAAM,KAAK,KAAM,EAAK,EAAM,EAC9C,EAQE,YANF,SAAqB,GACnB,OAAO,GAAS,YAAY,KAAK,KAAM,EACzC,GAaA,SAAS,GAAkB,EAAI,GAC7B,IAAI,EAAY,OAAO,KAAK,EAAI,cAChC,OAAO,QAAQ,IAAI,EAAU,KAAI,SAAU,GACzC,OAAO,EAAG,cAAc,EAAI,IAAK,EAAU,CAAC,IAAK,EAAI,MACvD,IACF,CAqDA,SAAS,GAAQ,EAAK,EAAQ,EAAO,GACnC,EAAQ,EAAM,GAEd,IAAI,EAAa,GACb,GAAK,EAuDT,OAAO,QAAQ,UACZ,MAtDH,WAEE,IAAI,EAjCR,SAA2B,GACzB,IAAI,EAAW,GAWf,OAVA,OAAO,KAAK,GAAO,SAAQ,SAAU,GACjB,EAAM,GAAI,QAChB,SAAQ,SAAU,GAC5B,EAAS,KAAK,CACZ,GAAI,EACJ,IAAK,GAET,GACF,IAEO,CACL,KAAM,EACN,MAAM,EACN,QAAQ,EAEZ,CAgBsB,CAAkB,GAEpC,GAAK,EAAY,KAAK,OAItB,OAAO,EAAI,QAAQ,GAAa,MAAK,SAAU,GAE7C,GAAI,EAAM,UACR,MAAM,IAAI,MAAM,aAElB,OAAO,QAAQ,IAAI,EAAgB,QAAQ,KAAI,SAAU,GACvD,OAAO,QAAQ,IAAI,EAAY,KAAK,KAAI,SAAU,GAChD,IAAI,EAAY,EAAI,GAQpB,OANI,EAAI,QAGN,GAAK,GAGF,GAAc,EAAU,aAhFvC,SAA6C,EAAQ,EAAK,GACxD,IAAI,EAA6B,GAAS,KAAS,GAAS,GACxD,EAAY,OAAO,KAAK,EAAI,cAEhC,OAAK,EAIE,EAAO,IAAI,EAAI,KAAK,MAAK,SAAU,GACxC,OAAO,QAAQ,IAAI,EAAU,KAAI,SAAU,GACzC,OAvBN,SAAwB,EAAU,EAAW,GAC3C,OAAQ,EAAS,eACT,EAAS,aAAa,IACvB,EAAS,aAAa,GAAU,SAAW,EAAU,aAAa,GAAU,MACrF,CAmBU,CAAe,EAAU,EAAK,GACzB,EAAI,cAAc,EAAI,IAAK,GAG7B,EAAO,cAAc,EAAS,IAAK,EAC5C,IACF,IAAG,OAAM,SAAU,GAEjB,GAAqB,MAAjB,EAAM,OACR,MAAM,EAGR,OAAO,GAAkB,EAAK,EAChC,IAlBS,GAAkB,EAAK,EAmBlC,CA4DiB,CAAoC,EAAQ,EAAK,GAC9C,MAAK,SAAU,GACR,IAAI,EAAY,OAAO,KAAK,EAAU,cAS3B,OARX,EACG,SAAQ,SAAU,EAAY,GACpB,IAAI,EAAM,EAAU,aAAa,EAAU,WACpC,EAAI,YACJ,EAAI,OACX,EAAI,KAAO,CACb,IAEO,CACT,IAfjB,CAgBX,IACF,KAEC,MAAK,SAAU,GACd,EAAa,EAAW,OAAO,GAAQ,GAAS,OAAO,SACzD,GACF,GACF,IAQG,MANH,WACE,MAAO,CAAE,GAAG,EAAI,KAAK,EACvB,GAKF,CAEA,IACI,GAAa,UASb,GAAa,EAEjB,SAAS,GAAiB,EAAI,EAAI,EAAY,EAAS,GACrD,OAAO,EAAG,IAAI,GAAI,OAAM,SAAU,GAChC,GAAmB,MAAf,EAAI,OAMN,MALmB,SAAf,EAAG,SAAqC,UAAf,EAAG,SAC9B,EACE,IAAK,2DAGF,CACL,WAAY,EACZ,IAAK,EACL,QAAS,GACT,WAAY,GACZ,QAzBiB,GA4BrB,MAAM,CACR,IAAG,MAAK,SAAU,GAChB,IAAI,EAAY,WAKZ,EAAI,WAAa,EA0BrB,OArBA,EAAI,SAAW,EAAI,SAAW,IAAI,QAAO,SAAU,GACjD,OAAO,EAAK,aAAe,CAC7B,IAGA,EAAI,QAAQ,QAAQ,CAClB,SAAU,EACV,WAAY,IAMd,EAAI,QAAU,EAAI,QAAQ,MAAM,EA5CN,GA8C1B,EAAI,QAvDiB,EAwDrB,EAAI,WAAa,GAEjB,EAAI,WAAa,EACjB,EAAI,SAAW,EAER,EAAG,IAAI,GAAK,OAAM,SAAU,GACjC,GAAmB,MAAf,EAAI,OAEN,OAAO,GAAiB,EAAI,EAAI,EAAY,EAAS,GAEvD,MAAM,CACR,GACF,GACF,CAEA,MAAM,GACJ,WAAA,CAAY,EAAK,EAAQ,EAAI,EAAa,GACxC,KAAK,IAAM,EACX,KAAK,OAAS,EACd,KAAK,GAAK,EACV,KAAK,YAAc,EACnB,KAAK,KAAO,GAAQ,CAAC,CACvB,CAEA,eAAA,CAAgB,EAAY,GAC1B,IAAI,EAAO,KACX,OAAO,KAAK,aAAa,EAAY,GAAS,MAAK,WACjD,OAAO,EAAK,aAAa,EAAY,EACvC,GACF,CAEA,YAAA,CAAa,EAAY,GACvB,OAAI,KAAK,KAAK,sBACL,GAAiB,KAAK,OAAQ,KAAK,GAAI,EAC5C,EAAS,KAAK,aAET,QAAQ,SAAQ,EAE3B,CAEA,YAAA,CAAa,EAAY,GACvB,GAAI,KAAK,KAAK,sBAAuB,CACnC,IAAI,EAAO,KACX,OAAO,GAAiB,KAAK,IAAK,KAAK,GAAI,EACzC,EAAS,KAAK,aACb,OAAM,SAAU,GACf,GAAI,GAAiB,GAEnB,OADA,EAAK,KAAK,uBAAwB,GAC3B,EAET,MAAM,CACR,GACJ,CACE,OAAO,QAAQ,SAAQ,EAE3B,CAEA,aAAA,GACE,IAAI,EAAO,KAEX,OAAI,EAAK,MAAQ,EAAK,KAAK,wBAA0B,EAAK,KAAK,sBACtD,EAAK,IAAI,IAAI,EAAK,IAAI,MAAK,SAAU,GAC1C,OAAO,EAAU,UAAY,EAC/B,IAAG,OAAM,SAAU,GAEjB,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,OAAO,EACT,IAGK,EAAK,OAAO,IAAI,EAAK,IAAI,MAAK,SAAU,GAC7C,OAAI,EAAK,MAAQ,EAAK,KAAK,wBAA0B,EAAK,KAAK,sBACtD,EAAU,UAAY,GAGxB,EAAK,IAAI,IAAI,EAAK,IAAI,MAAK,SAAU,GAI1C,OAAI,EAAU,UAAY,EAAU,QAC3B,IAKP,EADE,EAAU,QACF,EAAU,QAAQ,WAElB,eAGG,GACN,GAAY,GAAS,EAAW,GAGlC,GAXP,IAAI,CAYN,IAAG,SAAU,GACX,GAAmB,MAAf,EAAI,QAAkB,EAAU,SAClC,OAAO,EAAK,IAAI,IAAI,CAClB,IAAK,EAAK,GACV,SAAU,KACT,MAAK,WACN,OAAO,EACT,IAAG,SAAU,GACX,OAAI,GAAiB,IACnB,EAAK,KAAK,uBAAwB,EAC3B,EAAU,UAGZ,EACT,IAEF,MAAM,CACR,GACF,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,OAAO,EACT,GACF,EAGF,IAAI,GAAc,CAChB,UAAa,SAAU,EAAW,GAEhC,OAAwD,IAApD,GAAQ,EAAU,SAAU,EAAU,UACjC,EAAU,SAGZ,CACT,EACA,EAAK,SAAU,EAAW,GAExB,OAQJ,SAAgC,EAAQ,GACtC,GAAI,EAAO,aAAe,EAAO,WAC/B,MAAO,CACL,SAAU,EAAO,SACjB,QAAS,EAAO,SAIpB,OAAO,GAA0B,EAAO,QAAS,EAAO,QAC1D,CAjBW,CAAuB,EAAW,GAAW,QACtD,GAkBF,SAAS,GAA0B,EAAe,GAGhD,IAAI,EAAI,EAAc,GAClB,EAAa,EAAc,MAAM,GACjC,EAAI,EAAc,GAClB,EAAa,EAAc,MAAM,GAErC,OAAK,GAA8B,IAAzB,EAAc,OASpB,GAFW,EAAE,WAEU,GAClB,CACL,SAAU,EAAE,SACZ,QAAS,GAKT,GADW,EAAE,WACU,GAClB,CACL,SAAU,EAAE,SACZ,QAAS,GAIN,GAA0B,EAAY,GAvBpC,CACL,SAAU,GACV,QAAS,GAsBf,CAEA,SAAS,GAAa,EAAW,GAC/B,IAAI,EAAQ,EAAQ,GAChB,EAAO,EAAQ,MAAM,GAEzB,SAAK,GAAgC,IAAnB,EAAQ,UAItB,IAAc,EAAM,YAIjB,GAAa,EAAW,GACjC,CAEA,SAAS,GAAiB,GACxB,MAA6B,iBAAf,EAAI,QAAwD,IAAjC,KAAK,MAAM,EAAI,OAAS,IACnE,CAEA,SAAS,GAAa,EAAK,EAAQ,EAAI,EAAa,GAClD,OAAM,gBAAgB,GAGf,GAFE,IAAI,GAAqB,EAAK,EAAQ,EAAI,EAAa,EAGlE,CAEA,IAAI,GAAoB,EAwCxB,SAAS,GAAsB,EAAK,EAAQ,GAC1C,IAAI,EAAS,EAAK,QAAU,EAAK,QAAQ,KAAK,IAAW,GACrD,EAAY,EAAK,OAAS,EAAK,OAAO,WAAa,GACnD,EAAc,GACd,EAAkB,GAClB,EAAW,GAiBf,OAZI,EAAK,WACP,EAAW,KAAK,UAAU,EAAK,WAG7B,EAAK,QAAU,EAAK,eACtB,EAAc,KAAK,UAxBvB,SAAmC,GACjC,OAAO,OAAO,KAAK,GAAa,KAAK,IAAS,QAAO,SAAU,EAAQ,GAErE,OADA,EAAO,GAAO,EAAY,GACnB,CACT,GAAG,CAAC,EACN,CAmBiC,CAA0B,EAAK,gBAG1D,EAAK,QAA0B,UAAhB,EAAK,SACtB,EAAiB,EAAK,KAAK,YAGtB,QAAQ,IAAI,CAAC,EAAI,KAAM,EAAO,OAAO,MAAK,SAAU,GACzD,IAAI,EAAY,EAAI,GAAK,EAAI,GAAK,EAAY,EAC5C,EAAc,EAAS,EACzB,OAAO,IAAI,SAAQ,SAAU,GAC3B,GAAU,EAAW,EACvB,GACF,IAAG,MAAK,SAAU,GAKhB,MAAO,WADP,EAAS,EAAO,QAAQ,MAAO,KAAK,QAAQ,MAAO,KAErD,GACF,CAEA,SAAS,GAAU,EAAK,EAAQ,EAAM,EAAa,GACjD,IACI,EAqBA,EACA,EAIA,EA3BA,EAAU,GAEV,EAAe,CACjB,IAAK,EACL,QAAS,GACT,KAAM,IAEJ,GAAoB,EACpB,GAAmB,EACnB,GAAuB,EAIvB,EAAmB,EACnB,EAAW,EACX,EAAa,EAAK,YAAc,EAAK,OAAQ,EAC7C,EAAa,EAAK,YAAc,IAChC,EAAgB,EAAK,eAAiB,GACtC,EAAQ,EAAK,OAAS,WACtB,GAAiB,EACjB,EAAU,EAAK,QACf,EAAW,EAAK,SAGhB,EAAc,GAEd,EAAU,KAGd,EAAS,GAAU,CACjB,IAAI,EACJ,YAAY,IAAI,MAAO,cACvB,UAAW,EACX,aAAc,EACd,mBAAoB,EACpB,OAAQ,IAGV,IAAI,EAAc,CAAC,EAGnB,SAAS,IACP,OAAI,EACK,QAAQ,UAEV,GAAsB,EAAK,EAAQ,GAAM,MAAK,SAAU,GAC7D,EAAQ,EAER,IAAI,EAAiB,CAAC,EAEpB,GADsB,IAApB,EAAK,WACU,CAAE,uBAAuB,EAAO,uBAAuB,GAC3C,WAApB,EAAK,WACG,CAAE,uBAAuB,EAAM,uBAAuB,GAC1C,WAApB,EAAK,WACG,CAAE,uBAAuB,EAAO,uBAAuB,GAEvD,CAAE,uBAAuB,EAAM,uBAAuB,GAGzE,EAAe,IAAI,GAAa,EAAK,EAAQ,EAAO,EAAa,EACnE,GACF,CAEA,SAAS,IAGP,GAFA,EAAc,GAEmB,IAA7B,EAAa,KAAK,OAAtB,CAGA,IAAI,EAAO,EAAa,KACpB,EAAW,CAAC,QAAS,EAAK,SAC9B,OAAO,EAAO,SAAS,CAAC,KAAM,EAAM,WAAW,GAAQ,GAAU,MAAK,SAAU,GAE9E,GAAI,EAAY,UAEd,MADA,IACM,IAAI,MAAM,aAKlB,IAAI,EAAa,OAAO,OAAO,MAC/B,EAAI,SAAQ,SAAU,GAChB,EAAI,QACN,EAAW,EAAI,IAAM,EAEzB,IAEA,IAAI,EAAW,OAAO,KAAK,GAAY,OACvC,EAAO,oBAAsB,EAC7B,EAAO,cAAgB,EAAK,OAAS,EAErC,EAAK,SAAQ,SAAU,GACrB,IAAI,EAAQ,EAAW,EAAI,KAC3B,GAAI,EAAO,CACT,EAAO,OAAO,KAAK,GAEnB,IAAI,GAAa,EAAM,MAAQ,IAAI,cACnC,GAAkB,iBAAd,GAA8C,cAAd,EAGlC,MAAM,EAFN,EAAY,KAAK,SAAU,EAAM,GAIrC,MACE,EAAY,KAAK,EAErB,GAEF,IAAG,SAAU,GAEX,MADA,EAAO,oBAAsB,EAAK,OAC5B,CACR,GA1CA,CA2CF,CAEA,SAAS,IACP,GAAI,EAAa,MACf,MAAM,IAAI,MAAM,qCAElB,EAAO,SAAW,EAAW,EAAa,IAC1C,IAAI,EAAY,EAAM,GA2BtB,OA1BI,EAAY,SACd,EAAU,KAAO,EAGmB,iBAAzB,EAAa,UACtB,EAAU,QAAU,EAAa,eAC1B,EAAa,SAEtB,EAAY,KAAK,SAAU,IAE7B,GAAoB,EAEpB,EAAI,OAAO,MAAK,SAAU,GACxB,IAAI,EAAO,EAAI,YAAY,IAAI,GAC/B,GAAK,GAAiB,EAAtB,CAIA,IAAI,EAAY,EAAK,iBAAmB,EACpC,EAAc,SAAS,EAAK,WAAY,IAAM,SAAS,EAAkB,IAC7E,EAAI,YAAY,OAAO,EAAQ,CAC7B,gBAAiB,EAAY,EAAa,QAAQ,OAClD,eANF,CAQF,IAEO,EAAa,gBAAgB,EAAa,IAC7C,GAAS,MAAK,WAIhB,GAHA,EAAY,KAAK,aAAc,CAAE,WAAc,EAAa,MAC5D,GAAoB,EAEhB,EAAY,UAEd,MADA,IACM,IAAI,MAAM,aAElB,OAAe,EACf,GACF,IAAG,OAAM,SAAU,GAEjB,MADA,EAAkB,GACZ,CACR,GACF,CA0BA,SAAS,IACP,OAAO,GAAQ,EAAK,EAAQ,EAAa,MAAO,GAAa,MAAK,SAAU,GAC1E,EAAa,OAAS,EAAI,GAC1B,EAAI,KAAK,SAAQ,SAAU,UAClB,EAAa,MAAM,EAAI,KAC9B,EAAO,YACP,EAAa,KAAK,KAAK,EACzB,GACF,GACF,CAEA,SAAS,IAnCT,IACM,EAmCA,EAAY,WAAa,IAGN,IAAnB,EAAQ,QAIZ,EAAe,EAAQ,QACvB,EAAY,KAAK,aAAc,CAAE,iBAAoB,EAAa,OA3C9D,EAAO,CAAC,EACZ,EAAa,QAAQ,SAAQ,SAAU,GACrC,EAAY,KAAK,aAAc,CAAE,UAAa,IAG5B,WAAd,EAAO,KAGX,EAAK,EAAO,IAAM,EAAO,QAAQ,KAAI,SAAU,GAC7C,OAAO,EAAE,GACX,IACF,IACO,EAAO,SAAS,GAAM,MAAK,SAAU,GAE1C,GAAI,EAAY,UAEd,MADA,IACM,IAAI,MAAM,aAGlB,EAAa,MAAQ,CACvB,KAyBG,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,OAAM,SAAU,GACf,EAAiB,yCAA0C,EAC7D,KAZA,GAAoB,GAaxB,CAGA,SAAS,EAAoB,GACS,IAAhC,EAAa,QAAQ,QAavB,GACA,GACA,EAAa,QAAQ,QAAU,KAE/B,EAAQ,KAAK,GACb,EAAe,CACb,IAAK,EACL,QAAS,GACT,KAAM,IAEkB,YAAtB,EAAY,OAA6C,YAAtB,EAAY,QACjD,EAAY,MAAQ,SACpB,EAAY,KAAK,WAEnB,KA1BuB,IAAnB,EAAQ,QAAiB,KACtB,GAAc,EAAY,MAAS,KACtC,EAAY,MAAQ,UACpB,EAAY,KAAK,WAEf,GACF,IAsBR,CAGA,SAAS,EAAiB,EAAQ,GAC5B,IAGC,EAAI,UACP,EAAI,QAAU,GAEhB,EAAO,IAAK,EACZ,EAAO,OAAS,WAChB,EAAU,GACV,EAAe,CACb,IAAK,EACL,QAAS,GACT,KAAM,IAER,EAAoB,GACtB,CAGA,SAAS,EAAoB,GAC3B,KAAI,GAIA,EAAY,YACd,EAAO,OAAS,YACZ,IAWN,GAPA,EAAO,OAAS,EAAO,QAAU,WACjC,EAAO,UAAW,IAAI,MAAO,cAC7B,EAAO,SAAW,EAClB,GAAuB,EAEvB,EAAI,YAAY,OAAO,EAAQ,GAE3B,EAAY,EAEd,EAAa,GAAY,IACd,OAAS,EAGpB,IAAI,GAAa,EAAW,MAAQ,IAAI,cACtB,iBAAd,GAA8C,cAAd,GAClC,EAAY,KAAK,QAAS,GAC1B,EAAY,sBArXpB,SAAiB,EAAM,EAAa,EAAO,GACzC,IAAmB,IAAf,EAAK,MAGP,OAFA,EAAY,KAAK,QAAS,QAC1B,EAAY,qBAQd,GAJsC,mBAA3B,EAAK,oBACd,EAAK,kBAAoB,GAE3B,EAAY,KAAK,eAAgB,GACP,WAAtB,EAAY,OAA4C,YAAtB,EAAY,MAAqB,CACrE,EAAY,KAAK,SAAU,GAC3B,EAAY,MAAQ,UACpB,IAAI,EAAa,WACf,EAAK,iBAAmB,EAC1B,EAIA,EAAY,KAAK,UAHS,WACxB,EAAY,eAAe,SAAU,EACvC,IAEA,EAAY,KAAK,SAAU,EAC7B,CAEA,EAAK,iBAAmB,EAAK,kBAAoB,GACjD,EAAK,iBAAmB,EAAK,kBAAkB,EAAK,kBACpD,WAAW,EAAU,EAAK,iBAC5B,CA4VQ,CAAQ,EAAM,EAAa,GAAY,WACrC,GAAU,EAAK,EAAQ,EAAM,EAC/B,GAEJ,MACE,EAAY,KAAK,WAAY,GAC7B,EAAY,oBAEhB,CAEA,SAAS,EAAS,EAAQ,EAAS,GAEjC,GAAI,EAAY,UACd,OAAO,IAST,GALuB,iBAAZ,IACT,EAAa,QAAU,GAGZ,GAAa,EAAb,CAAmB,GAWhC,EAAa,IAAM,EAAO,KAAO,EACjC,EAAa,QAAQ,KAAK,GAC1B,EAAY,KAAK,aAAc,CAAE,cAAiB,EAAa,MAC/D,KAAU,WACR,EAAuC,IAAnB,EAAQ,QAAgB,EAAY,KAC1D,QAfA,CAEE,IAAI,EAAO,EAAI,YAAY,IAAI,GAC/B,GAAI,EAAM,CAER,IAAI,EAAY,EAAK,iBAAmB,EACxC,EAAI,YAAY,OAAO,EAAQ,CAAC,kBAAmB,GACrD,CAEF,CAOF,CAGA,SAAS,EAAkB,GAGzB,GAFA,GAAiB,EAEb,EAAY,UACd,OAAO,IAKT,GAAI,EAAQ,QAAQ,OAAS,EAC3B,EAAY,MAAQ,EAAQ,QAAQ,EAAQ,QAAQ,OAAS,GAAG,IAChE,IACA,GAAoB,OACf,CAEL,IAAI,EAAW,WACT,GACF,EAAY,MAAO,EACnB,KAEA,GAAmB,EAErB,GAAoB,EACtB,EAGK,GAA2C,IAA3B,EAAQ,QAAQ,OAenC,KAdA,GAAoB,EACpB,EAAa,gBAAgB,EAAQ,SACjC,GAAS,MAAK,WAGhB,GAFA,GAAoB,EACpB,EAAO,SAAW,EAAW,EAAQ,SACjC,EAAY,UAEd,MADA,IACM,IAAI,MAAM,aAEhB,GAEJ,IACC,MAAM,GAIX,CACF,CAGA,SAAS,EAAe,GAGtB,GAFA,GAAiB,EAEb,EAAY,UACd,OAAO,IAET,EAAiB,mBAAoB,EACvC,CAGA,SAAS,IACP,IACG,IACA,GACD,EAAQ,OAAS,EAHnB,CAOA,GAAiB,EAQb,EAAY,WACd,EAAY,eAAe,SAAU,EAAY,eACjD,EAAY,SAAS,UAEvB,EAAY,KAAK,SAAU,GAE3B,IAAI,EAAU,EAAI,QAAQ,GACvB,GAAG,SAAU,GAChB,EAAQ,KAAK,EAAgB,GAC7B,EAAQ,KAAK,GACV,MAAM,GAEL,EAAK,QAEP,EAAY,SAAW,EACvB,EAAY,cAAgB,EAxB9B,CAEA,SAAS,IACP,EAAQ,QACV,CACA,SAAS,IACP,EAAY,eAAe,SAAU,EACvC,CAmBF,CAEA,SAAS,EAAW,GAClB,OAAO,EAAI,OAAO,MAAK,SAAU,GAC/B,IAAI,OAAoC,IAAf,EAAK,MAC5B,SAAS,EAAK,WAAY,IAAM,SAAS,EAAY,IACrD,SAAS,EAAK,WAAY,IAO5B,OALA,EAAS,EAAI,YAAY,IAAI,CAC3B,KAAM,GAAG,EAAa,cAAgB,sBAAsB,EAAK,UACjE,gBAGK,CACT,GACF,CAEA,SAAS,IACP,IAAmB,MAAK,WAEtB,IAAI,EAAY,UAIhB,OAAO,EAAa,gBAAgB,KAAK,GAAY,MAAK,SAAU,GAElE,EAAmB,EACnB,EAAc,CACZ,MAHF,EAAW,EAIT,MAAO,EACP,WAAY,EACZ,MAAO,EACP,QAAS,EACT,SAAU,EACV,aAAa,GAEX,EAAK,SACoB,iBAAhB,EAAK,OAEd,EAAY,cAAe,EAE3B,EAAY,OAAS,EAAK,QAG1B,cAAe,IACjB,EAAY,UAAY,EAAK,WAE3B,YAAa,IACf,EAAY,QAAU,EAAK,SAEzB,EAAK,eACP,EAAY,aAAe,EAAK,cAE9B,EAAK,OACP,EAAY,KAAO,EAAK,MAE1B,GACF,IApCE,GAqCJ,IAAG,OAAM,SAAU,GACjB,EAAiB,+BAAgC,EACnD,GACF,CAGA,SAAS,EAAkB,GACzB,GAAoB,EACpB,EAAiB,uCAAwC,EAC3D,CA1cA,EAAY,MAAM,EAAK,GA6cnB,EAAY,UACd,KAIG,EAAY,kBACf,EAAY,KAAK,SAAU,GAEE,mBAAlB,EAAK,WACd,EAAY,KAAK,QAAS,EAAK,UAC/B,EAAY,KAAK,YAAY,SAAU,GACrC,EAAK,SAAS,KAAM,EACtB,KAEF,EAAY,iBAAkB,QAGN,IAAf,EAAK,MACd,IAEA,IAAmB,MAAK,WAEtB,OADA,GAAoB,EACb,EAAa,gBAAgB,EAAK,MAAO,EAClD,IAAG,MAAK,WACN,GAAoB,EAEhB,EAAY,UACd,KAGF,EAAW,EAAK,MAChB,IACF,IAAG,MAAM,GAEb,CAIA,MAAM,WAAoB,KACxB,WAAA,GACE,QACA,KAAK,WAAY,EACjB,KAAK,MAAQ,UACb,MAAM,EAAU,IAAI,SAAQ,CAAC,EAAS,KACpC,KAAK,KAAK,WAAY,GACtB,KAAK,KAAK,QAAS,EAAO,IAE5B,KAAK,KAAO,SAAU,EAAS,GAC7B,OAAO,EAAQ,KAAK,EAAS,EAC/B,EACA,KAAK,MAAQ,SAAU,GACrB,OAAO,EAAQ,MAAM,EACvB,EAGA,KAAK,OAAM,WAAa,GAC1B,CAEA,MAAA,GACE,KAAK,WAAY,EACjB,KAAK,MAAQ,YACb,KAAK,KAAK,SACZ,CAEA,KAAA,CAAM,EAAK,GACT,GAAI,KAAK,aACP,OAEF,KAAK,cAAe,EAEpB,MAAM,EAAY,KAChB,KAAK,QAAQ,EAIf,SAAS,IACP,EAAI,eAAe,YAAa,GAChC,EAAO,eAAe,YAAa,EACrC,CALA,EAAI,KAAK,YAAa,GACtB,EAAO,KAAK,YAAa,GAKzB,KAAK,KAAK,WAAY,GACtB,KAAK,KAAK,QAAS,EACrB,EAGF,SAAS,GAAQ,EAAI,GACnB,IAAI,EAAmB,EAAK,iBAC5B,MAAkB,iBAAP,EACF,IAAI,EAAiB,EAAI,GAEzB,CAEX,CAEA,SAAS,GAAiB,EAAK,EAAQ,EAAM,GAU3C,GARoB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,QAEU,IAAT,IACT,EAAO,CAAC,GAGN,EAAK,UAAY,MAAM,QAAQ,EAAK,SACtC,MAAM,GAAY,GACC,6CAGrB,EAAK,SAAW,GAChB,EAAO,EAAM,IACR,WAAa,EAAK,YAAc,EAAK,KAC1C,EAAK,MAAS,UAAW,GAAQ,EAAK,MAEtC,EAAK,iBAAmB,EAAK,kBAAoB,KACjD,IAAI,EAAe,IAAI,GAAY,GAInC,OADA,GAFe,GAAQ,EAAK,GACV,GAAQ,EAAQ,GACD,EAAM,GAChC,CACT,CAEA,SAAS,GAAK,EAAK,EAAQ,EAAM,GAa/B,MAZoB,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,QAEU,IAAT,IACT,EAAO,CAAC,IAEV,EAAO,EAAM,IAER,iBAAmB,EAAK,kBAAoB,KACjD,EAAM,GAAQ,EAAK,GACnB,EAAS,GAAQ,EAAQ,GAClB,IAAI,GAAK,EAAK,EAAQ,EAAM,EACrC,CAEA,MAAM,WAAa,KACjB,WAAA,CAAY,EAAK,EAAQ,EAAM,GAC7B,QACA,KAAK,UAAW,EAEhB,MAAM,EAAW,EAAK,KAAO,EAAsB,CAAC,EAAG,EAAM,EAAK,MAAQ,EACpE,EAAW,EAAK,KAAO,EAAsB,CAAC,EAAG,EAAM,EAAK,MAAQ,EAE1E,KAAK,KAAO,GAAiB,EAAK,EAAQ,GAC1C,KAAK,KAAO,GAAiB,EAAQ,EAAK,GAE1C,KAAK,YAAa,EAClB,KAAK,YAAa,EAElB,MAAM,EAAc,IAClB,KAAK,KAAK,SAAU,CAClB,UAAW,OACX,OAAQ,GACR,EAEE,EAAc,IAClB,KAAK,KAAK,SAAU,CAClB,UAAW,OACX,OAAQ,GACR,EAEE,EAAc,IAClB,KAAK,KAAK,SAAU,CAClB,UAAW,OACX,IAAK,GACL,EAEE,EAAc,IAClB,KAAK,KAAK,SAAU,CAClB,UAAW,OACX,IAAK,GACL,EAEE,EAAa,KACjB,KAAK,YAAa,EAEd,KAAK,YACP,KAAK,KAAK,SACZ,EAEI,EAAa,KACjB,KAAK,YAAa,EAEd,KAAK,YACP,KAAK,KAAK,SACZ,EAEI,EAAa,KACjB,KAAK,YAAa,EAEd,KAAK,YACP,KAAK,KAAK,SAAU,CAClB,UAAW,QAEf,EAEI,EAAa,KACjB,KAAK,YAAa,EAEd,KAAK,YACP,KAAK,KAAK,SAAU,CAClB,UAAW,QAEf,EAGF,IAAI,EAAU,CAAC,EAEf,MAAM,EAAa,GACV,CAAC,EAAO,MACc,WAAV,IACd,IAAS,GAAc,IAAS,IACR,WAAV,IACd,IAAS,GAAc,IAAS,IACR,WAAV,IACd,IAAS,GAAc,IAAS,IACR,WAAV,IACd,IAAS,GAAc,IAAS,MAG3B,KAAS,IACb,EAAQ,GAAS,CAAC,GAEpB,EAAQ,GAAO,IAAQ,EACoB,IAAvC,OAAO,KAAK,EAAQ,IAAQ,QAE9B,KAAK,mBAAmB,GAE5B,EASJ,SAAS,EAAe,EAAI,EAAO,IACa,GAA1C,EAAG,UAAU,GAAO,QAAQ,IAC9B,EAAG,GAAG,EAAO,EAEjB,CATI,EAAK,OACP,KAAK,KAAK,GAAG,WAAY,KAAK,KAAK,OAAO,KAAK,KAAK,OACpD,KAAK,KAAK,GAAG,WAAY,KAAK,KAAK,OAAO,KAAK,KAAK,QAStD,KAAK,GAAG,eAAe,SAAU,GACjB,WAAV,GACF,EAAe,KAAK,KAAM,SAAU,GACpC,EAAe,KAAK,KAAM,SAAU,IACjB,WAAV,GACT,EAAe,KAAK,KAAM,SAAU,GACpC,EAAe,KAAK,KAAM,SAAU,IACjB,WAAV,GACT,EAAe,KAAK,KAAM,SAAU,GACpC,EAAe,KAAK,KAAM,SAAU,IACjB,WAAV,IACT,EAAe,KAAK,KAAM,SAAU,GACpC,EAAe,KAAK,KAAM,SAAU,GAExC,IAEA,KAAK,GAAG,kBAAkB,SAAU,GACpB,WAAV,GACF,KAAK,KAAK,eAAe,SAAU,GACnC,KAAK,KAAK,eAAe,SAAU,IAChB,WAAV,GACT,KAAK,KAAK,eAAe,SAAU,GACnC,KAAK,KAAK,eAAe,SAAU,IAChB,WAAV,GACT,KAAK,KAAK,eAAe,SAAU,GACnC,KAAK,KAAK,eAAe,SAAU,IAChB,WAAV,IACT,KAAK,KAAK,eAAe,SAAU,GACnC,KAAK,KAAK,eAAe,SAAU,GAEvC,IAEA,KAAK,KAAK,GAAG,iBAAkB,EAAU,SACzC,KAAK,KAAK,GAAG,iBAAkB,EAAU,SAEzC,MAAM,EAAU,QAAQ,IAAI,CAC1B,KAAK,KACL,KAAK,OACJ,MAAM,IACP,MAAM,EAAM,CACV,KAAM,EAAK,GACX,KAAM,EAAK,IAOb,OALA,KAAK,KAAK,WAAY,GAClB,GACF,EAAS,KAAM,GAEjB,KAAK,qBACE,CAAG,IACR,IAaF,GAZA,KAAK,SACD,EAGF,EAAS,GAKT,KAAK,KAAK,QAAS,GAErB,KAAK,qBACD,EAEF,MAAM,CACR,IAGF,KAAK,KAAO,SAAU,EAAS,GAC7B,OAAO,EAAQ,KAAK,EAAS,EAC/B,EAEA,KAAK,MAAQ,SAAU,GACrB,OAAO,EAAQ,MAAM,EACvB,CACF,CAEA,MAAA,GACO,KAAK,WACR,KAAK,UAAW,EAChB,KAAK,KAAK,SACV,KAAK,KAAK,SAEd,EA6BF,GAAQ,QA52HR,SAAmB,GACjB,EAAQ,QAAQ,MAAO,IAAU,EACnC,IA22HG,QAzuFH,SAAsB,GACpB,EAAQ,QAAQ,OAAQ,IAAW,GACnC,EAAQ,QAAQ,QAAS,IAAW,EACtC,IAuuFG,OAAO,IACP,QA7BH,SAAqB,GACnB,EAAQ,UAAY,GACpB,EAAQ,KAAO,GAEf,OAAO,eAAe,EAAQ,UAAW,YAAa,CACpD,IAAK,WACH,IAAI,EAAO,KAWX,YAVqC,IAA1B,KAAK,mBACd,KAAK,iBAAmB,CACtB,KAAM,SAAU,EAAO,EAAM,GAC3B,OAAO,EAAK,YAAY,UAAU,EAAO,EAAM,EAAM,EACvD,EACA,GAAI,SAAU,EAAO,EAAM,GACzB,OAAO,EAAK,YAAY,UAAU,EAAM,EAAO,EAAM,EACvD,IAGG,KAAK,gBACd,IAGF,EAAQ,UAAU,KAAO,SAAU,EAAQ,EAAM,GAC/C,OAAO,KAAK,YAAY,KAAK,KAAM,EAAQ,EAAM,EACnD,CACF,IAOA,YCx/UA,MAAM,WAAmB,MACvB,WAAA,CAAY,EAAQ,EAAO,GACzB,QACA,KAAK,OAAS,EACd,KAAK,KAAO,EACZ,KAAK,QAAU,EACf,KAAK,OAAQ,CACf,CAEA,QAAA,GACE,OAAO,KAAK,UAAU,CACpB,OAAQ,KAAK,OACb,KAAM,KAAK,KACX,QAAS,KAAK,QACd,OAAQ,KAAK,QAEjB,EAGiB,IAAI,GAAW,IAAK,eAAgB,kCAC/B,IAAI,GAAW,IAAK,cAAe,+BACzC,IAAI,GAAW,IAAK,YAAa,WAChC,IAAI,GAAW,IAAK,WAAY,4BAClC,IAAI,GAAW,IAAK,cAAe,mCACnC,IAAI,GAAW,IAAK,aAAc,4BACjC,IAAI,GAAW,IAAK,cAAe,yDACtC,IAAI,GAAW,IAAK,sBAAuB,qBAP1D,IAQI,GAAgB,IAAI,GAAW,IAAK,gBAAiB,yCAC3C,IAAI,GAAW,IAAK,SAAU,kCACtB,IAAI,GAAW,IAAK,kBAAmB,uBACrC,IAAI,GAAW,IAAK,oBAAqB,mCAC5C,IAAI,GAAW,IAAK,iBAAkB,+BACzC,IAAI,GAAW,IAAK,cAAe,oCACjC,IAAI,GAAW,IAAK,cAAe,kCACtC,IAAI,GAAW,IAAK,YAAa,sBAClC,IAAI,GAAW,IAAK,sBAAuB,WAC3C,IAAI,GAAW,IAAK,mBAAoB,WACxC,IAAI,GAAW,IAAK,wBAAyB,WAC7C,IAAI,GAAW,IAAK,YAAa,wDAC/B,IAAI,GAAW,IAAK,cAAe,sBACnC,IAAI,GAAW,IAAK,cAAe,+DAClC,IAAI,GAAW,IAAK,eAAgB,+CACrC,IAAI,GAAW,IAAK,cAAe,2BA2BrD,SAAS,GAA0B,GAEjC,GAAmB,iBAAR,EAAkB,CAC3B,IAAI,EAAO,GACX,EAAM,IACF,KAAO,CACb,CAuBA,MArBI,UAAW,GAAqB,aAAd,EAAI,QACxB,EAAI,KAAO,WACX,EAAI,OAAS,KAGT,SAAU,IACd,EAAI,KAAO,EAAI,OAAS,WAGpB,WAAY,IAChB,EAAI,OAAS,KAGT,YAAa,IACjB,EAAI,QAAU,EAAI,SAAW,EAAI,QAG7B,UAAW,IACf,EAAI,OAAQ,IAAK,OAAS,OAGrB,CACT,CCjGoC,oBAApB,iBACV,gBADN,ICoFI,GACA,GDhFA,GAAI,QCPR,SAAS,GAAO,GACd,MAAO,IAAM,CACf,CACA,SAAS,GAAS,GAChB,OAAO,EAAI,UAAU,EACvB,CACA,SAAS,KACP,KAAK,OAAS,CAAC,CACjB,CAsCA,SAAS,GAAM,GAIb,GAHA,KAAK,OAAS,IAAI,GAGd,GAAS,MAAM,QAAQ,GACzB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAM,OAAQ,EAAI,EAAK,IAC3C,KAAK,IAAI,EAAM,GAGrB,CA9CA,GAAM,UAAU,IAAM,SAAU,GAC9B,IAAI,EAAU,GAAO,GACrB,OAAO,KAAK,OAAO,EACrB,EACA,GAAM,UAAU,IAAM,SAAU,EAAK,GACnC,IAAI,EAAU,GAAO,GAErB,OADA,KAAK,OAAO,GAAW,GAChB,CACT,EACA,GAAM,UAAU,IAAM,SAAU,GAE9B,OADc,GAAO,KACH,KAAK,MACzB,EACA,GAAM,UAAU,KAAO,WACrB,OAAO,OAAO,KAAK,KAAK,QAAQ,KAAI,GAAK,GAAS,IACpD,EACA,GAAM,UAAU,OAAS,SAAU,GACjC,IAAI,EAAU,GAAO,GACjB,EAAM,KAAW,KAAK,OAE1B,cADO,KAAK,OAAO,GACZ,CACT,EACA,GAAM,UAAU,QAAU,SAAU,GAElC,IADA,IAAI,EAAO,OAAO,KAAK,KAAK,QACnB,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CAC/C,IAAI,EAAM,EAAK,GAGf,EAFY,KAAK,OAAO,GACxB,EAAM,GAAS,GAEjB,CACF,EACA,OAAO,eAAe,GAAM,UAAW,OAAQ,CAC7C,IAAK,WACH,OAAO,OAAO,KAAK,KAAK,QAAQ,MAClC,IAaF,GAAM,UAAU,IAAM,SAAU,GAC9B,OAAO,KAAK,OAAO,IAAI,GAAK,EAC9B,EACA,GAAM,UAAU,IAAM,SAAU,GAC9B,OAAO,KAAK,OAAO,IAAI,EACzB,EACA,GAAM,UAAU,QAAU,SAAU,GAClC,KAAK,OAAO,SAAQ,SAAU,EAAO,GACnC,EAAG,EACL,GACF,EACA,OAAO,eAAe,GAAM,UAAW,OAAQ,CAC7C,IAAK,WACH,OAAO,KAAK,OAAO,IACrB,KAMF,WACE,GAAsB,oBAAX,QAAyC,oBAAR,KAAsC,oBAAR,IACxE,OAAO,EAET,IAAI,EAAO,OAAO,yBAAyB,IAAK,OAAO,SACvD,OAAO,GAAQ,QAAS,GAAQ,IAAI,OAAO,WAAa,GAC1D,CAQM,IAIF,GAAc,GACd,GAAc,KAJd,GAAc,IACd,GAAc,KC5FlB,IAAI,GAAW,SAAU,GACvB,OAAO,KAAK,EACd,EAiCA,SAAS,GAA0B,GAIjC,IAHA,IAAI,EAAS,EAAI,OACb,EAAM,IAAI,YAAY,GACtB,EAAM,IAAI,WAAW,GAChB,EAAI,EAAG,EAAI,EAAQ,IAC1B,EAAI,GAAK,EAAI,WAAW,GAE1B,OAAO,CACT,CAEA,SAAS,GAAmB,EAAW,GACrC,OAnCF,SAAoB,EAAO,GAEzB,EAAQ,GAAS,GACjB,EAAa,GAAc,CAAC,EAC5B,IACE,OAAO,IAAI,KAAK,EAAO,EACzB,CAAE,MAAO,GACP,GAAe,cAAX,EAAE,KACJ,MAAM,EAOR,IALA,IAII,EAAU,IAJuB,oBAAhB,YAA8B,YACZ,oBAAlB,cAAgC,cACb,oBAAnB,eAAiC,eACxC,mBAEL,EAAI,EAAG,EAAI,EAAM,OAAQ,GAAK,EACrC,EAAQ,OAAO,EAAM,IAEvB,OAAO,EAAQ,QAAQ,EAAW,KACpC,CACF,CAeS,CAAW,CAAC,GAA0B,IAAa,CAAC,KAAM,GACnE,CChCA,IAAI,IAAiB,IACjB,GAAmB,EACnB,GAAM,GAEV,SAAS,GAAQ,EAAG,GAElB,GAAI,IAAM,EACR,OAAO,EAGT,EAAI,GAAa,GACjB,EAAI,GAAa,GAEjB,IAAI,EAAK,GAAe,GACpB,EAAK,GAAe,GACxB,GAAK,EAAK,GAAQ,EAChB,OAAO,EAAK,EAEd,cAAe,GACb,IAAK,SACH,OAAO,EAAI,EACb,IAAK,UACH,OAAO,EAAI,GAAK,EAAI,EACtB,IAAK,SACH,OAsPN,SAAuB,EAAG,GAIxB,OAAQ,IAAM,EAAK,EAAM,EAAI,EAAK,GAAK,CACzC,CA3Pa,CAAc,EAAG,GAE5B,OAAO,MAAM,QAAQ,GAyOvB,SAAsB,EAAG,GAEvB,IADA,IAAI,EAAM,KAAK,IAAI,EAAE,OAAQ,EAAE,QACtB,EAAI,EAAG,EAAI,EAAK,IAAK,CAC5B,IAAI,EAAO,GAAQ,EAAE,GAAI,EAAE,IAC3B,GAAa,IAAT,EACF,OAAO,CAEX,CACA,OAAQ,EAAE,SAAW,EAAE,OAAU,EAC9B,EAAE,OAAS,EAAE,OAAU,GAAK,CACjC,CAnP4B,CAAa,EAAG,GA0P5C,SAAuB,EAAG,GAGxB,IAFA,IAAI,EAAK,OAAO,KAAK,GAAI,EAAK,OAAO,KAAK,GACtC,EAAM,KAAK,IAAI,EAAG,OAAQ,EAAG,QACxB,EAAI,EAAG,EAAI,EAAK,IAAK,CAE5B,IAAI,EAAO,GAAQ,EAAG,GAAI,EAAG,IAC7B,GAAa,IAAT,EACF,OAAO,EAIT,GAAa,KADb,EAAO,GAAQ,EAAE,EAAG,IAAK,EAAE,EAAG,MAE5B,OAAO,CAGX,CACA,OAAQ,EAAG,SAAW,EAAG,OAAU,EAChC,EAAG,OAAS,EAAG,OAAU,GAAK,CACnC,CA5QiD,CAAc,EAAG,EAClE,CAIA,SAAS,GAAa,GACpB,cAAe,GACb,IAAK,YACH,OAAO,KACT,IAAK,SACH,OAAI,IAAQ,KAAY,KAAS,KAAY,MAAM,GAC1C,KAEF,EACT,IAAK,SACH,IAAI,EAAU,EACd,GAAI,MAAM,QAAQ,GAAM,CACtB,IAAI,EAAM,EAAI,OACd,EAAM,IAAI,MAAM,GAChB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IACvB,EAAI,GAAK,GAAa,EAAQ,GAGlC,KAAO,IAAI,aAAe,KACxB,OAAO,EAAI,SACN,GAAY,OAAR,EAET,IAAK,IAAI,KADT,EAAM,CAAC,EACO,EACZ,GAAI,OAAO,UAAU,eAAe,KAAK,EAAS,GAAI,CACpD,IAAI,EAAM,EAAQ,QACC,IAAR,IACT,EAAI,GAAK,GAAa,GAE1B,CAEJ,EAEJ,OAAO,CACT,CAEA,SAAS,GAAS,GAChB,GAAY,OAAR,EACF,cAAe,GACb,IAAK,UACH,OAAO,EAAM,EAAI,EACnB,IAAK,SACH,OA2PR,SAA8B,GAE5B,GAAY,IAAR,EACF,MAAO,IAKT,IAAI,EAAY,EAAI,gBAAgB,MAAM,QACtC,EAAY,SAAS,EAAU,GAAI,IAEnC,EAAM,EAAM,EAEZ,EAAS,EAAM,IAAM,IAKrB,GA1VW,IAyVU,GAAO,EAAY,GAAa,IACd,WA1VvB,EA0VmC,IA1V1B,EA0V+B,GApW9D,SAAa,EAAK,EAAS,GAIzB,IAHA,IAAI,EAAU,GACV,EAAe,EAAa,EAAI,OAE7B,EAAQ,OAAS,GACtB,GAAW,EAEb,OAAO,CACT,CAGgB,CAAI,EAAK,EAAS,GACf,GAFnB,IAAiB,EAAK,EAAS,EA4V7B,GAAU,GAAM,EAGhB,IAAI,EAAS,KAAK,IAAI,WAAW,EAAU,KAEvC,IACF,EAAS,GAAK,GAGhB,IAAI,EAAY,EAAO,QAAQ,IAO/B,OAJA,EAAY,EAAU,QAAQ,SAAU,IAExC,GAAU,GAAM,EAET,CACT,CAhSe,CAAqB,GAC9B,IAAK,SAOH,OAAO,EACJ,QAAQ,UAAW,MACnB,QAAQ,UAAW,MACnB,QAAQ,UAAW,MAExB,IAAK,SACH,IAAI,EAAU,MAAM,QAAQ,GACxB,EAAM,EAAU,EAAM,OAAO,KAAK,GAClC,GAAK,EACL,EAAM,EAAI,OACV,EAAS,GACb,GAAI,EACF,OAAS,EAAI,GACX,GAAU,GAAkB,EAAI,SAGlC,OAAS,EAAI,GAAK,CAChB,IAAI,EAAS,EAAI,GACjB,GAAU,GAAkB,GACxB,GAAkB,EAAI,GAC5B,CAEF,OAAO,EAGb,MAAO,EACT,CAKA,SAAS,GAAkB,GAGzB,OAAO,GADP,EAAM,GAAa,IACU,GAAM,GAAS,GAFjC,IAGb,CAEA,SAAS,GAAY,EAAK,GACxB,IACI,EADA,EAAc,EAGlB,GADsB,MAAX,EAAI,GAEb,EAAM,EACN,QACK,CACL,IAAI,EAAiB,MAAX,EAAI,GACd,IACA,IAAI,EAAc,GACd,EAAc,EAAI,UAAU,EAAG,EAAI,IACnC,EAAY,SAAS,EAAa,IAAM,GAM5C,IAJI,IACF,GAAa,GAEf,GAAK,KACQ,CACX,IAAI,EAAK,EAAI,GACb,GAAW,OAAP,EACF,MAEA,GAAe,EAEjB,GACF,CAGE,EADyB,KAD3B,EAAc,EAAY,MAAM,MAChB,OACR,SAAS,EAAa,IAGtB,WAAW,EAAY,GAAK,IAAM,EAAY,IAGlD,IACF,GAAY,IAGI,IAAd,IAIF,EAAM,WAAW,EAAM,IAAM,GAEjC,CACA,MAAO,CAAC,IAAK,EAAK,OAAS,EAAI,EACjC,CAIA,SAAS,GAAI,EAAO,GAClB,IAAI,EAAM,EAAM,MAEhB,GAAI,EAAU,OAAQ,CACpB,IAAI,EAAkB,EAAU,EAAU,OAAS,GAC/C,IAAQ,EAAgB,UAE1B,EAAU,MACV,EAAkB,EAAU,EAAU,OAAS,IAEjD,IAAI,EAAU,EAAgB,QAC1B,EAAmB,EAAgB,MACvC,GAAI,MAAM,QAAQ,GAChB,EAAQ,KAAK,QACR,GAAI,IAAqB,EAAM,OAAS,EAAG,CAEhD,EADU,EAAM,OACD,CACjB,MACE,EAAM,KAAK,EAEf,CACF,CA8GA,SAAS,GAAe,GACtB,IACI,EADK,CAAC,UAAW,SAAU,SAAU,UAC5B,eAAe,GAE5B,OAAK,EACO,OAAN,EACK,EAEL,MAAM,QAAQ,GACT,EAEF,EAAM,EAAK,EAAM,EAAM,EAAM,EAGlC,MAAM,QAAQ,GACT,OADT,CAGF,CCxUuB,KAAK,cAAgB,KAAK,WAoEjD,SAAS,GAAU,GACjB,OAAO,SAAS,EAClB,CChDA,SAAS,GAAkB,GACzB,GAAI,aAAkB,YACpB,OAdJ,SAA0B,GACxB,GAA0B,mBAAf,EAAK,MACd,OAAO,EAAK,MAAM,GAGpB,IAAI,EAAS,IAAI,YAAY,EAAK,YAC9B,EAAc,IAAI,WAAW,GAC7B,EAAc,IAAI,WAAW,GAEjC,OADA,EAAY,IAAI,GACT,CACT,CAIW,CAAiB,GAE1B,IAAI,EAAO,EAAO,KACd,EAAO,EAAO,KAElB,MAA4B,mBAAjB,EAAO,MACT,EAAO,MAAM,EAAG,EAAM,GAGxB,EAAO,YAAY,EAAG,EAAM,EACrC,CAMA,IAAI,GAAe,SAAS,UAAU,SAClC,GAAmB,GAAa,KAAK,QAazC,SAAS,GAAM,GACb,IAAI,EACA,EACA,EAEJ,IAAK,GAA4B,iBAAX,EACpB,OAAO,EAGT,GAAI,MAAM,QAAQ,GAAS,CAEzB,IADA,EAAY,GACP,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IACxC,EAAU,GAAK,GAAM,EAAO,IAE9B,OAAO,CACT,CAIA,GAAI,aAAkB,MAAQ,SAAS,GACrC,OAAO,EAAO,cAGhB,GAxEF,SAAwB,GACtB,MAA+B,oBAAhB,aAA+B,aAAkB,aAC7C,oBAAT,MAAwB,aAAkB,IACtD,CAqEM,CAAe,GACjB,OAAO,GAAkB,GAG3B,IAtCF,SAAuB,GACrB,IAAI,EAAQ,OAAO,eAAe,GAElC,GAAc,OAAV,EACF,OAAO,EAET,IAAI,EAAO,EAAM,YACjB,MAAuB,mBAAR,GACb,aAAgB,GAAQ,GAAa,KAAK,IAAS,EACvD,CA6BO,CAAc,GACjB,OAAO,EAIT,IAAK,KADL,EAAY,CAAC,EACH,EAER,GAAI,OAAO,UAAU,eAAe,KAAK,EAAQ,GAAI,CACnD,IAAI,EAAQ,GAAM,EAAO,SACJ,IAAV,IACT,EAAU,GAAK,EAEnB,CAEF,OAAO,CACT,CAgBA,SAAS,GAAU,GAEjB,OAAO,YAAa,GAElB,EAAO,GAAM,GACb,IAAI,EAAO,KAEP,EAA2C,mBAA1B,EAAK,EAAK,OAAS,IAAqB,EAAK,MAC9D,EAAU,IAAI,SAAQ,SAAU,EAAS,GAC3C,IAAI,EAvBI,EACR,EAuBA,IACE,IAAI,GAzBE,EAyBc,SAAU,EAAK,GAC7B,EACF,EAAO,GAEP,EAAQ,EAEZ,EA9BF,GAAS,EACN,YAAa,GAElB,GAAI,EAEF,MAAM,IAAI,MAAM,8BAEhB,GAAS,EACT,EAAI,MAAM,KAAM,EAEpB,GAuBM,EAAK,KAAK,IACV,EAAO,EAAK,MAAM,EAAM,KACS,mBAAd,EAAK,MACtB,EAAQ,EAEZ,CAAE,MAAO,GACP,EAAO,EACT,CACF,IAOA,OALI,GACF,EAAQ,MAAK,SAAU,GACrB,EAAO,KAAM,EACf,GAAG,GAEE,CACT,CACF,CAkMA,IACE,aAAa,QAAQ,4BAA6B,KACrC,aAAa,QAAQ,4BACpC,CAAE,MAAO,IACI,CACb,CAmFA,SAAS,GAAe,GAEtB,GAAuB,oBAAZ,SAAsD,mBAApB,QAAQ,GACxC,MAAM,UAAU,MAAM,KAAK,UAAW,EAGrD,CA+DA,IAAI,GAzB2B,mBAAlB,OAAO,OACL,OAAO,OAIP,SAAU,GAGnB,IAFA,IAAI,EAAK,OAAO,GAEP,EAAQ,EAAG,EAAQ,UAAU,OAAQ,IAAS,CACrD,IAAI,EAAa,UAAU,GAE3B,GAAkB,MAAd,EACF,IAAK,IAAI,KAAW,EAEd,OAAO,UAAU,eAAe,KAAK,EAAY,KACnD,EAAG,GAAW,EAAW,GAIjC,CACA,OAAO,CACT,EAmDJ,SAAS,GAAQ,GAEf,IADA,IAAI,EAAM,GACD,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAC1C,EAAM,EAAI,OAAO,EAAK,IAExB,OAAO,CACT,CAoDA,SAAS,GAAS,GAChB,MAA0B,kBAAf,EAAG,QACL,EAAG,QAGW,mBAAZ,EAAG,OACZ,GAAe,OACb,8EAEmB,SAAd,EAAG,OAId,CAgFA,SAAS,GAAO,EAAI,EAAO,GACzB,OAAO,EAAG,IAAI,GACX,OAAM,SAAU,GAEf,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,MAAO,CAAC,CACV,IACC,MAAK,SAAU,GAEd,IAAI,EAAS,EAAI,KACb,EAAS,EAAQ,GAErB,OAAK,GAQL,EAAO,IAAM,EACb,EAAO,KAAO,EAKpB,SAAmB,EAAI,EAAK,GAC1B,OAAO,EAAG,IAAI,GAAK,MAAK,SAAU,GAChC,MAAO,CACL,SAAS,EACT,IAAK,EAAI,IAEb,IAAG,SAAU,GAEX,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,OAAO,GAAO,EAAI,EAAI,IAAK,EAC7B,GACF,CAjBa,CAAU,EAAI,EAAQ,IAPpB,CAAC,SAAS,EAAO,IAAK,EAQjC,GACJ,CCptBA,MAAM,WAAwB,MAC5B,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,oBACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,MAAM,WAAsB,MAC1B,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,YACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,MAAM,WAAqB,MACzB,WAAA,CAAY,GACV,QACA,KAAK,OAAS,IACd,KAAK,KAAO,gBACZ,KAAK,QAAU,EACf,KAAK,OAAQ,EACb,IACE,MAAM,kBAAkB,KAAM,GAChC,CAAE,MAAO,GAAI,CACf,EAGF,SAAS,GAAiB,EAAS,GAYjC,OAXI,GACF,EAAQ,MAAK,SAAU,GACrB,KAAS,WACP,EAAS,KAAM,EACjB,GACF,IAAG,SAAU,GACX,KAAS,WACP,EAAS,EACX,GACF,IAEK,CACT,CA0BA,SAAS,GAAc,EAAO,GAC5B,OAAO,WACL,IAAI,EAAO,UACP,EAAO,KACX,OAAO,EAAM,KAAI,WACf,OAAO,EAAe,MAAM,EAAM,EACpC,GACF,CACF,CAIA,SAAS,GAAK,GACZ,IAAI,EAAS,IAAI,GAAI,GACjB,EAAS,IAAI,MAAM,EAAO,MAC1B,GAAS,EAIb,OAHA,EAAO,SAAQ,SAAU,GACvB,IAAS,GAAS,CACpB,IACO,CACT,CAEA,SAAS,GAAe,GACtB,IAAI,EAAS,IAAI,MAAM,EAAI,MACvB,GAAS,EAIb,OAHA,EAAI,SAAQ,SAAU,EAAO,GAC3B,IAAS,GAAS,CACpB,IACO,CACT,CC/FA,MAAM,GACJ,WAAA,GACE,KAAK,QAAU,IAAI,SAAQ,SAAU,GAAU,GAAW,GAC5D,CAEA,GAAA,CAAI,GAMF,OALA,KAAK,QAAU,KAAK,QAAQ,OAAM,WAElC,IAAG,MAAK,WACN,OAAO,GACT,IACO,KAAK,OACd,CAEA,MAAA,GACE,OAAO,KAAK,OACd,EAGF,SAAS,GAAU,GACjB,IAAK,EACH,MAAO,YAIT,cAAe,GACb,IAAK,WAGL,IAAK,SAEH,OAAO,EAAM,WACf,QAEE,OAAO,KAAK,UAAU,GAE5B,CAQA,eAAe,GAAW,EAAU,EAAU,EAAQ,EAAW,EAAW,GAC1E,MAAM,EANR,SAA6B,EAAQ,GAEnC,OAAO,GAAU,GAAU,GAAU,GAAa,WACpD,CAGwB,CAAoB,EAAQ,GAElD,IAAI,EACJ,IAAK,IAEH,EAAc,EAAS,aAAe,EAAS,cAAgB,CAAC,EAC5D,EAAY,IACd,OAAO,EAAY,GAIvB,MAAM,EAAiB,EAAS,OAAO,MAAK,eAAgB,GAC1D,MAAM,EAAY,EAAK,QAAU,YAChC,EAAY,OAAS,GAAU,UAkB1B,GAAO,EAAU,UAAY,GAdnC,SAAsB,GACpB,EAAI,MAAQ,EAAI,OAAS,CAAC,EAC1B,IAAI,EAAe,GACgB,IAA/B,EAAa,QAAQ,OACvB,EAAe,EAAW,IAAM,GAElC,MAAM,EAAS,EAAI,MAAM,GAAgB,EAAI,MAAM,IAAiB,CAAC,EAErE,IAAI,EAAO,GAIX,OADA,EAAO,IAAa,EACb,CACT,IAEA,MACM,SADY,EAAS,0BAA0B,IACtC,GACf,EAAG,iBAAkB,EACrB,MAAM,EAAO,CACX,KAAM,EACN,GAAI,EACJ,SAAU,EACV,QAAS,EAAS,QAClB,OAAQ,EACR,UAAW,GAGb,IAAI,EACJ,IACE,QAAmB,EAAK,GAAG,IAAI,iBACjC,CAAE,MAAO,GAEP,GAAmB,MAAf,EAAI,OACN,MAAM,CAEV,CAQA,OANA,EAAK,IAAM,EAAa,EAAW,IAAM,EACrC,GACF,EAAK,GAAG,KAAK,aAAa,kBACjB,EAAY,EACrB,IAEK,CACT,IAKA,OAHI,IACF,EAAY,GAAiB,GAExB,CACT,CAEA,IAAI,GAAmB,CAAC,EACpB,GAAgB,IAAI,GAGxB,SAAS,GAAc,GAGrB,OAA8B,IAAvB,EAAK,QAAQ,KAAc,CAAC,EAAM,GAAQ,EAAK,MAAM,IAC9D,CAQA,SAAS,GAAU,EAAI,EAAG,GACxB,IACE,EAAG,KAAK,QAAS,EACnB,CAAE,MAAO,GACP,GAAe,QACb,qMAIF,GAAe,QAAS,EAAG,EAC7B,CACF,CA+hCA,SAngCA,SAAiC,EAAc,EAAQ,EAAS,GAE9D,SAAS,EAAO,EAAI,EAAK,GAGvB,IACE,EAAI,EACN,CAAE,MAAO,GACP,GAAU,EAAI,EAAG,CAAC,IAAK,EAAK,IAAK,GACnC,CACF,CAEA,SAAS,EAAU,EAAI,EAAK,EAAM,EAAQ,GAKxC,IACE,MAAO,CAAC,OAAS,EAAI,EAAM,EAAQ,GACrC,CAAE,MAAO,GAEP,OADA,GAAU,EAAI,EAAG,CAAC,IAAK,EAAK,KAAM,EAAM,OAAQ,EAAQ,SAAU,IAC3D,CAAC,MAAO,EACjB,CACF,CAEA,SAAS,EAAmB,EAAG,GAC7B,MAAM,EAAa,GAAQ,EAAE,IAAK,EAAE,KACpC,OAAsB,IAAf,EAAmB,EAAa,GAAQ,EAAE,MAAO,EAAE,MAC5D,CAEA,SAAS,EAAa,EAAS,EAAO,GAEpC,OADA,EAAO,GAAQ,EACM,iBAAV,EACF,EAAQ,MAAM,EAAM,EAAQ,GAC1B,EAAO,EACT,EAAQ,MAAM,GAEhB,CACT,CAEA,SAAS,EAAW,GAClB,MAAM,EAAM,EAAI,MAIhB,OADe,GAAsB,iBAAR,GAAoB,EAAI,KAAQ,EAAI,EAEnE,CAEA,SAAS,EAA8B,GACrC,EAAI,KAAK,SAAQ,SAAU,GACzB,MAAM,EAAO,EAAI,KAAO,EAAI,IAAI,aAC3B,GAGL,OAAO,KAAK,GAAM,SAAQ,SAAU,GAClC,MAAM,EAAM,EAAK,GL9LzB,IAAsB,EAAK,EK+LnB,EAAK,GAAU,ML/LD,EK+LmC,EAAI,KL/LlC,EK+LwC,EAAI,aL9L9D,GAAmB,GAAS,GAAM,GK+LrC,GACF,GACF,CAEA,SAAS,EAAuB,GAC9B,OAAO,SAAU,GAIf,OAHI,EAAK,cAAgB,EAAK,aAAe,EAAK,QAChD,EAA8B,GAEzB,CACT,CACF,CAEA,SAAS,EAAa,EAAW,EAAM,EAAQ,GAE7C,IAAI,EAAM,EAAK,QACI,IAAR,IACL,IACF,EAAM,mBAAmB,KAAK,UAAU,KAE1C,EAAO,KAAK,EAAY,IAAM,GAElC,CAEA,SAAS,EAAc,GACrB,QAAgC,IAArB,EAAkC,CAC3C,MAAM,EAAW,OAAO,GAExB,OAAK,MAAM,IAAa,IAAa,SAAS,EAAkB,IAGvD,EAFA,CAIX,CACF,CAoBA,SAAS,EAAqB,EAAS,GACrC,MAAM,EAAe,EAAQ,WAAa,SAAW,WAC/C,EAAa,EAAQ,WAAa,WAAa,SAErD,QAAqC,IAA1B,EAAQ,SACc,IAAxB,EAAQ,IACf,GAAQ,EAAQ,GAAe,EAAQ,IAAe,EACtD,MAAM,IAAI,GAAgB,mGAErB,GAAI,EAAI,SAA6B,IAAnB,EAAQ,OAAkB,CACjD,GAAI,EAAQ,aACV,MAAM,IAAI,GAAgB,6CACrB,GAAI,EAAQ,MAAQ,EAAQ,KAAK,OAAS,IAC9C,EAAQ,QAAU,EAAQ,YAC3B,MAAM,IAAI,GAAgB,4DAG9B,CACA,CAAC,cAAe,QAAS,QAAQ,SAAQ,SAAU,GACjD,MAAM,EA9BV,SAA8B,GAC5B,GAAI,EAAQ,CACV,GAAsB,iBAAX,EACT,OAAQ,IAAI,GAAgB,+BAA+B,MAE7D,GAAI,EAAS,EACX,OAAO,IAAI,GAAgB,wCAAwC,KAEvE,CACF,CAqBkB,CAAqB,EAAQ,IAC3C,GAAI,EACF,MAAM,CAEV,GACF,CAiJA,SAAS,EAAW,GAClB,OAAO,SAAU,GAEf,GAAsB,MAAlB,EAAO,OACT,OAAO,EAEP,MAAM,CAEV,CACF,CAyGA,SAAS,EAAc,EAAM,EAAyB,GACpD,IAAI,EAAW,iBACf,OAAO,EAAK,GAAG,IAAI,GAChB,MAAM,EAAW,CAAC,IAAK,EAAU,IAAK,KACtC,MAAK,SAAU,GACd,IAAI,EAAS,GAAe,GAC5B,OAAO,QAAQ,IAAI,EAAO,KAAI,SAAU,GACtC,OA3GR,eAAgC,EAAO,EAAM,GAC3C,MAAM,EAAY,cAAgB,EAC5B,EAAiB,CAAC,IAAK,EAAW,KAAM,IACxC,EAAU,EAAwB,IAAI,GACtC,EAA2B,EAAQ,GACnC,EAAU,EAAQ,GA8DlB,QAtZV,SAAkB,GAGhB,OAA0B,IAAnB,EAAQ,QAAgB,MAAM,KAAK,EAAQ,GAAG,IACvD,CAuVU,CAAS,GAGJ,QAAQ,QAAQ,GAElB,EAAK,GAAG,IAAI,GAAW,MAAM,EAAW,KAuD3C,QApDN,SAAyB,GACvB,OAAK,EAAQ,KAAK,OAIX,EAAK,GAAG,QAAQ,CACrB,KAAM,EAAQ,KACd,cAAc,IAJP,QAAQ,QAAQ,CAAC,KAAM,IAMlC,CA2C2B,CAAgB,GAC3C,OA1CA,SAA6B,EAAS,GACpC,MAAM,EAAS,GACT,EAAU,IAAI,GAEpB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAU,KAAK,OAAQ,EAAI,EAAK,IAAK,CACzD,MACM,EADM,EAAU,KAAK,GACX,IAChB,GAAK,IAGL,EAAO,KAAK,GACZ,EAAQ,IAAI,EAAI,KAChB,EAAI,UAAY,EAAyB,IAAI,EAAI,MAC5C,EAAI,UAAU,CACjB,MAAM,EAAW,EAAyB,IAAI,EAAI,KAC9C,UAAW,IACb,EAAI,MAAQ,EAAS,MAEzB,CACF,CACA,MAAM,EAAU,GAAe,GAiB/B,OAhBA,EAAQ,SAAQ,SAAU,GACxB,IAAK,EAAQ,IAAI,GAAM,CAErB,MAAM,EAAQ,CACZ,IAAK,GAED,EAAW,EAAyB,IAAI,GAC1C,UAAW,IACb,EAAM,MAAQ,EAAS,OAEzB,EAAO,KAAK,EACd,CACF,IACA,EAAQ,KAAO,GAAK,EAAQ,OAAO,EAAQ,OAC3C,EAAO,KAAK,GAEL,CACT,CAIO,CAAoB,EAAS,EACtC,CAqCe,CAAiB,EAAO,EAAM,EACvC,KAAI,MAAK,SAAU,GACjB,IAAI,EAAgB,GAAQ,GAI5B,OAHA,EAAW,IAAM,EACjB,EAAc,KAAK,GAEZ,EAAK,GAAG,SAAS,CAAC,KAAO,GAClC,IAGG,MAAK,IA7Cd,SAAwB,GAGtB,OAAO,EAAK,SAAS,IAAI,iBAAiB,MAAK,SAAU,GACvD,MAAM,EAAW,EAAI,SACrB,OAAO,EAAK,GAAG,IAAI,mBAAmB,MAAK,SAAU,GACnD,OAAO,EAAI,IACb,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,CAGV,IAAG,MAAK,SAAU,GAChB,OAAO,EAAK,GAAG,IAAI,CACjB,IAAK,kBACL,KAAM,EACN,YAEJ,GACF,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,CAEV,GACF,CAqBoB,CAAe,IAC/B,GACJ,CAEA,SAAS,EAAS,GAChB,MAAM,EAA2B,iBAAT,EAAoB,EAAO,EAAK,KACxD,IAAI,EAAQ,GAAiB,GAI7B,OAHK,IACH,EAAQ,GAAiB,GAAY,IAAI,IAEpC,CACT,CAEA,eAAe,EAAW,EAAM,GAC9B,OAAO,GAAc,EAAS,IAAO,WACnC,OAIJ,eAAiC,EAAM,GAErC,IAAI,EACA,EACA,EAEJ,SAAS,EAAK,EAAK,GACjB,MAAM,EAAS,CAAC,GAAI,EAAI,IAAK,IAAK,GAAa,IAG3C,MAAO,IACT,EAAO,MAAQ,GAAa,IAE9B,EAAW,KAAK,EAClB,CAEA,MAAM,EAAS,EAAO,EAAK,OAAQ,GAEnC,IAAI,EAAa,EAAK,KAAO,EAE7B,SAAS,IACP,OAAO,EAAK,SAAS,OAAO,MAAK,SAAU,GACzC,EAAS,EAAK,SAAS,YAAY,IAAI,CACrC,KAAM,gBACN,YAAa,EAAK,WAAa,GAEnC,GACF,CAEA,SAAS,EAAc,EAAyB,GAC9C,OAAO,WACL,OAAO,EAAc,EAAM,EAAyB,EACtD,CACF,CAEA,IAAI,EAAe,EACnB,MAAM,EAAW,CACf,KAAM,EAAK,KACX,aAAc,GAEhB,EAAK,SAAS,KAAK,WAAY,GAE/B,MAAM,EAAQ,IAAI,GAElB,eAAe,IAUb,OAAO,QATgB,EAAK,SAAS,QAAQ,CAC3C,aAAa,EACb,WAAW,EACX,cAAc,EACd,MAAO,WACP,MAAO,EACP,MAAO,EAAK,2BAEO,IAEvB,CAEA,SAAS,IACP,OAAO,EAAK,GAAG,IAAI,mBAAmB,MAAK,SAAU,GACnD,OAAO,EAAI,QACb,IAAG,OAAM,SAAU,GACjB,GAAI,GAAsB,MAAf,EAAI,OACb,MAAM,EAER,OAAQ,CACV,IAAG,MAAK,SAAU,GAChB,OAAO,EAAK,SAAS,IAAI,iBAAiB,MAAK,SAAU,GACvD,MAAM,EAAe,EAAI,OAAO,QAAO,SAAU,EAAO,GACtD,OAAO,EAAQ,CACjB,IAAG,KAAK,GAAU,EAAM,QAElB,EAAe,EAAa,QAAO,SAAU,EAAO,GACxD,OAAO,EAAa,QAAQ,KAAW,CACzC,IAEA,OAAO,QAAQ,IAAI,EAAa,KAAI,SAAU,GAC5C,OAAO,EAAK,SAAS,IAAI,GAAO,MAAK,SAAU,GAC7C,MAAO,CAAE,QAAO,MAClB,IAAG,OAAM,SAAU,GACjB,GAAmB,MAAf,EAAI,OACN,MAAM,EAER,MAAO,CAAE,QACX,GACF,IACF,IAAG,OAAM,SAAU,GACjB,GAAI,GAAsB,MAAf,EAAI,OACb,MAAM,EAER,MAAO,EACT,GACF,GACF,CAEA,SAAS,EAAa,EAAU,GAC9B,IAAI,EAAU,EAAS,QACvB,IAAK,EAAQ,SAAW,EAAO,OAC7B,OAGF,IAAK,IAAI,KAAS,EAAQ,CAIxB,GAHc,EAAQ,WAAU,SAAU,GACxC,OAAO,EAAO,KAAO,EAAM,KAC7B,IACY,EAAG,CAEb,MAAM,EAAQ,CACZ,IAAK,EAAM,MACX,IAAK,CACH,IAAK,EAAM,MACX,SAAU,GAEZ,QAAS,IAGP,EAAM,MAER,EAAM,IAAM,EAAM,IAClB,EAAM,QAAQ,KAAK,CAAE,IAAK,EAAM,IAAI,QAGtC,EAAQ,KAAK,EACf,CACF,CAEA,IAAI,EAA0B,EAA8B,GAE5D,EAAM,IAAI,EAAc,EAAyB,IAEjD,GAA8B,EAAQ,OACtC,MAAM,EAAW,CACf,KAAM,EAAK,KACX,SAAU,EAAS,SACnB,cAAe,EAAQ,OACvB,aAAc,GAKhB,OAHA,EAAK,SAAS,KAAK,WAAY,GAC/B,EAAK,SAAS,YAAY,OAAO,EAAQ,CAAC,gBAAiB,IAEvD,EAAQ,OAAS,EAAK,wBAA1B,EAGO,GACT,CAEA,SAAS,EAA8B,GACrC,MAAM,EAA0B,IAAI,GACpC,IAAK,IAAI,EAAI,EAAG,EAAM,EAAQ,OAAQ,EAAI,EAAK,IAAK,CAClD,MAAM,EAAS,EAAQ,GACvB,GAA0B,MAAtB,EAAO,IAAI,IAAI,GAAY,CAC7B,EAAa,GACb,EAAM,EAAO,IAER,EAAI,UACP,EAAO,EAAK,SAAU,EAAQ,GAEhC,EAAW,KAAK,GAEhB,MAAM,EAA2B,EAA+B,GAChE,EAAwB,IAAI,EAAO,IAAI,IAAK,CAC1C,EACA,EAAO,SAEX,CACA,EAAa,EAAO,GACtB,CACA,OAAO,CACT,CAEA,SAAS,EAA+B,GACtC,MAAM,EAA2B,IAAI,GACrC,IAAI,EACJ,IAAK,IAAI,EAAI,EAAG,EAAM,EAAW,OAAQ,EAAI,EAAK,IAAK,CACrD,MAAM,EAAkB,EAAW,GAC7B,EAAa,CAAC,EAAgB,IAAK,EAAgB,IACrD,EAAI,GAA+C,IAA1C,GAAQ,EAAgB,IAAK,IACxC,EAAW,KAAK,GAElB,EAAyB,IAAI,GAAkB,GAAa,GAC5D,EAAU,EAAgB,GAC5B,CACA,OAAO,CACT,CAEA,UACQ,UACA,UACA,EAAM,SACZ,EAAK,IAAM,EACX,EAAK,SAAS,YAAY,OAAO,EACnC,CAAE,MAAO,GACP,EAAK,SAAS,YAAY,OAAO,EAAQ,EAC3C,CACF,CArMW,CAAkB,EAAM,EACjC,GAFO,EAGT,CAuPA,SAAS,EAAU,EAAM,GACvB,OAAO,GAAc,EAAS,IAAO,WACnC,OAIJ,eAAgC,EAAM,GACpC,IAAI,EACJ,MAAM,EAAe,EAAK,YAA6B,IAAhB,EAAK,OACtC,EAAO,EAAK,MAAQ,OACD,IAAd,EAAK,MAAyB,EAAK,KAAK,SAEjD,EAAK,MAAQ,SACN,EAAK,MAGd,eAAe,EAAc,GAC3B,EAAS,cAAe,EACxB,MAAM,QAAY,EAAK,GAAG,QAAQ,GAGlC,OAFA,EAAY,EAAI,WAET,EAAI,KAAK,KAAI,SAAU,GAK5B,GAAI,UAAW,EAAO,KAAmC,iBAArB,EAAO,IAAI,OACxB,OAArB,EAAO,IAAI,MAAgB,CAC3B,MAAM,EAAO,OAAO,KAAK,EAAO,IAAI,OAAO,OAGrC,EAAe,CAAC,KAAM,MAAO,SACnC,KAAM,EAAO,GAAgB,EAAO,GAClC,OAAO,EAAO,IAAI,KAEtB,CAEA,MAAM,EJlrBd,SAA8B,GAM5B,IALA,IAAI,EAAQ,GACR,EAAY,GACZ,EAAI,IAGK,CACX,IAAI,EAAiB,EAAI,KACzB,GAAuB,OAAnB,EAQJ,OAAQ,GACN,IAAK,IACH,EAAM,KAAK,MACX,MACF,IAAK,IACH,EAAM,KAAgB,MAAX,EAAI,IACf,IACA,MACF,IAAK,IACH,IAAI,EAAY,GAAY,EAAK,GACjC,EAAM,KAAK,EAAU,KACrB,GAAK,EAAU,OACf,MACF,IAAK,IAGH,IAFA,IAAI,EAAY,KAEH,CACX,IAAI,EAAK,EAAI,GACb,GAAW,OAAP,EACF,MAEF,GAAa,EACb,GACF,CAIA,EAAY,EAAU,QAAQ,gBAAiB,MAC5C,QAAQ,gBAAiB,KACzB,QAAQ,gBAAiB,KAE5B,EAAM,KAAK,GACX,MACF,IAAK,IACH,IAAI,EAAe,CAAE,QAAS,GAAI,MAAO,EAAM,QAC/C,EAAM,KAAK,EAAa,SACxB,EAAU,KAAK,GACf,MACF,IAAK,IACH,IAAI,EAAa,CAAE,QAAS,CAAC,EAAG,MAAO,EAAM,QAC7C,EAAM,KAAK,EAAW,SACtB,EAAU,KAAK,GACf,MAEF,QACE,MAAM,IAAI,MACR,4DACE,OAvDR,CACE,GAAqB,IAAjB,EAAM,OACR,OAAO,EAAM,MAEb,GAAI,EAAO,EAGf,CAkDF,CACF,CIgnBkC,CAAqB,EAAO,IAAI,KAC1D,MAAO,CACL,IAAK,EAAkB,GACvB,GAAI,EAAkB,GACtB,MAAQ,UAAW,EAAO,IAAM,EAAO,IAAI,MAAQ,KAEvD,GACF,CAEA,eAAe,EAAkB,GAC/B,IAAI,EAqBJ,GAnBE,EADE,EAlGR,SAAoB,EAAM,EAAS,GACL,IAAxB,EAAQ,oBACH,EAAQ,YAGjB,MAAM,EAAc,EAAQ,OAAS,EAAQ,YAEvC,EAAY,EAAQ,EAAK,WAEzB,EAAS,GACT,EAAM,MAAM,EAAQ,aAAe,OAAO,kBAC9C,EAAQ,YACV,EAAQ,SAAQ,SAAU,GACxB,MAAM,EAAO,EAAO,EAAO,OAAS,GACpC,IAAI,EAAW,EAAc,EAAE,IAAM,KAOrC,GAJI,GAAe,MAAM,QAAQ,KAC/B,EAAW,EAAS,MAAM,EAAG,IAG3B,GAA6C,IAArC,GAAQ,EAAK,SAAU,GAGjC,OAFA,EAAK,KAAK,KAAK,CAAC,EAAE,IAAK,EAAE,UACzB,EAAK,OAAO,KAAK,EAAE,OAGrB,EAAO,KAAK,CACV,KAAM,CAAC,CAAC,EAAE,IAAK,EAAE,KACjB,OAAQ,CAAC,EAAE,OACX,SAAU,GAEd,IACA,EAAU,GACV,IAAK,IAAI,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAAK,CACjD,MAAM,EAAI,EAAO,GACX,EAAY,EAAU,EAAK,SAAU,EAAW,EAAE,KAAM,EAAE,QAAQ,GACxE,GAAI,EAAU,OAAS,EAAU,iBAAiB,GAEhD,MAAM,EAAU,MAElB,EAAQ,KAAK,CAEX,MAAO,EAAU,MAAQ,KAAO,EAAU,OAC1C,IAAK,EAAE,UAEX,CAEA,MAAO,CAAC,KAAM,EAAa,EAAS,EAAQ,MAAO,EAAQ,MAC7D,CAmDqB,CAAW,EAAM,EAAM,QACR,IAAd,EAAK,KACN,CACb,WAAY,EACZ,OAAQ,EACR,KAAM,GAIO,CACb,WAAY,EACZ,OAAQ,EACR,KAAM,EAAa,EAAK,EAAK,MAAM,EAAK,OAIxC,EAAK,aACP,EAAa,WAAa,EAAK,KAE7B,EAAK,aAAc,CACrB,MAAM,EAAS,GAAK,EAAK,IAAI,IAEvB,QAAmB,EAAK,SAAS,QAAQ,CAC7C,KAAM,EACN,cAAc,EACd,UAAW,EAAK,UAChB,YAAa,EAAK,YAClB,OAAQ,EAAK,SAEf,IAAI,EAAe,IAAI,GAWvB,OAVA,EAAW,KAAK,SAAQ,SAAU,GAChC,EAAa,IAAI,EAAI,GAAI,EAAI,IAC/B,IACA,EAAK,SAAQ,SAAU,GACrB,IAAI,EAAQ,EAAW,GACnB,EAAM,EAAa,IAAI,GACvB,IACF,EAAI,IAAM,EAEd,IACO,CACT,CACE,OAAO,CAEX,CAEA,QAAyB,IAAd,EAAK,KAAsB,CACpC,MACM,EADO,EAAK,KACS,KAAI,SAAU,GACvC,MAAM,EAAW,CACf,SAAW,GAAkB,CAAC,IAC9B,OAAW,GAAkB,CAAC,EAAK,CAAC,KAMtC,OAHI,EAAK,aACP,EAAS,YAAa,GAEjB,EAAc,EACvB,IAGA,OAAO,EADiB,SADH,QAAQ,IAAI,IAGnC,CAAO,CACL,MAAM,EAAW,CACf,WAAa,EAAK,YAMpB,IAAI,EACA,EAkBJ,GAtBI,EAAK,aACP,EAAS,YAAa,GAIpB,cAAe,IACjB,EAAW,EAAK,WAEd,aAAc,IAChB,EAAW,EAAK,UAEd,YAAa,IACf,EAAS,EAAK,SAEZ,WAAY,IACd,EAAS,EAAK,aAEQ,IAAb,IACT,EAAS,SAAW,EAAK,WACvB,GAAkB,CAAC,EAAU,CAAC,IAC9B,GAAkB,CAAC,UAED,IAAX,EAAwB,CACjC,IAAI,GAAsC,IAAvB,EAAK,cACpB,EAAK,aACP,GAAgB,GAGlB,EAAS,OAAS,GAChB,EAAe,CAAC,EAAQ,CAAC,GAAK,CAAC,GACnC,CACA,QAAwB,IAAb,EAAK,IAAqB,CACnC,MAAM,EAAW,GAAkB,CAAC,EAAK,MACnC,EAAS,GAAkB,CAAC,EAAK,IAAK,CAAC,IACzC,EAAS,YACX,EAAS,OAAS,EAClB,EAAS,SAAW,IAEpB,EAAS,SAAW,EACpB,EAAS,OAAS,EAEtB,CACK,IACuB,iBAAf,EAAK,QACd,EAAS,MAAQ,EAAK,OAExB,EAAS,KAAO,GAIlB,OAAO,QADc,EAAc,GAErC,CACF,CAtKW,CAAiB,EAAM,EAChC,GAFO,EAGT,CA+OA,eAAe,EAAc,EAAI,EAAK,GAEpC,GAAyB,mBAAd,EAAG,OACZ,OA1pBJ,SAAqB,EAAI,EAAK,GAC5B,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,EAAG,OAAO,EAAK,GAAM,SAAU,EAAK,GAClC,GAAI,EACF,OAAO,EAAO,GAEhB,EAAQ,EACV,GACF,GACF,CAipBW,CAAY,EAAI,EAAK,GAE9B,GAAI,GAAS,GACX,OAnxBJ,eAAyB,EAAI,EAAK,GAEhC,IACI,EAEA,EAHA,EAAS,GAET,EAAS,MA+Bb,GAxBA,EAAa,SAAU,EAAM,GAC7B,EAAa,eAAgB,EAAM,GACnC,EAAa,cAAe,EAAM,GAClC,EAAa,QAAS,EAAM,GAC5B,EAAa,aAAc,EAAM,GACjC,EAAa,QAAS,EAAM,GAC5B,EAAa,cAAe,EAAM,GAClC,EAAa,OAAQ,EAAM,GAC3B,EAAa,QAAS,EAAM,GAC5B,EAAa,YAAa,EAAM,GAChC,EAAa,WAAY,EAAM,GAAQ,GACvC,EAAa,YAAa,EAAM,GAAQ,GACxC,EAAa,SAAU,EAAM,GAAQ,GACrC,EAAa,UAAW,EAAM,GAAQ,GACtC,EAAa,gBAAiB,EAAM,GACpC,EAAa,MAAO,EAAM,GAAQ,GAClC,EAAa,aAAc,EAAM,GAGjC,EAAS,EAAO,KAAK,KACrB,EAAoB,KAAX,EAAgB,GAAK,IAAM,OAIX,IAAd,EAAK,KAAsB,CACpC,MAAM,EAAiB,IAIjB,EAAe,QAAQ,mBAAmB,KAAK,UAAU,EAAK,SAChE,EAAa,OAAS,EAAO,OAAS,GAAK,EAG7C,IAAyB,MAAd,EAAO,GAAa,IAAM,KAAO,GAE5C,EAAS,OACU,iBAAR,EACT,EAAO,CAAC,KAAM,EAAK,MAEnB,EAAI,KAAO,EAAK,KAGtB,CAGA,GAAmB,iBAAR,EAAkB,CAC3B,MAAM,EAAQ,GAAc,GAEtB,QAAiB,EAAG,MAAM,WAAa,EAAM,GAAK,UAAY,EAAM,GAAK,EAAQ,CACrF,QAAS,IAAI,GAAQ,CAAC,eAAgB,qBACtC,OAAQ,EACR,KAAM,KAAK,UAAU,KAEvB,EAAK,EAAS,GAEd,MAAM,QAAe,EAAS,OAE9B,IAAK,EAEH,MADA,EAAO,OAAS,EAAS,OACnB,GAA0B,GAWlC,OAPA,EAAO,KAAK,SAAQ,SAAU,GAE5B,GAAI,EAAI,OAAS,EAAI,MAAM,OAA6B,yBAApB,EAAI,MAAM,MAC5C,MAAM,IAAI,MAAM,EAAI,OAExB,IAEO,IAAI,SAAQ,SAAU,GAC3B,EAAQ,EACV,IAAG,KAAK,EAAuB,GACjC,CAGA,EAAO,GAAQ,CAAC,EAChB,OAAO,KAAK,GAAK,SAAQ,SAAU,GAC7B,MAAM,QAAQ,EAAI,IACpB,EAAK,GAAO,EAAI,GAEhB,EAAK,GAAO,EAAI,GAAK,UAEzB,IAEA,MAAM,QAAiB,EAAG,MAAM,aAAe,EAAQ,CACrD,QAAS,IAAI,GAAQ,CAAC,eAAgB,qBACtC,OAAQ,OACR,KAAM,KAAK,UAAU,KAGvB,EAAK,EAAS,GAEd,MAAM,QAAe,EAAS,OAC9B,IAAK,EAEH,MADA,EAAO,OAAS,EAAS,OACnB,GAA0B,GAGlC,OAAO,IAAI,SAAQ,SAAU,GAC3B,EAAQ,EACV,IAAG,KAAK,EAAuB,GACjC,CAkqBW,CAAU,EAAI,EAAK,GAG5B,MAAM,EAAiB,CACrB,mBAAoB,EAAG,OAAO,gCAr9BX,IAw9BrB,GAAmB,iBAAR,EAkBT,OAhBA,EAAqB,EAAM,GAE3B,GAAc,KAAI,iBAChB,MAAM,QAAa,GACF,EACA,sBACF,EAAI,IACD,EAAI,QACJ,EACG,GAErB,ODniCK,ECmiCM,EAAW,EAAM,GAAgB,MAC1C,WAAc,OAAO,EAAU,EAAM,EAAO,IDpiChC,ECqiCZ,WAAc,OAAO,EAAK,GAAG,SAAW,EDpiCzC,EAAQ,MAAK,SAAU,GAC5B,OAAO,IAAsB,MAAK,WAChC,OAAO,CACT,GACF,IAAG,SAAU,GACX,OAAO,IAAsB,MAAK,WAChC,MAAM,CACR,GACF,IATF,IAAa,EAAS,CCuiChB,IACO,GAAc,SAChB,CAEL,MAAM,EAAe,EACf,EAAQ,GAAc,GACtB,EAAgB,EAAM,GACtB,EAAW,EAAM,GAEjB,QAAY,EAAG,IAAI,WAAa,GAGtC,KAFA,EAAM,EAAI,OAAS,EAAI,MAAM,IAI3B,MAAM,IAAI,GAAc,QAAQ,EAAI,yBAAyB,KAG/D,EAAc,EAAK,GACnB,EAAqB,EAAM,GAE3B,MAAM,QAAa,GACF,EACA,EACF,EAAI,IACD,EAAI,QACJ,EACG,GAErB,MAAmB,OAAf,EAAK,OAAiC,iBAAf,EAAK,OACX,iBAAf,EAAK,OACP,KAAS,WACP,EAAW,EAAM,EACnB,IAEK,EAAU,EAAM,WAEjB,EAAW,EAAM,GAChB,EAAU,EAAM,GAE3B,CACF,CAqBA,MAAM,GDhnCa,ECgnCqB,WACtC,MAAM,EAAK,KAEX,MAA+B,mBAApB,EAAG,aAvuBhB,SAA2B,GACzB,OAAO,IAAI,SAAQ,SAAU,EAAS,GACpC,EAAG,cAAa,SAAU,EAAK,GAC7B,GAAI,EACF,OAAO,EAAO,GAEhB,EAAQ,EACV,GACF,GACF,CA+tBW,CAAkB,GAEvB,GAAS,GA1Kf,eAA+B,GAK7B,aAJuB,EAAG,MAAM,gBAAiB,CAC/C,QAAS,IAAI,GAAQ,CAAC,eAAgB,qBACtC,OAAQ,UAEM,MAClB,CAqKW,CAAgB,GAnK3B,eAAgC,GAC9B,IACE,MAAM,QAAgB,EAAG,IAAI,UAAY,GACnC,EAAc,IAAI,GAExB,OAAO,KAAK,EAAQ,OAAO,SAAQ,SAAU,GAC3C,MAAM,EAAQ,GAAc,GACtB,EAAgB,WAAa,EAAM,GACnC,EAAW,EAAM,GACvB,IAAI,EAAQ,EAAY,IAAI,GACvB,IACH,EAAQ,IAAI,GACZ,EAAY,IAAI,EAAe,IAEjC,EAAM,IAAI,EACZ,IACA,MAAM,EAAO,CACX,KAAO,GAAe,GACtB,cAAe,GAGX,QAAY,EAAG,QAAQ,GACvB,EAAgB,CAAC,EACvB,EAAI,KAAK,SAAQ,SAAU,GACzB,MAAM,EAAW,EAAI,IAAI,UAAU,GACnC,EAAY,IAAI,EAAI,KAAK,SAAQ,SAAU,GACzC,IAAI,EAAe,EAAW,IAAM,EAE/B,EAAQ,MAAM,KAGjB,EAAe,GAEjB,MAAM,EAAc,OAAO,KAAK,EAAQ,MAAM,IAExC,EAAe,EAAI,KAAO,EAAI,IAAI,OACtC,EAAI,IAAI,MAAM,GAChB,EAAY,SAAQ,SAAU,GAC5B,EAAc,GACZ,EAAc,IAAe,CACjC,GACF,GACF,IAEA,MAGM,EAHc,OAAO,KAAK,GAC7B,QAAO,SAAU,GAAc,OAAQ,EAAc,EAAa,IAEjC,KAAI,SAAU,GAChD,OAAO,GAAc,EAAS,IAAa,WACzC,OAAO,IAAI,EAAG,YAAY,EAAY,EAAG,QAAQ,SACnD,GAFO,EAGT,IAEA,OAAO,QAAQ,IAAI,GAAiB,MAAK,WACvC,MAAO,CAAC,IAAI,EACd,GACF,CAAE,MAAO,GACP,GAAmB,MAAf,EAAI,OACN,MAAO,CAAC,IAAI,GAEZ,MAAM,CAEV,CACF,CAsGS,CAAiB,EAC1B,EDznCO,YAAa,GAClB,IAAI,EAAK,EAAK,MACV,EAAU,EAAI,MAAM,KAAM,GAI9B,MAHkB,mBAAP,GACT,GAAiB,EAAS,GAErB,CACT,GARF,IAAqB,EC4nCnB,MAAO,CACL,MAhCF,SAAuB,EAAK,EAAM,GAChC,MAAM,EAAK,KACS,mBAAT,IACT,EAAW,EACX,EAAO,CAAC,GAEV,EAAO,EAv4BT,SAAuB,GAIrB,OAHA,EAAK,YAAc,EAAc,EAAK,aACtC,EAAK,MAAQ,EAAc,EAAK,OAChC,EAAK,KAAO,EAAc,EAAK,MACxB,CACT,CAk4BgB,CAAc,GAAQ,CAAC,EAElB,mBAAR,IACT,EAAM,CAAC,IAAM,IAGf,MAAM,EAAU,QAAQ,UAAU,MAAK,WACrC,OAAO,EAAc,EAAI,EAAK,EAChC,IAEA,OADA,GAAiB,EAAS,GACnB,CACT,EAgBE,YAAa,EAEjB,ECprCA,SAAS,GAAgB,EAAK,GAE5B,IADA,IAAI,EAAQ,EACH,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAAK,CAGtD,KADA,EAAQ,EADE,EAAY,KAGpB,KAEJ,CACA,OAAO,CACT,CAEA,SAAS,GAAc,EAAK,EAAa,GACvC,IAAK,IAAI,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAI,EAAG,IAAK,CACxD,IAAI,EAAO,EAAY,GACvB,EAAM,EAAI,GAAQ,EAAI,IAAS,CAAC,CAClC,CACA,EAAI,EAAY,EAAI,IAAM,CAC5B,CAEA,SAAS,GAAQ,EAAM,GACrB,OAAO,EAAO,GAAS,EAAI,EAAO,EAAQ,EAAI,CAChD,CAGA,SAAS,GAAW,GAIlB,IAFA,IAAI,EAAS,GACT,EAAU,GACL,EAAI,EAAG,EAAM,EAAU,OAAQ,EAAI,EAAK,IAAK,CACpD,IAAI,EAAK,EAAU,GACf,EAAI,GAA0B,OAArB,EAAU,EAAI,KAAuB,MAAP,GAAqB,MAAP,GAEvD,EAAU,EAAQ,UAAU,EAAG,EAAQ,OAAS,GAAK,EACrC,MAAP,GAET,EAAO,KAAK,GACZ,EAAU,IAEV,GAAW,CAEf,CAEA,OADA,EAAO,KAAK,GACL,CACT,CAEA,IAAI,GAAoB,CAAC,MAAO,OAAQ,QACxC,SAAS,GAAqB,GAC5B,OAAO,GAAkB,QAAQ,IAAU,CAC7C,CAEA,SAAS,GAAO,GACd,OAAO,OAAO,KAAK,GAAK,EAC1B,CAEA,SAAS,GAAS,GAChB,OAAO,EAAI,GAAO,GACpB,CAIA,SAAS,GAAoB,GAK3B,IAAI,EAAM,CAAC,EACP,EAAQ,CAAC,KAAK,EAAM,MAAM,GA4D9B,OA1DA,EAAU,SAAQ,SAAU,GAC1B,OAAO,KAAK,GAAU,SAAQ,SAAU,GACtC,IAAI,EAAU,EAAS,GAKvB,GAJuB,iBAAZ,IACT,EAAU,CAAC,IAAK,IAGd,GAAqB,GAEvB,GAAI,aAAmB,MAAO,CAC5B,GAAI,EAAM,GAGR,OAFA,EAAM,IAAS,OACf,EAAI,GAAS,GAIf,IAAI,EAAU,GACd,EAAI,GAAO,SAAQ,SAAU,GAC3B,OAAO,KAAK,GAAS,SAAQ,SAAU,GACrC,IAAI,EAAI,EAAQ,GACZ,EAAU,KAAK,IAAI,OAAO,KAAK,GAAU,OAAQ,OAAO,KAAK,GAAG,QAChE,EAAS,GAAoB,CAAC,EAAU,IACxC,OAAO,KAAK,GAAQ,QAAU,GAMlC,EAAQ,KAAK,EACf,GACF,IACA,EAAI,GAAS,CACf,MAEE,EAAI,GAAS,GAAoB,CAAC,QAE/B,CACL,IAAI,EAAgB,EAAI,GAAS,EAAI,IAAU,CAAC,EAChD,OAAO,KAAK,GAAS,SAAQ,SAAU,GACrC,IAAI,EAAQ,EAAQ,GAEpB,MAAiB,QAAb,GAAmC,SAAb,EAuBpC,SAAoB,EAAU,EAAO,GACnC,QAAiC,IAAtB,EAAc,IACvB,YAEgC,IAAvB,EAAc,KACN,SAAb,EACE,EAAQ,EAAc,OACxB,EAAc,KAAO,GAGnB,GAAS,EAAc,cAClB,EAAc,KACrB,EAAc,IAAM,QAGc,IAAtB,EAAc,IACb,SAAb,EACE,EAAQ,EAAc,aACjB,EAAc,IACrB,EAAc,KAAO,GAGnB,EAAQ,EAAc,MACxB,EAAc,IAAM,GAIxB,EAAc,GAAY,CAE9B,CAnDmB,CAAW,EAAU,EAAO,GACb,QAAb,GAAmC,SAAb,EAqD3C,SAAoB,EAAU,EAAO,GACnC,QAAiC,IAAtB,EAAc,IACvB,YAEgC,IAAvB,EAAc,KACN,SAAb,EACE,EAAQ,EAAc,OACxB,EAAc,KAAO,GAGnB,GAAS,EAAc,cAClB,EAAc,KACrB,EAAc,IAAM,QAGc,IAAtB,EAAc,IACb,SAAb,EACE,EAAQ,EAAc,aACjB,EAAc,IACrB,EAAc,KAAO,GAGnB,EAAQ,EAAc,MACxB,EAAc,IAAM,GAIxB,EAAc,GAAY,CAE9B,CAjFmB,CAAW,EAAU,EAAO,GACb,QAAb,EAmFrB,SAAiB,EAAO,GAClB,QAAS,EAEX,EAAc,IAAI,KAAK,GAEvB,EAAc,IAAM,CAAC,EAEzB,CAzFmB,CAAQ,EAAO,GACA,QAAb,EA2FrB,SAAiB,EAAO,UAGf,EAAc,WACd,EAAc,YACd,EAAc,WACd,EAAc,YACd,EAAc,IACrB,EAAc,IAAM,CACtB,CAnGmB,CAAQ,EAAO,GACA,WAAb,EAqGrB,SAAoB,EAAO,GACrB,WAAY,EAEd,EAAc,OAAO,KAAK,GAE1B,EAAc,OAAS,CAAC,EAE5B,CA3GmB,CAAW,EAAO,QAE3B,EAAc,GAAY,EAC5B,GACF,CACF,GACF,IAEO,CACT,CAqGA,SAAS,GAA0B,GAC/B,IAAK,IAAI,KAAQ,EAAK,CAClB,GAAI,MAAM,QAAQ,GACd,IAAK,IAAI,KAAK,EACN,EAAI,GAAS,OACb,EAAI,GAAK,GAAoB,EAAI,GAAS,OAItD,IAAI,EAAQ,EAAI,GACK,iBAAV,GACP,GAA0B,EAElC,CACA,OAAO,CACX,CAGA,SAAS,GAAgB,EAAK,GAC1B,IAAK,IAAI,KAAQ,EAAK,CACL,SAAT,IACA,GAAQ,GAEZ,IAAI,EAAQ,EAAI,GACK,iBAAV,IACP,EAAQ,GAAgB,EAAO,GAEvC,CACA,OAAO,CACX,CAKA,SAAS,GAAgB,GACvB,IAAI,EAAS,GAAM,GAGf,GAAgB,GAAQ,IAEtB,SADJ,EAAS,GAA0B,MAEjC,EAAS,GAAoB,EAAa,OAI9C,CAAC,MAAO,QAAQ,SAAQ,SAAU,GAC5B,KAAW,GAGb,EAAO,GAAS,SAAQ,SAAU,GAEhC,IADA,IAAI,EAAS,OAAO,KAAK,GAChB,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAI,EAAQ,EAAO,GACf,EAAU,EAAY,GACH,iBAAZ,GAAoC,OAAZ,IACjC,EAAY,GAAS,CAAC,IAAK,GAE/B,CACF,GAEJ,IAEI,SAAU,IAGZ,EAAa,KAAI,GAAoB,CAAC,EAAa,QAKrD,IAFA,IAAI,EAAS,OAAO,KAAK,GAEhB,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAI,EAAQ,EAAO,GACf,EAAU,EAAO,GAEE,iBAAZ,GAAoC,OAAZ,IACjC,EAAU,CAAC,IAAK,IAElB,EAAO,GAAS,CAClB,CAIA,OAFA,GAAwB,GAEjB,CACT,CAMA,SAAS,GAAwB,GAC/B,OAAO,KAAK,GAAU,SAAQ,SAAU,GACtC,IAAI,EAAU,EAAS,GAEnB,MAAM,QAAQ,GAChB,EAAQ,SAAQ,SAAU,GACpB,GAAsC,iBAAhB,GACxB,GAAwB,EAE5B,IACmB,QAAV,EACT,EAAS,IAAM,CAAC,GACG,WAAV,EACT,EAAS,OAAS,CAAC,GACV,GAA8B,iBAAZ,GAC3B,GAAwB,EAE5B,GACF,CA0BA,SAAS,GAAqB,EAAM,EAAY,GAK9C,GAJA,EAAO,EAAK,QAAO,SAAU,GAC3B,OAAO,GAAU,EAAI,IAAK,EAAW,SAAU,EACjD,IAEI,EAAW,KAAM,CAEnB,IAAI,EA9BR,SAA2B,GAEzB,SAAS,EAAsB,GAC7B,OAAO,EAAK,KAAI,SAAU,GACxB,IACI,EAAc,GADF,GAAO,IAGvB,OADoB,GAAgB,EAAK,EAE3C,GACF,CAEA,OAAO,SAAU,EAAM,GACrB,IAEI,EAAY,GAFG,EAAsB,EAAK,KAC3B,EAAsB,EAAK,MAE9C,OAAkB,IAAd,EACK,EAGF,GAAQ,EAAK,IAAI,IAAK,EAAK,IAAI,IACxC,CACF,CASsB,CAAkB,EAAW,MAC/C,EAAO,EAAK,KAAK,GACiB,iBAAvB,EAAW,KAAK,IACU,SAAjC,GAAS,EAAW,KAAK,MAC3B,EAAO,EAAK,UAEhB,CAEA,GAAI,UAAW,GAAc,SAAU,EAAY,CAEjD,IAAI,EAAO,EAAW,MAAQ,EAC1B,GAAS,UAAW,EAAa,EAAW,MAAQ,EAAK,QAAU,EACvE,EAAO,EAAK,MAAM,EAAM,EAC1B,CACA,OAAO,CACT,CAEA,SAAS,GAAU,EAAK,EAAU,GAChC,OAAO,EAAe,OAAM,SAAU,GACpC,IAAI,EAAU,EAAS,GACnB,EAAc,GAAW,GACzB,EAAgB,GAAgB,EAAK,GACzC,OAAI,GAAqB,GAkD7B,SAAmC,EAAO,EAAS,GAEjD,GAAc,QAAV,EACF,OAAO,EAAQ,MAAK,SAAU,GAC5B,OAAO,GAAU,EAAK,EAAY,OAAO,KAAK,GAChD,IAGF,GAAc,SAAV,EACF,OAAQ,GAAU,EAAK,EAAS,OAAO,KAAK,IAI9C,OAAQ,EAAQ,MAAK,SAAU,GAC7B,OAAO,GAAU,EAAK,EAAY,OAAO,KAAK,GAChD,GAEF,CAlEa,CAA0B,EAAO,EAAS,GAG5C,GAAc,EAAS,EAAK,EAAa,EAClD,GACF,CAEA,SAAS,GAAc,EAAS,EAAK,EAAa,GAChD,OAAK,IAMkB,iBAAZ,EACF,OAAO,KAAK,GAAS,OAAM,SAAU,GAC1C,IAAI,EAAY,EAAS,GAEzB,GAAuC,IAAnC,EAAkB,QAAQ,KAC5B,OAAO,GAAM,EAAmB,EAAK,EAAW,EAAa,GAE7D,IAAI,EAAiB,GAAW,GAEhC,QACoB,IAAlB,GACqB,iBAAd,GACP,EAAe,OAAS,EAGxB,OAAO,EAGT,IAAI,EAAmB,GAAgB,EAAe,GAEtD,MAAyB,iBAAd,EAEF,GAAc,EAAW,EAAK,EAAa,GAI7C,GAAM,MAAO,EAAK,EAAW,EAAgB,EAExD,IAIK,IAAY,EACrB,CAqBA,SAAS,GAAM,EAAc,EAAK,EAAW,EAAa,GACxD,IAAK,GAAS,GAEZ,MAAM,IAAI,MAAM,qBAAuB,EAAvB,sIAIlB,OAAO,GAAS,GAAc,EAAK,EAAW,EAAa,EAC7D,CAEA,SAAS,GAAY,GACnB,OAAO,MAAO,CAChB,CAEA,SAAS,GAAoB,GAC3B,YAAgC,IAAlB,CAChB,CAcA,SAAS,GAAmB,EAAe,GACzC,OAAO,EAAU,MAAK,SAAU,GAC9B,OAAI,aAAyB,MACpB,EAAc,MAAK,SAAU,GAClC,OAA2C,IAApC,GAAQ,EAAK,EACtB,IAGqC,IAAhC,GAAQ,EAAK,EACtB,GACF,CAsCA,IAAI,GAAW,CAEb,WAAc,SAAU,EAAK,EAAW,EAAa,GACnD,QAAK,MAAM,QAAQ,KAIU,IAAzB,EAAc,SAIc,iBAArB,EAAc,IAAyC,OAArB,EAAc,GAClD,EAAc,MAAK,SAAU,GAClC,OAAO,GAAU,EAAK,EAAW,OAAO,KAAK,GAC/C,IAGK,EAAc,MAAK,SAAU,GAClC,OAAO,GAAc,EAAW,EAAK,EAAa,EACpD,KACF,EAEA,UAAa,SAAU,EAAK,EAAW,EAAa,GAClD,QAAK,MAAM,QAAQ,KAKU,IAAzB,EAAc,SAIc,iBAArB,EAAc,IAAyC,OAArB,EAAc,GAClD,EAAc,OAAM,SAAU,GACnC,OAAO,GAAU,EAAK,EAAW,OAAO,KAAK,GAC/C,IAGK,EAAc,OAAM,SAAU,GACnC,OAAO,GAAc,EAAW,EAAK,EAAa,EACpD,KACF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAwD,IAAtC,GAAQ,EAAe,EACtE,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,IAAc,CACpF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,GAAa,CACnF,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,IAAc,CACpF,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAoB,IAAkB,GAAQ,EAAe,GAAa,CACnF,EAEA,QAAW,SAAU,EAAK,EAAW,EAAa,GAEhD,OAAI,EACK,GAAoB,IAGrB,GAAoB,EAC9B,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAY,IArIvB,SAAkB,EAAe,GAC/B,MAA6B,iBAAlB,GACT,SAAS,EAAe,MAAQ,GAO3B,EAHO,EAAU,KACd,EAAU,EAGtB,CA2HyC,CAAS,EAAe,EAC/D,EAEA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,EAAU,OAAM,SAAU,GAC/B,OAA2C,IAApC,GAAQ,EAAe,EAChC,GACF,EACA,IAAO,SAAU,EAAK,EAAW,EAAa,GAC5C,OAAO,GAAY,IAAkB,GAAmB,EAAe,EACzE,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,GAAY,KAAmB,GAAmB,EAAe,EAC1E,EAEA,MAAS,SAAU,EAAK,EAAW,EAAa,GAC9C,OAAO,GAAY,IACjB,MAAM,QAAQ,IAvHpB,SAAmB,EAAe,GAChC,OAAO,EAAc,SAAW,CAClC,CAsHM,CAAU,EAAe,EAC7B,EAEA,KAAQ,SAAU,EAAK,EAAW,EAAa,GAC7C,OAAO,MAAM,QAAQ,IApIzB,SAAgC,EAAe,GAC7C,OAAO,EAAU,OAAM,SAAU,GAC/B,OAAO,EAAc,MAAK,SAAU,GAClC,OAA2C,IAApC,GAAQ,EAAK,EACtB,GACF,GACF,CA8H2C,CAAuB,EAAe,EAC/E,EAEA,OAAU,SAAU,EAAK,EAAW,EAAa,GAC/C,OAAO,GAAY,IACO,iBAAjB,GACP,EAAU,OAAM,SAAU,GACxB,OA/HR,SAAoB,EAAe,GAGjC,OAFS,IAAI,OAAO,GAEV,KAAK,EACjB,CA2He,CAAW,EAAe,EACnC,GACJ,EAEA,MAAS,SAAU,EAAK,EAAW,EAAa,GAC9C,OA9HJ,SAAmB,EAAe,GAEhC,OAAQ,GACN,IAAK,OACH,OAAyB,OAAlB,EACT,IAAK,UACH,MAAkC,kBAApB,EAChB,IAAK,SACH,MAAkC,iBAApB,EAChB,IAAK,SACH,MAAkC,iBAApB,EAChB,IAAK,QACH,OAAO,aAAyB,MAClC,IAAK,SACH,MAA6C,oBAAtC,CAAG,EAAE,SAAS,KAAK,GAEhC,CA8GW,CAAU,EAAe,EAClC,GAIF,SAAS,GAAgB,EAAK,GAE5B,GAAwB,iBAAb,EAET,MAAM,IAAI,MAAM,0CAIlB,IAII,EAAc,GAAqB,CAJ7B,CACR,IAAO,IAGqC,CAAE,SALhD,EAAW,GAAgB,IAK6C,OAAO,KAAK,IACpF,OAAO,GAAsC,IAAvB,EAAY,MACpC,CClpBA,SAAS,GAA0B,GAsBjC,OArBA,EAAa,GAAM,IAEH,QACd,EAAW,MAAQ,CAAC,GAGtB,CAAC,OAAQ,OAAQ,QAAQ,SAAQ,SAAU,GACrC,EAAW,MAAM,KACnB,EAAW,GAAO,EAAW,MAAM,UAC5B,EAAW,MAAM,GAE5B,IAEI,EAAW,SACb,EAAW,MAAM,OAAS,EAAW,cAC9B,EAAW,QAGf,EAAW,OACd,EAAW,KAAO,QAEb,CACT,CAGA,SAAS,GAAoB,EAAM,EAAO,GACzC,IAAI,EAAU,GACV,EAAW,EACX,GAAc,EAclB,IAbgF,IAA5E,CAAE,MAAO,OAAQ,MAAO,OAAQ,OAAQ,OAAQ,QAAS,QAAQ,KAC/D,MAAM,QAAQ,KAClB,EAAU,kBAAoB,EAAO,wBAKsB,IAAzD,CAAE,OAAQ,aAAc,aAAc,QAAQ,KAC1C,MAAM,QAAQ,IAA2B,iBAAV,GAAgC,OAAV,KAC3D,EAAU,kBAAoB,EAAO,uBAI1B,SAAT,GAAmB,MAAM,QAAQ,GACpC,GAAqB,IAAjB,EAAM,OACT,EAAU,qHAEJ,CACN,IAAI,EAAU,EAAM,GAChB,EAAM,EAAM,GACA,IAAZ,IACH,EAAU,oEACV,GAAc,GAEQ,iBAAZ,GAAwB,SAAS,EAAS,MAAQ,IAC5D,EAAU,mDACV,EAAW,GAER,SAAS,EAAK,MAAQ,IACzB,EAAU,qDACV,EAAW,EAEb,CAQD,GANa,YAAT,GACkB,kBAAV,IACV,EAAU,6CAIC,UAAT,EAAkB,CACrB,IAAI,EAAU,CAAE,OAAQ,UAAW,SAAU,SAAU,QAAS,UAC5D,EAAa,IAAM,EAAQ,MAAM,EAAG,EAAQ,OAAS,GAAG,KAAK,QAAU,UAAY,EAAQ,EAAQ,OAAS,GAAK,KAChG,iBAAV,IAE2B,GAA3B,EAAQ,QAAQ,MAD1B,EAAU,4DAA8D,EAAa,IAIvF,CAmBA,GAjBa,UAAT,GACC,SAAS,EAAO,MAAQ,IAC3B,EAAU,2CAIC,WAAT,GACkB,iBAAV,IACN,EACH,EAAU,0CACE,aAAiB,SAC7B,EAAU,8FAMT,EAAS,CACZ,GAAI,EAWH,GAAW,aATa,OAAb,EACT,IACA,MAAM,QAAQ,GACd,SACA,WAAa,GAKiB,MAJM,iBAAb,GAAsC,OAAb,EAC/C,KAAK,UAAU,EAAU,KAAM,MAChC,GAIH,MAAM,IAAI,MAAM,EACjB,CACD,CAGA,IAAI,GAAoB,CAAE,OAAQ,YAAa,OAAQ,aAAc,UAAW,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,SAAU,QAAS,SAE7I,GAA+B,CAAE,MAAO,OAAQ,OAAQ,QAExD,GAAoB,CAAE,MAAO,MAAO,OAAQ,MAAO,QAGvD,SAAS,GAAiB,EAAO,GAChC,GAAI,MAAM,QAAQ,GACjB,IAAK,IAAI,KAAS,EACI,iBAAV,GAAgC,OAAV,GAChC,GAAiB,EAAO,QAM1B,IAFA,IAAI,EAAS,OAAO,KAAK,GAEhB,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACvC,IAAI,EAAM,EAAO,GACb,EAAQ,EAAM,IAEsB,IAApC,GAAkB,QAAQ,IAC7B,GAAoB,EAAK,EAAO,IAEO,IAApC,GAAkB,QAAQ,MAIqB,IAA/C,GAA6B,QAAQ,IAIpB,iBAAV,GAAgC,OAAV,GAChC,GAAiB,EAAO,GAE1B,CAEF,CAEA,SAAS,GAAQ,EAAI,EAAM,EAAM,GAC/B,IAAI,EAAQ,EACZ,EAAK,QAAU,IAAI,GAAQ,CAAC,eAAgB,qBAC5C,EAAG,MAAM,EAAM,GAAM,MAAK,SAAU,GAGlC,OAFA,EAAS,EAAS,OAClB,EAAK,EAAS,GACP,EAAS,MAClB,IAAG,MAAK,SAAU,GAChB,GAAK,EAKH,EAAS,KAAM,OALR,CACP,EAAK,OAAS,EACd,IAAI,EAAM,GAA0B,GACpC,EAAS,EACX,CAGF,IAAG,MAAM,EACX,CAEA,SAAS,GAAY,EAAI,EAAY,GACnC,EAAa,GAA0B,GACvC,GAAQ,EAAI,SAAU,CACpB,OAAQ,OACR,KAAM,KAAK,UAAU,IACpB,EACL,CAEA,SAAS,GAAK,EAAI,EAAY,GAC5B,GAAiB,EAAW,UAAU,GACtC,GAAQ,EAAI,QAAS,CACnB,OAAQ,OACR,KAAM,KAAK,UAAU,IACpB,EACL,CAEA,SAAS,GAAQ,EAAI,EAAY,GAC/B,GAAQ,EAAI,WAAY,CACtB,OAAQ,OACR,KAAM,KAAK,UAAU,IACpB,EACL,CAEA,SAAS,GAAW,EAAI,GACtB,GAAQ,EAAI,SAAU,CACpB,OAAQ,OACP,EACL,CAEA,SAAS,GAAY,EAAI,EAAU,GAGjC,IAAI,EAAO,EAAS,KAChB,EAAO,EAAS,MAAQ,OACxB,EAAO,EAAS,KAEpB,OAAK,EAIA,OAML,GAAQ,EAFE,UAAY,CAAC,EAAM,EAAM,GAAM,IAAI,oBAAoB,KAAK,KAErD,CAAC,OAAQ,UAAW,GAL5B,EAAS,IAAI,MAAM,qCAJnB,EAAS,IAAI,MAAM,oCAU9B,CAEA,SAAS,GAAY,GACnB,OAAO,YAAa,GAClB,IAAI,EAAK,EAAK,MACV,EAAU,EAAI,MAAM,KAAM,GAE9B,OAIJ,SAA0B,EAAS,GACjC,EAAQ,MAAK,SAAU,GACrB,KAAS,WACP,EAAS,KAAM,EACjB,GACF,IAAG,SAAU,GACX,KAAS,WACP,EAAS,EACX,GACF,GAEF,CAhBI,CAAiB,EAAS,GACnB,CACT,CACF,CAeA,IAAI,GAAU,YAAa,GAEzB,IADA,IAAI,EAAM,GACD,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CAC/C,IAAI,EAAS,EAAK,GACd,MAAM,QAAQ,GAChB,EAAM,EAAI,OAAO,GAAQ,MAAM,KAAM,IAErC,EAAI,KAAK,EAEb,CACA,OAAO,CACT,EAEA,SAAS,GAAa,GAEpB,IADA,IAAI,EAAM,CAAC,EACF,EAAI,EAAG,EAAM,EAAI,OAAQ,EAAI,EAAK,IACzC,EAAM,GAAO,EAAK,EAAI,IAExB,OAAO,CACT,CAiBA,SAAS,GAA0B,EAAM,GAEvC,IAAK,IAAI,EAAI,EAAG,EAAM,KAAK,IAAI,EAAK,OAAQ,EAAM,QAAS,EAAI,EAAK,IAClE,GAAI,EAAK,KAAO,EAAM,GACpB,OAAO,EAGX,OAAO,CACT,CAqDA,SAAS,GAAY,EAAM,GACzB,GAAI,EAAK,SAAW,EAAK,OACvB,OAAO,EAET,IAAK,IAAI,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAC1C,GAAI,EAAK,KAAO,EAAK,GACnB,OAAO,EAGX,OAAO,CACT,CAwFA,SAAS,GAAa,EAAQ,EAAM,GAClC,IAAI,EAXN,SAAsB,GACpB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAE5C,IAA4B,IADhB,EAAO,GACT,QAAQ,KAChB,OAAO,EAGX,OAAO,CACT,CAGkB,CAAa,GACzB,EAA6B,IAAlB,EAAO,OAItB,OAAI,EACE,EAnCR,SAAmC,EAAO,EAAM,GAC9C,OAAO,SAAU,GACX,IAAa,GAAgB,EAAK,IACtC,EAAK,EAAI,GACX,CACF,CA+Ba,CAA0B,EAAO,GAAI,EAAM,GA7BxD,SAAkC,EAAQ,EAAM,GAC9C,OAAO,SAAU,GACf,IAAI,GAAa,GAAgB,EAAK,GAAtC,CAEA,IADA,IAAI,EAAS,GACJ,EAAI,EAAG,EAAM,EAAO,OAAQ,EAAI,EAAK,IAC5C,EAAO,KAAK,EAAI,EAAO,KAEzB,EAAK,EALsD,CAM7D,CACF,CAsBa,CAAyB,EAAQ,EAAM,GAG5C,EAzDR,SAAgC,EAAO,EAAM,GAC3C,IAAI,EAAc,GAAW,GAC7B,OAAO,SAAU,GACf,IAAI,GAAa,GAAgB,EAAK,GAAtC,CAEA,IADA,IAAI,EAAQ,EACH,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAGjD,QAAqB,KADrB,EAAQ,EADE,EAAY,KAGpB,OAGJ,EAAK,EATsD,CAU7D,CACF,CA4Ca,CAAuB,EAAO,GAAI,EAAM,GA9ErD,SAA+B,EAAQ,EAAM,GAC3C,OAAO,SAAU,GACf,IAAI,GAAa,GAAgB,EAAK,GAAtC,CAEA,IADA,IAAI,EAAS,GACJ,EAAI,EAAG,EAAO,EAAO,OAAQ,EAAI,EAAM,IAAK,CAGnD,IAFA,IAAI,EAAc,GAAW,EAAO,IAChC,EAAQ,EACH,EAAI,EAAG,EAAO,EAAY,OAAQ,EAAI,EAAM,IAGnD,QAAqB,KADrB,EAAQ,EADE,EAAY,KAGpB,OAGJ,EAAO,KAAK,EACd,CACA,EAAK,EAdsD,CAe7D,CACF,CA8Da,CAAsB,EAAQ,EAAM,EAGjD,CA4BA,IAAI,GAAiB,GACA,WA3BrB,SAAgB,EAAW,GAMzB,OAAO,GAHQ,OAAO,KAAK,EAAU,QAGT,EAFJ,EAAU,wBAGpC,IAGA,WACE,MAAM,IAAI,MAAM,uBAClB,IAEA,SAAuB,EAAM,GAC3B,IAAI,EAAO,EAAK,MAAM,GAItB,IAAK,EAAK,MAAQ,EAAK,IAAI,OACzB,MAAM,IAAI,MAAM,QAAU,EAAK,IAAK,cAAgB,EAApC,4EAIpB,IASA,SAAS,GAAkB,GACzB,OAAI,EAAG,0BACE,CAIL,MAAO,SAA0B,EAAW,GAC1C,IAAI,EAAW,GAAe,MAAM,KAAK,MACzC,OAAO,EAAG,0BAA0B,MAAM,KAAK,KAAM,EAAW,EAAM,EACxE,EACA,YAAa,WACX,IAAI,EAAW,GAAe,YAAY,KAAK,MAC/C,OAAO,EAAG,0BAA0B,YAAY,KAAK,KAAM,EAC7D,GAGG,EACT,CA+BA,SAAS,GAAgB,GAcvB,OAbA,EAAS,OAAS,EAAS,OAAO,KAAI,SAAU,GAC9C,GAAqB,iBAAV,EAAoB,CAC7B,IAAI,EAAM,CAAC,EAEX,OADA,EAAI,GAAS,MACN,CACT,CACA,OAAO,CACT,IACI,EAAS,0BACX,EAAS,wBAA0B,GACjC,EAAS,0BAGN,CACT,CAEA,SAAS,GAAc,EAAK,GAE1B,IADA,IAAI,EAAM,GACD,EAAI,EAAG,EAAI,EAAM,IAAI,OAAO,OAAQ,IAAK,CAChD,IAAI,EAAQ,GAAO,EAAM,IAAI,OAAO,IACpC,EAAI,KAAK,GAAgB,EAAK,GAAW,IAC3C,CACA,OAAO,CACT,CAuNA,SAAS,GAAa,GAGpB,OAAO,EAAG,QAAQ,CAChB,SAAU,WACV,OAAQ,YACR,cAAc,IACb,MAAK,SAAU,GAChB,IAAI,EAAM,CACR,QAAS,CAAC,CACR,KAAM,KACN,KAAM,YACN,KAAM,UACN,IAAK,CACH,OAAQ,CAAC,CAAC,IAAK,YA0BrB,OArBA,EAAI,QAAU,GAAQ,EAAI,QAAS,EAAW,KAAK,QAAO,SAAU,GAClE,MAA4B,UAArB,EAAI,IAAI,QACjB,IAAG,KAAI,SAAU,GAGf,YAFkC,IAAlB,EAAI,IAAI,MAAsB,OAAO,KAAK,EAAI,IAAI,OAAS,IAE1D,KAAI,SAAU,GAC7B,IAAI,EAAO,EAAI,IAAI,MAAM,GACzB,MAAO,CACL,KAAM,EAAI,GACV,KAAM,EACN,KAAM,OACN,IAAK,GAAgB,EAAK,QAAQ,KAEtC,GACF,KAGA,EAAI,QAAQ,MAAK,SAAU,EAAM,GAC/B,OAAO,GAAQ,EAAK,KAAM,EAAM,KAClC,IACA,EAAI,WAAa,EAAI,QAAQ,OACtB,CACT,GACF,CAGA,IAAI,GAAa,KAGb,GAAa,CAAC,IAAU,CAAC,GAE7B,MAAM,GAAsB,CAC1B,UAAW,CAAE,MAAO,EAAG,SAAU,GAAY,OAAQ,IACrD,eAAgB,IAKlB,SAAS,GAAkB,EAAO,GAEhC,IADA,IAAI,EAAc,EAAM,IAAI,OAAO,IAAI,IAC9B,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAAK,CAEtD,GAAI,IADa,EAAY,GAE3B,OAAO,CAEX,CACA,OAAO,CACT,CAOA,SAAS,GAA2B,EAAU,GAI5C,MAAwB,QAFL,GADL,EAAS,GAIzB,CAIA,SAAS,GAAkB,EAAY,GACrC,IAAI,EAAc,EAAM,IAAI,OAAO,IAAI,IAEvC,OAAO,EAAW,QAAQ,MAAK,SAAU,EAAG,GAC1C,IAAI,EAAO,EAAY,QAAQ,GAC3B,EAAO,EAAY,QAAQ,GAO/B,OANc,IAAV,IACF,EAAO,OAAO,YAEF,IAAV,IACF,EAAO,OAAO,WAET,GAAQ,EAAM,EACvB,GACF,CAkCA,SAAS,GAAkB,EAAoB,EAAO,EAAU,GAC9D,IAAI,EAAS,GAEX,EAlCJ,SAAgC,EAAO,EAAU,GAM/C,IADA,IAAI,GAAuB,EAClB,EAAI,EAAG,GAJhB,EAAa,GAAkB,EAAY,IAIV,OAAQ,EAAI,EAAK,IAAK,CACrD,IAAI,EAAQ,EAAW,GACvB,GAAI,IAAyB,GAAkB,EAAO,GACpD,OAAO,EAAW,MAAM,GAEtB,EAAI,EAAM,GAAK,GAA2B,EAAU,KACtD,GAAuB,EAE3B,CACA,MAAO,EACT,CAoBI,CAAuB,EAAO,EAAU,GAlB5C,SAAiC,GAC/B,IAAI,EAAS,GASb,OARA,OAAO,KAAK,GAAU,SAAQ,SAAU,GACtC,IAAI,EAAU,EAAS,GACvB,OAAO,KAAK,GAAS,SAAQ,SAAU,GACpB,QAAb,GACF,EAAO,KAAK,EAEhB,GACF,IACO,CACT,CASI,CAAwB,IAG1B,OAAO,GAvjBT,SAAc,GAEZ,IADA,IAAI,EAAM,CAAC,EACF,EAAI,EAAG,EAAI,EAAI,OAAQ,IAC9B,EAAI,IAAM,EAAI,KAAM,EAEtB,OAAO,OAAO,KAAK,GAAK,KAAI,SAAU,GACpC,OAAO,EAAI,UAAU,EACvB,GACF,CA+iB2B,CAAK,GAAS,EACzC,CAIA,SAAS,GAAsB,EAAa,EAAW,GACrD,GAAI,EAAW,CAGb,IAAI,GA9nBuC,EA8nBkB,KA9nBxB,EA8nBa,GA5nB3C,OAAS,EAAM,SAIjB,GAA0B,EAAM,IAynBjC,EAAkB,GAA0B,EAAQ,GAExD,OAAO,GAAe,CACxB,CAloBF,IAAyC,EAAM,EAuoB7C,OA5nBF,SAAiC,EAAM,GACrC,EAAO,EAAK,QACZ,IAAK,IAAI,EAAI,EAAG,EAAM,EAAM,OAAQ,EAAI,EAAK,IAAK,CAChD,IAAI,EAAQ,EAAM,GAClB,IAAK,EAAK,OACR,MAEF,IAAI,EAAU,EAAK,QAAQ,GAC3B,IAAiB,IAAb,EACF,OAAO,EAEP,EAAK,OAAO,EAAS,EAEzB,CACA,OAAO,CACT,CA6mBS,CAAwB,EAAQ,EACzC,CAEA,IAAI,GAAkB,CAAC,MAAO,MAAO,OAAQ,MAAO,QACpD,SAAS,GAAoB,GAC3B,OAA6C,IAAtC,GAAgB,QAAQ,EACjC,CAqBA,SAAS,GAAkB,EAAO,EAAW,EAAQ,GAEnD,IAAI,EAAc,EAAM,IAAI,OAAO,IAAI,IAIvC,QAFkB,GAAsB,EAAa,EAAW,IAnBlE,SAAmC,EAAa,GAC9C,IACI,EAAU,EADG,EAAY,IAG7B,YAAuB,IAAZ,KAKuC,IAAhC,OAAO,KAAK,GAAS,QACjB,QAApB,GAAO,GAGX,CAYS,CAA0B,EAAa,EAChD,CAiBA,SAAS,GAAsB,EAAU,EAAY,EAAW,EAAS,GAEvE,IAAI,EAVN,SAA6B,EAAU,EAAY,EAAW,GAC5D,OAAO,EAAQ,QAAO,SAAU,GAC9B,OAAO,GAAkB,EAAO,EAAW,EAAY,EACzD,GACF,CAMwB,CAAoB,EAAU,EAAY,EAAW,GAE3E,GAA+B,IAA3B,EAAgB,OAAc,CAChC,GAAI,EACF,KAAM,CACJ,MAAO,kBACP,QAAS,kDAKb,IAAI,EAAe,EAAQ,GAE3B,OADA,EAAa,aAAc,EACpB,CACT,CACA,GAA+B,IAA3B,EAAgB,SAAiB,EACnC,OAAO,EAAgB,GAGzB,IAAI,EAvrBN,SAAuB,GAErB,IADA,IAAI,EAAM,CAAC,EACF,EAAI,EAAG,EAAM,EAAI,OAAQ,EAAI,EAAK,IACzC,EAAI,EAAI,KAAM,EAEhB,OAAO,CACT,CAirBsB,CAAc,GAclC,GAAI,EAAU,CACZ,IAAI,EAAe,WAAa,EAAS,GACrC,EAAmC,IAApB,EAAS,QAAe,EAAS,GAChD,EAAQ,EAAgB,MAAK,SAAU,GACzC,SAAI,GAAgB,EAAM,OAAS,GAAgB,IAAiB,EAAM,OAItE,EAAM,OAAS,CAMrB,IAEA,IAAK,EACH,KAAM,CACJ,MAAO,gBACP,QAAS,uEAGb,OAAO,CACT,CAEA,OAttBF,SAAa,EAAK,GAGhB,IAFA,IAAI,EAAM,KACN,GAAY,EACP,EAAI,EAAG,EAAM,EAAI,OAAQ,EAAI,EAAK,IAAK,CAC9C,IAAI,EAAU,EAAI,GACd,EAAQ,EAAI,GACZ,EAAQ,IACV,EAAW,EACX,EAAM,EAEV,CACA,OAAO,CACT,CA0sBS,CAAI,GArCX,SAAoB,GAGlB,IAFA,IAAI,EAAc,EAAM,IAAI,OAAO,IAAI,IACnC,EAAQ,EACH,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAAK,CACtD,IAAI,EAAa,EAAY,GACzB,EAAc,IAChB,GAEJ,CACA,OAAO,CACT,GA4BF,CA2BA,SAAS,GAA4B,EAAU,GAC7C,IAQI,EARA,EAAQ,GAAO,EAAM,IAAI,OAAO,IAGhC,EAAU,EAAS,IAAU,CAAC,EAC9B,EAAiB,GAuBrB,OArBoB,OAAO,KAAK,GAIlB,SAAQ,SAAU,GAE1B,GAAoB,IACtB,EAAe,KAAK,GAGtB,IAEI,EA5CR,SAAoC,EAAc,GAChD,OAAQ,GACN,IAAK,MACH,MAAO,CAAC,IAAK,GACf,IAAK,OACH,MAAO,CAAC,OAAQ,GAClB,IAAK,OACH,MAAO,CAAC,SAAU,GACpB,IAAK,MACH,MAAO,CACL,OAAQ,EACR,eAAe,GAEnB,IAAK,MACH,MAAO,CACL,SAAU,EACV,iBAAiB,GAIvB,MAAO,CACL,SAAU,GAEd,CAqBuB,CAA2B,EAF9B,EAAQ,IAKtB,EADE,EACa,GAAa,CAAC,EAAc,IAE5B,CAEnB,IAEO,CACL,UAAW,EACX,eAAgB,EAEpB,CAEA,SAAS,GAA2B,EAAc,GAChD,OAAQ,GACN,IAAK,MACH,MAAO,CACL,SAAU,EACV,OAAQ,GAEZ,IAAK,OACH,MAAO,CACL,OAAQ,GAEZ,IAAK,OACH,MAAO,CACL,SAAU,GAEd,IAAK,MACH,MAAO,CACL,OAAQ,EACR,eAAe,GAEnB,IAAK,MACH,MAAO,CACL,SAAU,EACV,iBAAiB,GAGzB,CAuHA,SAAS,GAAiB,EAAU,GAClC,OAAI,EAAM,YATZ,SAA6B,GAE3B,MAAO,CACL,UAAW,CAAC,SAAU,MACtB,eAAgB,CAAC,OAAO,KAAK,IAEjC,CAIW,CAAoB,GAGG,IAA5B,EAAM,IAAI,OAAO,OAEZ,GAA4B,EAAU,GA5HjD,SAAgC,EAAU,GAExC,IAKI,EACA,EANA,EAAc,EAAM,IAAI,OAAO,IAAI,IAEnC,EAAiB,GACjB,EAAW,GACX,EAAS,GAKb,SAAS,EAAO,IAES,IAAnB,GACF,EAAS,KAAK,KAEK,IAAjB,GACF,EAAO,KAAK,IAId,EAAiB,EAAY,MAAM,EACrC,CAEA,IAAK,IAAI,EAAI,EAAG,EAAM,EAAY,OAAQ,EAAI,EAAK,IAAK,CACtD,IAEI,EAAU,EAFG,EAAY,IAI7B,IAAK,IAAY,OAAO,KAAK,GAAS,OAAQ,CAC5C,EAAO,GACP,KACF,CAAO,GAAI,OAAO,KAAK,GAAS,KAAK,IAAsB,CACzD,EAAO,GACP,KACF,CAAO,GAAI,EAAI,EAAG,CAChB,IAAI,EACF,QAAS,GAAW,SAAU,GAC9B,QAAS,GAAW,SAAU,EAC5B,EAAe,OAAO,KAAK,EAAS,EAAY,EAAI,KACpD,EAAgB,GAAY,EAAc,CAAC,QAC3C,EAAkB,GAAY,EAAc,OAAO,KAAK,IAE5D,GAD0B,IAAc,IAAkB,EACjC,CACvB,EAAO,GACP,KACF,CACF,CAMA,IAJA,IAAI,EAAgB,OAAO,KAAK,GAE5B,EAAe,KAEV,EAAI,EAAG,EAAI,EAAc,OAAQ,IAAK,CAC7C,IAAI,EAAe,EAAc,GAG7B,EAAU,GAA2B,EAFzB,EAAQ,IAKtB,EADE,EACa,GAAa,CAAC,EAAc,IAE5B,CAEnB,CAEA,EAAS,KAAK,aAAc,EAAe,EAAa,SAAW,IACnE,EAAO,KAAK,WAAY,EAAe,EAAa,OAAS,IACzD,oBAAqB,IACvB,EAAiB,EAAa,iBAE5B,kBAAmB,IACrB,EAAe,EAAa,cAEhC,CAEA,IAAI,EAAM,CACR,SAAU,EACV,OAAQ,GAUV,YAP8B,IAAnB,IACT,EAAI,gBAAkB,QAEI,IAAjB,IACT,EAAI,cAAgB,GAGf,CACL,UAAW,EACX,eAAgB,EAEpB,CAmCS,CAAuB,EAAU,EAC1C,CAEA,SAAS,GAAU,EAAS,GAE1B,IAAI,EAAW,EAAQ,SACnB,EAAO,EAAQ,KAEnB,GAzCF,SAA4B,GAU1B,OAHe,OAAO,KAAK,GAAU,KAAI,SAAU,GACjD,OAAO,EAAS,EAClB,IACc,MAAK,SAAU,GAC3B,MAAsB,iBAAR,GAAgD,IAA5B,OAAO,KAAK,GAAK,MACvD,GACA,CA4BM,CAAmB,GACrB,OAAO,GAAO,CAAC,EAAG,GAAqB,CAAE,MAAO,EAAQ,KAG1D,IAAI,EApmBN,SAAuB,EAAU,GAC/B,IAEI,EAFA,EAAiB,OAAO,KAAK,GAC7B,EAAa,EAAM,EAAK,IAAI,IAAU,GAQ1C,OALE,EADE,EAAe,QAAU,EAAW,OACzB,EAEA,EAGW,IAAtB,EAAW,OACN,CACL,OAAQ,GAiBL,CACL,OAbF,EAAa,EAAW,MAAK,SAAU,EAAM,GAC3C,IAAI,EAAU,EAAW,QAAQ,IAChB,IAAb,IACF,EAAU,OAAO,WAEnB,IAAI,EAAW,EAAW,QAAQ,GAIlC,OAHkB,IAAd,IACF,EAAW,OAAO,WAEb,EAAU,GAAY,EAAI,EAAU,EAAW,EAAI,CAC5D,IAIE,UAAW,EAAK,IAAI,IAExB,CAmkBsB,CAAc,EAAU,GAExC,EAAa,EAAc,OAE3B,EAAQ,GAAsB,EAAU,EAD5B,EAAc,UACqC,EAAS,EAAQ,WAEhF,EAAgB,GAAiB,EAAU,GAW/C,MALU,CACR,UANc,EAAc,UAO5B,MAAO,EACP,eALmB,GAFI,EAAc,eAEoB,EAAO,EAAU,GAQ9E,CAuDA,SAAS,GAAO,EAAI,EAAY,GA3zBhC,IAAyB,EACnB,EA20BJ,OAhBI,EAAW,WAEb,GAAiB,EAAW,UAAU,GACtC,EAAW,SAAW,GAAgB,EAAW,WAG/C,EAAW,OACb,EAAW,KAl1Bf,SAAqB,GACnB,IAAK,MAAM,QAAQ,GACjB,MAAM,IAAI,MAAM,0CAElB,OAAO,EAAK,KAAI,SAAU,GACxB,GAAuB,iBAAZ,EAAsB,CAC/B,IAAI,EAAM,CAAC,EAEX,OADA,EAAI,GAAW,MACR,CACT,CACE,OAAO,CAEX,GACF,CAq0BsB,CAAY,EAAW,OAGvC,EAAW,YACb,EAAW,WAv0BU,EAu0BkB,EAAW,UAt0BhD,EAAkB,GACE,iBAAb,EACT,EAAgB,KAAK,GAErB,EAAkB,EAGb,EAAgB,KAAI,SAAU,GACnC,OAAO,EAAK,QAAQ,WAAY,GAClC,MA4GF,SAA6B,GAC3B,GAAmC,iBAAxB,EAAW,SACpB,MAAM,IAAI,MAAM,8CAgBpB,CAksBE,CAAoB,GAEb,GAAa,GAAI,MAAK,SAAU,GAErC,EAAG,YAAY,KAAK,QAAS,CAAC,OAAQ,iBAAkB,IACxD,IAAI,EAAY,GAAU,EAAY,EAAc,SACpD,EAAG,YAAY,KAAK,QAAS,CAAC,OAAQ,aAAc,IAEpD,IAAI,EAAa,EAAU,OA/uB/B,SAAsB,EAAY,GAChC,GAAI,EAAM,aAAe,EAAW,KAAM,CACxC,IAAI,EAAc,EAAW,KAAK,QAAO,SAAU,GACjD,MAAoC,QAA7B,OAAO,KAAK,GAAU,EAC/B,IAAG,KAAI,SAAU,GACf,OAAO,OAAO,KAAK,GAAU,EAC/B,IAEA,GAAI,EAAY,OAAS,EACvB,MAAM,IAAI,MAAM,4BAA8B,EAAY,KAAK,KAC/D,iCAEJ,CAEI,EAAM,WAGZ,CAguBI,CAAa,EAAY,GAEzB,IAAI,EAAO,GAAO,CAChB,cAAc,EACd,QAAQ,EAER,cAAe,EAAc,YAC5B,EAAU,WAEb,MAAI,aAAc,GAAQ,WAAY,GAClC,GAAQ,EAAK,SAAU,EAAK,QAAU,EAGjC,CAAC,KAAM,KAGG,EAAW,MACE,iBAAvB,EAAW,KAAK,IACU,SAAjC,GAAS,EAAW,KAAK,MAIzB,EAAK,YAAa,EAClB,EAvyBN,SAAwB,GACtB,IAAI,EAAU,GAAM,GAkBpB,cAjBO,EAAQ,gBACR,EAAQ,cACR,EAAQ,uBACR,EAAQ,cAEX,WAAY,IACd,EAAQ,SAAW,EAAK,QAEtB,aAAc,IAChB,EAAQ,OAAS,EAAK,UAEpB,oBAAqB,IACvB,EAAQ,cAAgB,EAAK,iBAE3B,kBAAmB,IACrB,EAAQ,gBAAkB,EAAK,eAE1B,CACT,CAmxBa,CAAe,IAGnB,EAAU,eAAe,SAGxB,UAAW,IACb,EAAK,MAAQ,EAAW,OAEtB,SAAU,IACZ,EAAK,KAAO,EAAW,OAIvB,EACK,QAAQ,QAAQ,EAAW,GAG7B,QAAQ,UAAU,MAAK,WAC5B,GAAwB,cAApB,EAAW,KACb,OApHR,SAAmB,EAAI,GACrB,IAAI,EAAO,GAAM,GA+BjB,OA3BI,EAAK,YACH,WAAY,GAA+B,iBAAhB,EAAK,SAClC,EAAK,OAAS,IAEZ,aAAc,GAAiC,iBAAlB,EAAK,WACpC,EAAK,MAAQ,KAGX,aAAc,GAAiC,iBAAlB,EAAK,WACpC,EAAK,SAAW,IAEd,WAAY,GAA+B,iBAAhB,EAAK,SAClC,EAAK,MAAQ,IAGb,QAAS,GAA4B,iBAAb,EAAK,MAC/B,EAAK,MAAQ,GAGX,EAAK,MAAQ,GAAK,EAAK,gBAIzB,EAAK,eAAiB,EAAK,MAC3B,EAAK,OAAS,EAAK,eAGd,EAAG,QAAQ,GACf,MAAK,SAAU,GAWd,OATA,EAAI,KAAO,EAAI,KAAK,QAAO,SAAU,GACnC,OAAQ,aAAa,KAAK,EAAI,GAChC,IAEI,EAAK,iBACP,EAAK,MAAQ,EAAK,gBAGpB,EAAI,KAAO,EAAI,KAAK,MAAM,EAAG,EAAK,OAC3B,CACT,GACJ,CAsEe,CAAU,EAAI,GAErB,IA3HkB,EA2Hd,GA3Hc,EA2He,GAzH1B,KAAK,UAAU,GAAK,IAAM,EAAM,KA0HvC,OAAO,GAAiB,GAAI,MAAM,KAAK,EAAI,EAAW,EAE1D,IAAG,MAAK,SAAU,IACa,IAAzB,EAAK,kBAGP,EAAI,KA/1BZ,SAA8B,EAAM,EAAa,GAE/C,IADA,IAAI,EAAc,EAAM,IAAI,OACnB,EAAI,EAAG,EAAM,EAAK,OAAQ,EAAI,EAAK,IAAK,CAC/C,IAKI,EAAS,GALH,EAAK,GAKgB,IAAK,GACpC,GAA2B,IAAvB,EAAY,OACd,EAAS,EAAO,QAIhB,KAAO,EAAO,OAAS,EAAY,QACjC,EAAO,MAIX,GAAI,KAAK,IAAI,GAAQ,EAAQ,IAAgB,EAE3C,KAEJ,CACA,OAAO,EAAI,EAAI,EAAK,MAAM,GAAK,CACjC,CAs0BmB,CAAqB,EAAI,KAAM,EAAK,SAAU,IAGvD,EAAU,eAAe,SAE3B,EAAI,KAAO,GAAqB,EAAI,KAAM,EAAY,EAAU,iBAGlE,IAAI,EAAO,CACT,KAAM,EAAI,KAAK,KAAI,SAAU,GAC3B,IAAI,EAAM,EAAI,IACd,OAAI,EAAW,OAxpCzB,SAAc,EAAK,GAEjB,IADA,IAAI,EAAM,CAAC,EACF,EAAI,EAAG,EAAM,EAAI,OAAQ,EAAI,EAAK,IAAK,CAC9C,IAAI,EAAc,GAAW,EAAI,IAC7B,EAAQ,GAAgB,EAAK,QACZ,IAAV,GACT,GAAc,EAAK,EAAa,EAEpC,CACA,OAAO,CACT,CA+oCmB,CAAK,EAAK,EAAW,QAEvB,CACT,KAOF,OAJI,EAAW,cACb,EAAK,QAAU,oEAGV,CACT,IACF,GACF,CA4DA,IAAI,GAAwB,IA5yB5B,SAAuB,EAAI,GAEzB,IAOI,EAPA,EAAmB,IADvB,EAAa,GAA0B,IACC,OAQxC,SAAS,IACP,OAAO,IAAQ,EAAM,GAAU,KAAK,UAAU,IAChD,CATA,EAAW,MAAQ,GAAgB,EAAW,OA1FhD,SAAuB,GACrB,IAAI,EAAY,EAAM,OAAO,QAAO,SAAU,GAC5C,MAA2B,QAApB,GAAS,EAClB,IACA,GAAyB,IAArB,EAAU,QAAgB,EAAU,SAAW,EAAM,OAAO,OAC9D,MAAM,IAAI,MAAM,4BAEpB,CAqFE,CAAc,EAAW,OASzB,IAAI,EAAW,EAAW,MAAS,OAAS,IAExC,EAAW,EAAW,MAAS,OAAS,IACxC,EAAS,WAAa,EAEtB,GAAqB,EACrB,GAAa,EA+BjB,OAFA,EAAG,YAAY,KAAK,QAAS,CAAC,OAAQ,iBAAkB,IAEjD,GAAO,EAAI,GA7BlB,SAAoB,GASlB,OARI,EAAI,MAAyB,UAAjB,EAAI,WAClB,GAAqB,GAEvB,EAAI,SAAW,QACf,EAAI,MAAQ,EAAI,OAAS,CAAC,IAE1B,IAAe,EAAI,MAAM,MAMzB,EAAI,MAAM,GAAY,CACpB,IAAK,CACH,OAAQ,GAAa,EAAW,MAAM,QACtC,wBAAyB,EAAW,MAAM,yBAE5C,OAAQ,SACR,QAAS,CACP,IAAK,IAIF,EACT,IAIsC,MAAK,WACzC,GAAI,EACF,MAAM,IAAI,MAAM,sCAChB,EACA,wBAEJ,IAAG,MAAK,WAIN,IAAI,EAAY,EAAW,IAAM,EACjC,OAAO,GAAiB,GAAI,MAAM,KAAK,EAAI,EAAW,CACpD,MAAO,EACP,QAAQ,IACP,MAAK,WACN,MAAO,CACL,GAAI,EACJ,KAAM,EACN,OAAQ,EAAa,SAAW,UAEpC,GACF,GACF,IAouBI,GAAiB,GAAY,IAC7B,GAAoB,IA5DxB,SAAmB,EAAI,GACrB,OAAO,GAAO,EAAI,GAAY,GAC7B,MAAK,SAAU,GACd,MAAO,CACL,OAAQ,EAAG,KACX,MAAO,EAAU,MACjB,SAAU,EAAW,SACrB,MAAO,CACL,UAAW,EAAU,UAAU,SAC/B,QAAS,EAAU,UAAU,QAE/B,KAAM,CACJ,UAAW,EAAW,WAAa,GACnC,SAAU,MACV,MAAO,EAAW,MAClB,KAAM,EAAW,KACjB,KAAM,EAAW,MAAQ,CAAC,EAC1B,OAAQ,EAAW,OACnB,WAAW,EACX,EAAG,CAAC,KAEN,MAAO,EAAW,MAClB,KAAM,EAAW,MAAQ,EACzB,OAAQ,EAAW,OAEvB,GACF,IAmCI,GAAuB,GAAY,IACnC,GAAwB,IAlC5B,SAAuB,EAAI,GAEzB,IAAK,EAAM,KACT,MAAM,IAAI,MAAM,+CAGlB,IAAK,EAAM,KACT,MAAM,IAAI,MAAM,+CAGlB,IAAI,EAAQ,EAAM,KACd,EAAW,EAAM,KAYrB,OAAO,GAAO,EAAI,GAVlB,SAAkB,GAChB,OAAsC,IAAlC,OAAO,KAAK,EAAI,OAAO,QAAgB,EAAI,MAAM,GAE5C,CAAC,IAAK,EAAO,UAAU,WAGzB,EAAI,MAAM,GACV,EACT,IAEmC,MAAK,WACtC,OAAO,GAAiB,GAAI,YAAY,MAAM,EAChD,IAAG,MAAK,WACN,MAAO,CAAC,IAAI,EACd,GACF,IAQI,GAAS,CAAC,EACd,GAAO,YAAc,IAAU,SAAU,EAAY,GAEnD,GAA0B,iBAAf,EACT,OAAO,EAAS,IAAI,MAAM,yCAGP,GAAS,MAC5B,GAAc,IACD,KAAM,EAAY,EACnC,IAEA,GAAO,KAAO,IAAU,SAAU,EAAY,GAO5C,QALwB,IAAb,IACT,EAAW,EACX,OAAa,GAGW,iBAAf,EACT,OAAO,EAAS,IAAI,MAAM,kDAGd,GAAS,MAAQ,GAAO,IAC9B,KAAM,EAAY,EAC5B,IAEA,GAAO,QAAU,IAAU,SAAU,EAAY,GAO/C,QALwB,IAAb,IACT,EAAW,EACX,OAAa,GAGW,iBAAf,EACT,OAAO,EAAS,IAAI,MAAM,qDAGd,GAAS,MAAQ,GAAU,IACjC,KAAM,EAAY,EAC5B,IAEA,GAAO,WAAa,IAAU,SAAU,IAElB,GAAS,MAAQ,GAAa,IACpC,KAAM,EACtB,IAEA,GAAO,YAAc,IAAU,SAAU,EAAU,GAEjD,GAAwB,iBAAb,EACT,OAAO,EAAS,IAAI,MAAM,yCAGP,GAAS,MAC5B,GAAc,IACD,KAAM,EAAU,EACjC,IAEA,YC1jDA,IAAI,GAAwC,SAAU,EAAS,EAAY,EAAG,GAE1E,OAAO,IAAK,IAAM,EAAI,WAAU,SAAU,EAAS,GAC/C,SAAS,EAAU,GAAS,IAAM,EAAK,EAAU,KAAK,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC1F,SAAS,EAAS,GAAS,IAAM,EAAK,EAAiB,MAAE,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC7F,SAAS,EAAK,GAJlB,IAAe,EAIa,EAAO,KAAO,EAAQ,EAAO,QAJ1C,EAIyD,EAAO,MAJhD,aAAiB,EAAI,EAAQ,IAAI,GAAE,SAAU,GAAW,EAAQ,EAAQ,KAIjB,KAAK,EAAW,EAAW,CAC7G,GAAM,EAAY,EAAU,MAAM,EAAS,GAAc,KAAK,OAClE,GACJ,EAIA,IAAI,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACJ,SAAS,KACL,GAAQ,IAAI,GAAQ,kBACpB,GAAU,IAAI,GAAQ,oBACtB,GAAQ,IAAI,GAAQ,kBACpB,GAAW,IAAI,GAAQ,qBACvB,GAAQ,IAAI,GAAQ,kBACpB,GAAe,IAAI,GAAQ,yBAC3B,GAAa,IAAI,GAAQ,uBACzB,GAAmB,IAAI,GAAQ,6BAC/B,GAAgB,IAAI,GAAQ,0BAC5B,GAAY,IAAI,GAAQ,sBACxB,GAAe,IAAI,GAAQ,yBAC3B,GAAW,IAAI,GAAQ,oBAC3B,CA1BA,GAAQ,OAAO,IA2Bf,KACA,IAAI,GAAW,CACX,WAAY,SAAU,GAElB,OADA,EAAQ,IAAM,EAAQ,KACf,GAAM,IAAI,EACrB,EACA,aAAc,SAAU,GAEpB,OADA,EAAU,IAAM,EAAU,KACnB,GAAQ,IAAI,EACvB,EACA,WAAY,SAAU,GAElB,OADA,EAAQ,IAAM,EAAQ,KACf,GAAM,IAAI,EACrB,EACA,eAAgB,SAAU,GACtB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YAInC,aAHmB,GAAM,KAAK,CAC1B,SAAU,CAAE,KAAM,MAER,KAAK,EACvB,GACJ,EACA,oBAAqB,SAAU,GAC3B,OAAO,GAAU,UAAM,OAAQ,GAAQ,YAInC,aAHmB,GAAM,KAAK,CAC1B,SAAU,CAAE,aAAc,MAEhB,KAAK,EACvB,GACJ,EACA,cAAe,SAAU,GAErB,OADA,EAAI,IAAM,EAAI,KACP,GAAS,IAAI,EACxB,EACA,WAAY,SAAU,GAElB,OADA,EAAI,IAAM,EAAI,KACP,GAAM,IAAI,EACrB,EACA,SAAU,SAAU,GAChB,OAAO,GAAM,IAAI,GAAI,OAAM,SAAU,GAAO,GAChD,EACA,kBAAmB,SAAU,GAEzB,OADA,EAAI,IAAM,EAAI,cACP,GAAa,IAAI,EAC5B,EACA,gBAAiB,SAAU,GACvB,OAAO,GAAa,IAAI,GAAI,OAAM,SAAU,GAAO,GACvD,EACA,kBAAmB,SAAU,GACzB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAI,IAAM,EAAI,SACd,IAAI,QAAe,GAAW,IAAI,EAAI,KAAK,OAAM,SAAU,GAAO,IAOlE,OANI,GACA,EAAI,KAAO,EAAO,KAClB,EAAI,MAAQ,EAAO,MAAQ,GAG3B,EAAI,MAAQ,EACT,GAAW,IAAI,EAC1B,GACJ,EACA,wBAAyB,SAAU,GAC/B,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAI,IAAM,EAAI,SACd,IAAI,QAAe,GAAiB,IAAI,EAAI,KAAK,OAAM,SAAU,GAAO,IAOxE,OANI,GACA,EAAI,KAAO,EAAO,KAClB,EAAI,MAAQ,EAAO,MAAQ,GAG3B,EAAI,MAAQ,EACT,GAAiB,IAAI,EAChC,GACJ,EACA,qBAAsB,SAAU,GAC5B,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAI,IAAM,EAAI,YACd,IAAI,QAAe,GAAc,IAAI,EAAI,KAAK,OAAM,SAAU,GAAO,IAOrE,OANI,GACA,EAAI,KAAO,EAAO,KAClB,EAAI,MAAQ,EAAO,MAAQ,GAG3B,EAAI,MAAQ,EACT,GAAc,IAAI,EAC7B,GACJ,EACA,kBAAmB,SAAU,GACzB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAI,IAAM,EAAI,SACd,IAAI,QAAe,GAAU,IAAI,EAAI,KAAK,OAAM,SAAU,GAAO,IAOjE,OANI,GACA,EAAI,KAAO,EAAO,KAClB,EAAI,MAAQ,EAAO,MAAQ,GAG3B,EAAI,MAAQ,EACT,GAAU,IAAI,EACzB,GACJ,EACA,qBAAsB,SAAU,GAC5B,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAI,IAAM,EAAI,YACd,IAAI,QAAe,GAAa,IAAI,EAAI,KAAK,OAAM,SAAU,GAAO,IAOpE,OANI,GACA,EAAI,KAAO,EAAO,KAClB,EAAI,MAAQ,EAAO,MAAQ,GAG3B,EAAI,MAAQ,EACT,GAAa,IAAI,EAC5B,GACJ,EACA,UAAW,SAAU,GACjB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YAWnC,aAVM,GAAM,YAAY,CACpB,MAAO,CAAE,OAAQ,CAAC,gBAEH,GAAM,KAAK,CAC1B,SAAU,EACJ,CAAE,GAAI,CAAE,KAAM,MAAQ,SAAU,GAChC,CAAE,GAAI,CAAE,KAAM,OACpB,KAAM,CAAC,MACP,MAAO,OAEG,IAClB,GACJ,EACA,YAAa,SAAU,GACnB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YAWnC,aAVM,GAAQ,YAAY,CACtB,MAAO,CAAE,OAAQ,CAAC,gBAEH,GAAQ,KAAK,CAC5B,SAAU,EACJ,CAAE,GAAI,CAAE,KAAM,MAAQ,SAAU,GAChC,CAAE,GAAI,CAAE,KAAM,OACpB,KAAM,CAAC,MACP,MAAO,OAEG,IAClB,GACJ,EACA,aAAc,SAAU,GACpB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAS,YAAY,CACvB,MAAO,CAAE,OAAQ,CAAC,gBAEH,GAAS,KAAK,CAC7B,SAAU,CAAE,GAAI,CAAE,KAAM,MAAQ,IAAK,CAAC,CAAE,GAAI,GAAQ,CAAE,KAAM,KAC5D,KAAM,CAAC,MACP,MAAO,OAEG,IAClB,GACJ,EACA,eAAgB,WACZ,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAW,YAAY,CACzB,MAAO,CAAE,OAAQ,CAAC,mBAEH,GAAW,KAAK,CAC/B,SAAU,CAAE,MAAO,CAAE,KAAM,OAC3B,KAAM,CAAC,SACP,MAAO,MAEG,IAClB,GACJ,EACA,qBAAsB,WAClB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAiB,YAAY,CAC/B,MAAO,CAAE,OAAQ,CAAC,mBAEH,GAAiB,KAAK,CACrC,SAAU,CAAE,MAAO,CAAE,KAAM,OAC3B,KAAM,CAAC,SACP,MAAO,MAEG,IAClB,GACJ,EACA,kBAAmB,WACf,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAc,YAAY,CAC5B,MAAO,CAAE,OAAQ,CAAC,mBAEH,GAAc,KAAK,CAClC,SAAU,CAAE,MAAO,CAAE,KAAM,OAC3B,KAAM,CAAC,SACP,MAAO,MAEG,IAClB,GACJ,EACA,cAAe,WACX,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAU,YAAY,CACxB,MAAO,CAAE,OAAQ,CAAC,mBAEH,GAAU,KAAK,CAC9B,SAAU,CAAE,MAAO,CAAE,KAAM,OAC3B,KAAM,CAAC,SACP,MAAO,MAEG,IAClB,GACJ,EACA,iBAAkB,WACd,OAAO,GAAU,UAAM,OAAQ,GAAQ,YASnC,aARM,GAAa,YAAY,CAC3B,MAAO,CAAE,OAAQ,CAAC,mBAEH,GAAa,KAAK,CACjC,SAAU,CAAE,MAAO,CAAE,KAAM,OAC3B,KAAM,CAAC,SACP,MAAO,MAEG,IAClB,GACJ,EACA,eAAgB,SAAU,GACtB,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,EAAY,IAAM,WAClB,IAAI,QAAe,GAAS,IAAI,EAAY,KAAK,OAAM,SAAU,GAAO,IAIxE,OAHI,IACA,EAAY,KAAO,EAAO,MAEvB,GAAS,IAAI,EAAa,CAAE,OAAO,GAC9C,GACJ,EACA,aAAc,WACV,OAAO,GAAU,UAAM,OAAQ,GAAQ,YAEnC,aADuB,GAAS,IAAI,YAAY,OAAM,SAAU,GAAO,GAE3E,GACJ,EACA,cAAe,WACX,OAAO,GAAU,UAAM,OAAQ,GAAQ,YACnC,MAAM,QAAsB,KAAK,eAGjC,QAAQ,IAAI,CACR,GAAM,UACN,GAAQ,UACR,GAAM,UACN,GAAS,UACT,GAAM,UACN,GAAa,UACb,GAAW,UACX,GAAiB,UACjB,GAAc,UACd,GAAU,UACV,GAAa,UACb,GAAS,YACV,MAAK,KAEJ,KACA,GAAS,eAAe,EAAc,GAE9C,GACJ,GAEG,MAAM,GAAQ,IACV,6BCvPX,SAAS,EAAI,EAAK,EAAO,GACvB,IAAI,EAAkB,EAAU,EAAU,OAAS,GAC/C,IAAQ,EAAgB,UAE1B,EAAU,MACV,EAAkB,EAAU,EAAU,OAAS,IAEjD,IAAI,EAAU,EAAgB,QAC1B,EAAmB,EAAgB,MACvC,GAAI,MAAM,QAAQ,GAChB,EAAQ,KAAK,QACR,GAAI,IAAqB,EAAM,OAAS,EAAG,CAEhD,EADU,EAAM,OACD,CACjB,MACE,EAAM,KAAK,EAEf,CAjEA,EAAQ,UAAY,SAAmB,GACrC,IAAI,EAAQ,GACZ,EAAM,KAAK,CAAC,IAAK,IAIjB,IAFA,IACI,EAAM,EAAa,EAAK,EAAG,EAAa,EAAM,EAAG,EAAK,EAAO,EAD7D,EAAM,GAEF,EAAO,EAAM,OAKnB,GAJA,EAAM,EAAK,IAGX,GAFS,EAAK,QAAU,GACxB,EAAM,EAAK,KAAO,GAGhB,GAAO,OACF,GAAmB,iBAAR,EAChB,QAAsB,IAAR,EAAsB,KAAO,KAAK,UAAU,QACrD,GAAY,OAAR,EACT,GAAO,YACF,GAAI,MAAM,QAAQ,GAAM,CAE7B,IADA,EAAM,KAAK,CAAC,IAAK,MACZ,EAAI,EAAI,OAAS,EAAG,GAAK,EAAG,IAC/B,EAAoB,IAAN,EAAU,GAAK,IAC7B,EAAM,KAAK,CAAC,IAAK,EAAI,GAAI,OAAQ,IAEnC,EAAM,KAAK,CAAC,IAAK,KACnB,KAAO,CAEL,IAAK,KADL,EAAO,GACG,EACJ,EAAI,eAAe,IACrB,EAAK,KAAK,GAId,IADA,EAAM,KAAK,CAAC,IAAK,MACZ,EAAI,EAAK,OAAS,EAAG,GAAK,EAAG,IAEhC,EAAQ,EADR,EAAM,EAAK,IAEX,EAAa,EAAI,EAAI,IAAM,GAC3B,GAAa,KAAK,UAAU,GAAO,IACnC,EAAM,KAAK,CAAC,IAAK,EAAO,OAAQ,IAElC,EAAM,KAAK,CAAC,IAAK,KACnB,CAEF,OAAO,CACT,EAwBA,EAAQ,MAAQ,SAAU,GAOxB,IANA,IAGI,EAAe,EAAU,EACzB,EAAa,EAAO,EAAsB,EAC1C,EAAc,EALd,EAAQ,GACR,EAAY,GACZ,EAAI,IAMN,GAAuB,OADvB,EAAiB,EAAI,OAEE,MAAnB,QAC0B,IAAnB,EAQX,OAAQ,GACN,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,IACL,IAAK,IACH,MACF,IAAK,IACH,GAAK,EACL,EAAI,KAAM,EAAO,GACjB,MACF,IAAK,IACH,GAAK,EACL,GAAI,EAAM,EAAO,GACjB,MACF,IAAK,IACH,GAAK,EACL,GAAI,EAAO,EAAO,GAClB,MACF,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IAGH,IAFA,EAAY,GACZ,MACa,CAEX,GADA,EAAU,EAAI,MACV,cAAc,KAAK,GAEhB,CACL,IACA,KACF,CAJE,GAAa,CAKjB,CACA,EAAI,WAAW,GAAY,EAAO,GAClC,MACF,IAAK,IAIH,IAHA,EAAe,GACf,OAAS,EACT,EAAwB,EAGX,OADX,EAAK,EAAI,OACqB,OAAX,GACf,EAAwB,GAAM,GAChC,GAAgB,EAED,QADf,EAAS,GAEP,IAEA,EAAwB,EAM9B,EAAI,KAAK,MAAM,IAAM,EAAe,KAAM,EAAO,GACjD,MACF,IAAK,IACH,EAAe,CAAE,QAAS,GAAI,MAAO,EAAM,QAC3C,EAAM,KAAK,EAAa,SACxB,EAAU,KAAK,GACf,MACF,IAAK,IACH,EAAa,CAAE,QAAS,CAAC,EAAG,MAAO,EAAM,QACzC,EAAM,KAAK,EAAW,SACtB,EAAU,KAAK,GACf,MACF,QACE,MAAM,IAAI,MACR,sCAAwC,OAtF9C,CAGE,GAAqB,IAAjB,EAAM,OACR,OAAO,EAAM,MAEb,EAAI,EAAM,MAAO,EAAO,EAG5B,CAgFJ,yBC1KA,IACI,KAAK,uBAAyB,GAClC,CACA,MAAO,GAAK,yBCHZ,IACI,KAAK,6BAA+B,GACxC,CACA,MAAO,GAAK,wBCHZ,IACI,KAAK,0BAA4B,GACrC,CACA,MAAO,GAAK,yBCHZ,IACI,KAAK,6BAA+B,GACxC,CACA,MAAO,GAAK,eCJR,EAA2B,CAAC,EAGhC,SAAS,EAAoB,GAE5B,IAAI,EAAe,EAAyB,GAC5C,QAAqB,IAAjB,EACH,OAAO,EAAa,QAGrB,IAAI,EAAS,EAAyB,GAAY,CAGjD,QAAS,CAAC,GAOX,OAHA,EAAoB,GAAU,EAAQ,EAAO,QAAS,GAG/C,EAAO,OACf,CCrBA,EAAoB,EAAK,IACxB,IAAI,EAAS,GAAU,EAAO,WAC7B,IAAO,EAAiB,QACxB,IAAM,EAEP,OADA,EAAoB,EAAE,EAAQ,CAAE,EAAG,IAC5B,CAAM,ECLd,EAAoB,EAAI,CAAC,EAAS,KACjC,IAAI,IAAI,KAAO,EACX,EAAoB,EAAE,EAAY,KAAS,EAAoB,EAAE,EAAS,IAC5E,OAAO,eAAe,EAAS,EAAK,CAAE,YAAY,EAAM,IAAK,EAAW,IAE1E,ECND,EAAoB,EAAI,WACvB,GAA0B,iBAAf,WAAyB,OAAO,WAC3C,IACC,OAAO,MAAQ,IAAI,SAAS,cAAb,EAChB,CAAE,MAAO,GACR,GAAsB,iBAAX,OAAqB,OAAO,MACxC,CACA,CAPuB,GCAxB,EAAoB,EAAI,CAAC,EAAK,IAAU,OAAO,UAAU,eAAe,KAAK,EAAK,GCClF,EAAoB,EAAK,IACH,oBAAX,QAA0B,OAAO,aAC1C,OAAO,eAAe,EAAS,OAAO,YAAa,CAAE,MAAO,WAE7D,OAAO,eAAe,EAAS,aAAc,CAAE,OAAO,GAAO,4BCGvD,MCeM,EAdI,CAAC,KAAS,KACvB,IAAI,EAAM,EAIV,OAHI,EAAK,OAAS,IACd,GAAO,OAAO,KAAK,UAAU,MAE1B,CAAG,ECId,MAAM,UAAqB,MASvB,WAAA,CAAY,EAAW,GAEnB,MADgB,EAAiB,EAAW,IAE5C,KAAK,KAAO,EACZ,KAAK,QAAU,CACnB,ECjBJ,MCPM,EAAoB,CACtB,gBAAiB,kBACjB,SAAU,cACV,OAAQ,UACR,QAAS,UACT,OAAgC,oBAAjB,aAA+B,aAAa,MAAQ,IAEjE,EAAoB,GACf,CAAC,EAAkB,OAAQ,EAAW,EAAkB,QAC1D,QAAQ,GAAU,GAAS,EAAM,OAAS,IAC1C,KAAK,KAOD,EAWS,GACP,GAAiB,EAAiB,EAAkB,UAZtD,EAiBQ,GACN,GAAiB,EAAiB,EAAkB,SC3BnE,SAAS,EAAU,EAAO,GACtB,MAAM,EAAgB,IAEtB,OADA,EAAM,UAAU,GACT,CACX,QCAO,SAAS,EAAe,GAC3B,IAAK,EACD,MAAM,IAAI,EAAa,oCAAqC,CAAE,UAIlE,GAAqB,iBAAV,EAAoB,CAC3B,MAAM,EAAY,IAAI,IAAI,EAAO,SAAS,MAC1C,MAAO,CACH,SAAU,EAAU,KACpB,IAAK,EAAU,KAEvB,CACA,MAAM,SAAE,EAAQ,IAAE,GAAQ,EAC1B,IAAK,EACD,MAAM,IAAI,EAAa,oCAAqC,CAAE,UAIlE,IAAK,EAAU,CACX,MAAM,EAAY,IAAI,IAAI,EAAK,SAAS,MACxC,MAAO,CACH,SAAU,EAAU,KACpB,IAAK,EAAU,KAEvB,CAGA,MAAM,EAAc,IAAI,IAAI,EAAK,SAAS,MACpC,EAAc,IAAI,IAAI,EAAK,SAAS,MAE1C,OADA,EAAY,aAAa,IAxCC,kBAwC0B,GAC7C,CACH,SAAU,EAAY,KACtB,IAAK,EAAY,KAEzB,CCzCA,MAAM,EACF,WAAA,GACI,KAAK,YAAc,GACnB,KAAK,eAAiB,GACtB,KAAK,iBAAmB,OAAS,UAAS,YAElC,IACA,EAAM,gBAAkB,EAC5B,EAEJ,KAAK,yBAA2B,OAAS,QAAO,QAAO,qBACnD,GAAmB,YAAf,EAAM,MACF,GACA,EAAM,iBACN,EAAM,2BAA2B,QAAS,CAE1C,MAAM,EAAM,EAAM,gBAAgB,IAC9B,EACA,KAAK,eAAe,KAAK,GAGzB,KAAK,YAAY,KAAK,EAE9B,CAEJ,OAAO,CAAc,CAE7B,EC3BJ,MAAM,EACF,WAAA,EAAY,mBAAE,IACV,KAAK,mBAAqB,OAAS,UAAS,aAGxC,MAAM,GAAY,aAAuC,EAAS,EAAO,WACrE,KAAK,oBAAoB,kBAAkB,EAAQ,KAEvD,OAAO,EACD,IAAI,QAAQ,EAAU,CAAE,QAAS,EAAQ,UACzC,CAAO,EAEjB,KAAK,oBAAsB,CAC/B,ECnBJ,IAAI,ECqBJ,eAAe,EAAa,EAAU,GAClC,IAAI,EAAS,KAEb,GAAI,EAAS,IAAK,CAEd,EADoB,IAAI,IAAI,EAAS,KAChB,MACzB,CACA,GAAI,IAAW,KAAK,SAAS,OACzB,MAAM,IAAI,EAAa,6BAA8B,CAAE,WAE3D,MAAM,EAAiB,EAAS,QAE1B,EAAe,CACjB,QAAS,IAAI,QAAQ,EAAe,SACpC,OAAQ,EAAe,OACvB,WAAY,EAAe,YAGzB,EAAuB,EAAW,EAAS,GAAgB,EAI3D,EDjCV,WACI,QAAsB,IAAlB,EAA6B,CAC7B,MAAM,EAAe,IAAI,SAAS,IAClC,GAAI,SAAU,EACV,IACI,IAAI,SAAS,EAAa,MAC1B,GAAgB,CACpB,CACA,MAAO,GACH,GAAgB,CACpB,CAEJ,GAAgB,CACpB,CACA,OAAO,CACX,CCkBiB,GACP,EAAe,WACT,EAAe,OAC3B,OAAO,IAAI,SAAS,EAAM,EAC9B,CChDA,SAAS,EAAY,EAAS,GAC1B,MAAM,EAAc,IAAI,IAAI,GAC5B,IAAK,MAAM,KAAS,EAChB,EAAY,aAAa,OAAO,GAEpC,OAAO,EAAY,IACvB,CCGA,MAAM,EAIF,WAAA,GACI,KAAK,QAAU,IAAI,SAAQ,CAAC,EAAS,KACjC,KAAK,QAAU,EACf,KAAK,OAAS,CAAM,GAE5B,ECdJ,MAAM,EAAsB,IAAI,WCKhC,SAAS,EAAU,GACf,MAAwB,iBAAV,EAAqB,IAAI,QAAQ,GAAS,CAC5D,CAUA,MAAM,EAiBF,WAAA,CAAY,EAAU,GAClB,KAAK,WAAa,CAAC,EA8CnB,OAAO,OAAO,KAAM,GACpB,KAAK,MAAQ,EAAQ,MACrB,KAAK,UAAY,EACjB,KAAK,iBAAmB,IAAI,EAC5B,KAAK,wBAA0B,GAG/B,KAAK,SAAW,IAAI,EAAS,SAC7B,KAAK,gBAAkB,IAAI,IAC3B,IAAK,MAAM,KAAU,KAAK,SACtB,KAAK,gBAAgB,IAAI,EAAQ,CAAC,GAEtC,KAAK,MAAM,UAAU,KAAK,iBAAiB,QAC/C,CAcA,WAAM,CAAM,GACR,MAAM,MAAE,GAAU,KAClB,IAAI,EAAU,EAAU,GACxB,GAAqB,aAAjB,EAAQ,MACR,aAAiB,YACjB,EAAM,gBAAiB,CACvB,MAAM,QAAiC,EAAM,gBAC7C,GAAI,EAKA,OAAO,CAEf,CAIA,MAAM,EAAkB,KAAK,YAAY,gBACnC,EAAQ,QACR,KACN,IACI,IAAK,MAAM,KAAM,KAAK,iBAAiB,oBACnC,QAAgB,EAAG,CAAE,QAAS,EAAQ,QAAS,SAEvD,CACA,MAAO,GACH,GAAI,aAAe,MACf,MAAM,IAAI,EAAa,kCAAmC,CACtD,mBAAoB,EAAI,SAGpC,CAIA,MAAM,EAAwB,EAAQ,QACtC,IACI,IAAI,EAEJ,QAAsB,MAAM,EAA0B,aAAjB,EAAQ,UAAsB,EAAY,KAAK,UAAU,cAM9F,IAAK,MAAM,KAAY,KAAK,iBAAiB,mBACzC,QAAsB,EAAS,CAC3B,QACA,QAAS,EACT,SAAU,IAGlB,OAAO,CACX,CACA,MAAO,GAeH,MARI,SACM,KAAK,aAAa,eAAgB,CACpC,MAAO,EACP,QACA,gBAAiB,EAAgB,QACjC,QAAS,EAAsB,UAGjC,CACV,CACJ,CAWA,sBAAM,CAAiB,GACnB,MAAM,QAAiB,KAAK,MAAM,GAC5B,EAAgB,EAAS,QAE/B,OADK,KAAK,UAAU,KAAK,SAAS,EAAO,IAClC,CACX,CAaA,gBAAM,CAAW,GACb,MAAM,EAAU,EAAU,GAC1B,IAAI,EACJ,MAAM,UAAE,EAAS,aAAE,GAAiB,KAAK,UACnC,QAAyB,KAAK,YAAY,EAAS,QACnD,EAAoB,OAAO,OAAO,OAAO,OAAO,CAAC,EAAG,GAAe,CAAE,cAC3E,QAAuB,OAAO,MAAM,EAAkB,GAStD,IAAK,MAAM,KAAY,KAAK,iBAAiB,4BACzC,QACW,EAAS,CACZ,YACA,eACA,iBACA,QAAS,EACT,MAAO,KAAK,cACT,EAEf,OAAO,CACX,CAgBA,cAAM,CAAS,EAAK,GAChB,MAAM,EAAU,EAAU,GCxP3B,IAAiB,UD2PF,EC1PX,IAAI,SAAS,GAAY,WAAW,EAAS,MD2PhD,MAAM,QAAyB,KAAK,YAAY,EAAS,SAiBzD,IAAK,EAKD,MAAM,IAAI,EAAa,6BAA8B,CACjD,KE1RQ,EF0RY,EAAiB,IEzRlC,IAAI,IAAI,OAAO,GAAM,SAAS,MAG/B,KAAK,QAAQ,IAAI,OAAO,IAAI,SAAS,UAAW,OAJ3C,IAAC,EF6RhB,MAAM,QAAwB,KAAK,2BAA2B,GAC9D,IAAK,EAKD,OAAO,EAEX,MAAM,UAAE,EAAS,aAAE,GAAiB,KAAK,UACnC,QAAc,KAAK,OAAO,KAAK,GAC/B,EAAyB,KAAK,YAAY,kBAC1C,EAAc,QHtR5B,eAAsC,EAAO,EAAS,EAAc,GAChE,MAAM,EAAqB,EAAY,EAAQ,IAAK,GAEpD,GAAI,EAAQ,MAAQ,EAChB,OAAO,EAAM,MAAM,EAAS,GAGhC,MAAM,EAAc,OAAO,OAAO,OAAO,OAAO,CAAC,EAAG,GAAe,CAAE,cAAc,IAC7E,QAAkB,EAAM,KAAK,EAAS,GAC5C,IAAK,MAAM,KAAY,EAEnB,GAAI,IADwB,EAAY,EAAS,IAAK,GAElD,OAAO,EAAM,MAAM,EAAU,EAIzC,CGuQoB,CAIR,EAAO,EAAiB,QAAS,CAAC,mBAAoB,GACpD,KAKN,UACU,EAAM,IAAI,EAAkB,EAAyB,EAAgB,QAAU,EACzF,CACA,MAAO,GACH,GAAI,aAAiB,MAKjB,KAHmB,uBAAf,EAAM,YGhT1B,iBAKI,IAAK,MAAM,KAAY,QACb,GAQd,CHmS0B,GAEJ,CAEd,CACA,IAAK,MAAM,KAAY,KAAK,iBAAiB,wBACnC,EAAS,CACX,YACA,cACA,YAAa,EAAgB,QAC7B,QAAS,EACT,MAAO,KAAK,QAGpB,OAAO,CACX,CAYA,iBAAM,CAAY,EAAS,GACvB,MAAM,EAAM,GAAG,EAAQ,SAAS,IAChC,IAAK,KAAK,WAAW,GAAM,CACvB,IAAI,EAAmB,EACvB,IAAK,MAAM,KAAY,KAAK,iBAAiB,sBACzC,EAAmB,QAAgB,EAAS,CACxC,OACA,QAAS,EACT,MAAO,KAAK,MAEZ,OAAQ,KAAK,UAGrB,KAAK,WAAW,GAAO,CAC3B,CACA,OAAO,KAAK,WAAW,EAC3B,CAQA,WAAA,CAAY,GACR,IAAK,MAAM,KAAU,KAAK,UAAU,QAChC,GAAI,KAAQ,EACR,OAAO,EAGf,OAAO,CACX,CAiBA,kBAAM,CAAa,EAAM,GACrB,IAAK,MAAM,KAAY,KAAK,iBAAiB,SAGnC,EAAS,EAEvB,CAUA,iBAAC,CAAiB,GACd,IAAK,MAAM,KAAU,KAAK,UAAU,QAChC,GAA4B,mBAAjB,EAAO,GAAsB,CACpC,MAAM,EAAQ,KAAK,gBAAgB,IAAI,GACjC,EAAoB,IACtB,MAAM,EAAgB,OAAO,OAAO,OAAO,OAAO,CAAC,EAAG,GAAQ,CAAE,UAGhE,OAAO,EAAO,GAAM,EAAc,QAEhC,CACV,CAER,CAcA,SAAA,CAAU,GAEN,OADA,KAAK,wBAAwB,KAAK,GAC3B,CACX,CAWA,iBAAM,GACF,IAAI,EACJ,KAAQ,EAAU,KAAK,wBAAwB,eACrC,CAEd,CAKA,OAAA,GACI,KAAK,iBAAiB,QAAQ,KAClC,CAWA,gCAAM,CAA2B,GAC7B,IAAI,EAAkB,EAClB,GAAc,EAClB,IAAK,MAAM,KAAY,KAAK,iBAAiB,mBAQzC,GAPA,QACW,EAAS,CACZ,QAAS,KAAK,QACd,SAAU,EACV,MAAO,KAAK,cACT,EACX,GAAc,GACT,EACD,MAwBR,OArBK,GACG,GAA8C,MAA3B,EAAgB,SACnC,OAAkB,GAmBnB,CACX,EIhfJ,MAAM,EAuBF,WAAA,CAAY,EAAU,CAAC,GAQnB,KAAK,UAAY,EAA0B,EAAQ,WAQnD,KAAK,QAAU,EAAQ,SAAW,GAQlC,KAAK,aAAe,EAAQ,aAQ5B,KAAK,aAAe,EAAQ,YAChC,CAoBA,MAAA,CAAO,GACH,MAAO,GAAgB,KAAK,UAAU,GACtC,OAAO,CACX,CAuBA,SAAA,CAAU,GAEF,aAAmB,aACnB,EAAU,CACN,MAAO,EACP,QAAS,EAAQ,UAGzB,MAAM,EAAQ,EAAQ,MAChB,EAAqC,iBAApB,EAAQ,QACzB,IAAI,QAAQ,EAAQ,SACpB,EAAQ,QACR,EAAS,WAAY,EAAU,EAAQ,YAAS,EAChD,EAAU,IAAI,EAAgB,KAAM,CAAE,QAAO,UAAS,WACtD,EAAe,KAAK,aAAa,EAAS,EAAS,GAGzD,MAAO,CAAC,EAFY,KAAK,eAAe,EAAc,EAAS,EAAS,GAG5E,CACA,kBAAM,CAAa,EAAS,EAAS,GAEjC,IAAI,QADE,EAAQ,aAAa,mBAAoB,CAAE,QAAO,YAExD,IAKI,GAJA,QAAiB,KAAK,QAAQ,EAAS,IAIlC,GAA8B,UAAlB,EAAS,KACtB,MAAM,IAAI,EAAa,cAAe,CAAE,IAAK,EAAQ,KAE7D,CACA,MAAO,GACH,GAAI,aAAiB,MACjB,IAAK,MAAM,KAAY,EAAQ,iBAAiB,mBAE5C,GADA,QAAiB,EAAS,CAAE,QAAO,QAAO,YACtC,EACA,MAIZ,IAAK,EACD,MAAM,CAOd,CACA,IAAK,MAAM,KAAY,EAAQ,iBAAiB,sBAC5C,QAAiB,EAAS,CAAE,QAAO,UAAS,aAEhD,OAAO,CACX,CACA,oBAAM,CAAe,EAAc,EAAS,EAAS,GACjD,IAAI,EACA,EACJ,IACI,QAAiB,CACrB,CACA,MAAO,GAIP,CACA,UACU,EAAQ,aAAa,oBAAqB,CAC5C,QACA,UACA,mBAEE,EAAQ,aAClB,CACA,MAAO,GACC,aAA0B,QAC1B,EAAQ,EAEhB,CAQA,SAPM,EAAQ,aAAa,qBAAsB,CAC7C,QACA,UACA,WACA,MAAO,IAEX,EAAQ,UACJ,EACA,MAAM,CAEd,ECtLJ,MAAM,UAAyB,EAkB3B,WAAA,CAAY,EAAU,CAAC,GACnB,EAAQ,UAAY,EAA2B,EAAQ,WACvD,MAAM,GACN,KAAK,oBAC6B,IAA9B,EAAQ,kBAKZ,KAAK,QAAQ,KAAK,EAAiB,uCACvC,CAQA,aAAM,CAAQ,EAAS,GACnB,MAAM,QAAiB,EAAQ,WAAW,GAC1C,OAAI,IAKA,EAAQ,OAAgC,YAAvB,EAAQ,MAAM,WAClB,KAAK,eAAe,EAAS,SAIjC,KAAK,aAAa,EAAS,GAC5C,CACA,kBAAM,CAAa,EAAS,GACxB,IAAI,EACJ,MAAM,EAAU,EAAQ,QAAU,CAAC,EAEnC,IAAI,KAAK,mBAuCL,MAAM,IAAI,EAAa,yBAA0B,CAC7C,UAAW,KAAK,UAChB,IAAK,EAAQ,MAzCQ,CACrB,EAKJ,MAAM,EAAsB,EAAO,UAC7B,EAAqB,EAAQ,UAC7B,GAAuB,GAAsB,IAAuB,EAe1E,GAZA,QAAiB,EAAQ,MAAM,IAAI,QAAQ,EAAS,CAChD,UAA4B,YAAjB,EAAQ,KACb,GAAsB,OACtB,KASN,GACA,GACiB,YAAjB,EAAQ,KAAoB,CAC5B,KAAK,8CACmB,EAAQ,SAAS,EAAS,EAAS,SACvD,CAMR,CACJ,CAuBA,OAAO,CACX,CACA,oBAAM,CAAe,EAAS,GAC1B,KAAK,wCACL,MAAM,QAAiB,EAAQ,MAAM,GAIrC,UADwB,EAAQ,SAAS,EAAS,EAAS,SAIvD,MAAM,IAAI,EAAa,0BAA2B,CAC9C,IAAK,EAAQ,IACb,OAAQ,EAAS,SAGzB,OAAO,CACX,CA4BA,qCAAA,GACI,IAAI,EAAqB,KACrB,EAA6B,EACjC,IAAK,MAAO,EAAO,KAAW,KAAK,QAAQ,UAEnC,IAAW,EAAiB,yCAI5B,IAAW,EAAiB,oCAC5B,EAAqB,GAErB,EAAO,iBACP,KAG2B,IAA/B,EACA,KAAK,QAAQ,KAAK,EAAiB,mCAE9B,EAA6B,GAA4B,OAAvB,GAEvC,KAAK,QAAQ,OAAO,EAAoB,EAGhD,EAEJ,EAAiB,kCAAoC,CACjD,gBAAqB,OAAC,SAAE,MACf,GAAY,EAAS,QAAU,IACzB,KAEJ,GAGf,EAAiB,uCAAyC,CACtD,gBAAqB,OAAC,SAAE,KACb,EAAS,iBAAmB,EAAa,GAAY,GCnMpE,MAAM,EAWF,WAAA,EAAY,UAAE,EAAS,QAAE,EAAU,GAAE,kBAAE,GAAoB,GAAU,CAAC,GAClE,KAAK,iBAAmB,IAAI,IAC5B,KAAK,kBAAoB,IAAI,IAC7B,KAAK,wBAA0B,IAAI,IACnC,KAAK,UAAY,IAAI,EAAiB,CAClC,UAAW,EAA2B,GACtC,QAAS,IACF,EACH,IAAI,EAAuB,CAAE,mBAAoB,QAErD,sBAGJ,KAAK,QAAU,KAAK,QAAQ,KAAK,MACjC,KAAK,SAAW,KAAK,SAAS,KAAK,KACvC,CAKA,YAAI,GACA,OAAO,KAAK,SAChB,CAWA,QAAA,CAAS,GACL,KAAK,eAAe,GACf,KAAK,kCACN,KAAK,iBAAiB,UAAW,KAAK,SACtC,KAAK,iBAAiB,WAAY,KAAK,UACvC,KAAK,iCAAkC,EAE/C,CAQA,cAAA,CAAe,GASX,MAAM,EAAkB,GACxB,IAAK,MAAM,KAAS,EAAS,CAEJ,iBAAV,EACP,EAAgB,KAAK,GAEhB,QAA4B,IAAnB,EAAM,UACpB,EAAgB,KAAK,EAAM,KAE/B,MAAM,SAAE,EAAQ,IAAE,GAAQ,EAAe,GACnC,EAA6B,iBAAV,GAAsB,EAAM,SAAW,SAAW,UAC3E,GAAI,KAAK,iBAAiB,IAAI,IAC1B,KAAK,iBAAiB,IAAI,KAAS,EACnC,MAAM,IAAI,EAAa,wCAAyC,CAC5D,WAAY,KAAK,iBAAiB,IAAI,GACtC,YAAa,IAGrB,GAAqB,iBAAV,GAAsB,EAAM,UAAW,CAC9C,GAAI,KAAK,wBAAwB,IAAI,IACjC,KAAK,wBAAwB,IAAI,KAAc,EAAM,UACrD,MAAM,IAAI,EAAa,4CAA6C,CAChE,QAGR,KAAK,wBAAwB,IAAI,EAAU,EAAM,UACrD,CAGA,GAFA,KAAK,iBAAiB,IAAI,EAAK,GAC/B,KAAK,kBAAkB,IAAI,EAAK,GAC5B,EAAgB,OAAS,EAAG,CAEf,EAAgB,KAAK,MAE9B,CAQR,CACJ,CACJ,CAWA,OAAA,CAAQ,GAGJ,OAAO,EAAU,GAAO,UACpB,MAAM,EAAsB,IAAI,EAChC,KAAK,SAAS,QAAQ,KAAK,GAG3B,IAAK,MAAO,EAAK,KAAa,KAAK,iBAAkB,CACjD,MAAM,EAAY,KAAK,wBAAwB,IAAI,GAC7C,EAAY,KAAK,kBAAkB,IAAI,GACvC,EAAU,IAAI,QAAQ,EAAK,CAC7B,YACA,MAAO,EACP,YAAa,sBAEX,QAAQ,IAAI,KAAK,SAAS,UAAU,CACtC,OAAQ,CAAE,YACV,UACA,UAER,CACA,MAAM,YAAE,EAAW,eAAE,GAAmB,EAIxC,MAAO,CAAE,cAAa,iBAAgB,GAE9C,CAWA,QAAA,CAAS,GAGL,OAAO,EAAU,GAAO,UACpB,MAAM,QAAc,KAAK,OAAO,KAAK,KAAK,SAAS,WAC7C,QAAgC,EAAM,OACtC,EAAoB,IAAI,IAAI,KAAK,iBAAiB,UAClD,EAAc,GACpB,IAAK,MAAM,KAAW,EACb,EAAkB,IAAI,EAAQ,aACzB,EAAM,OAAO,GACnB,EAAY,KAAK,EAAQ,MAMjC,MAAO,CAAE,cAAa,GAE9B,CAOA,kBAAA,GACI,OAAO,KAAK,gBAChB,CAOA,aAAA,GACI,MAAO,IAAI,KAAK,iBAAiB,OACrC,CAUA,iBAAA,CAAkB,GACd,MAAM,EAAY,IAAI,IAAI,EAAK,SAAS,MACxC,OAAO,KAAK,iBAAiB,IAAI,EAAU,KAC/C,CAMA,uBAAA,CAAwB,GACpB,OAAO,KAAK,wBAAwB,IAAI,EAC5C,CAmBA,mBAAM,CAAc,GAChB,MAAM,EAAM,aAAmB,QAAU,EAAQ,IAAM,EACjD,EAAW,KAAK,kBAAkB,GACxC,GAAI,EAAU,CAEV,aADoB,KAAK,OAAO,KAAK,KAAK,SAAS,YACtC,MAAM,EACvB,CAEJ,CASA,uBAAA,CAAwB,GACpB,MAAM,EAAW,KAAK,kBAAkB,GACxC,IAAK,EACD,MAAM,IAAI,EAAa,oBAAqB,CAAE,QAElD,OAAQ,IACJ,EAAQ,QAAU,IAAI,QAAQ,GAC9B,EAAQ,OAAS,OAAO,OAAO,CAAE,YAAY,EAAQ,QAC9C,KAAK,SAAS,OAAO,GAEpC,ECxRJ,IAAI,EAKG,MAAM,EAAgC,KACpC,IACD,EAAqB,IAAI,GAEtB,SCFJ,MCAM,EAAoB,GACzB,GAA8B,iBAAZ,EASX,EAWA,CAAE,OAAQ,GCjBzB,MAAM,EAYF,WAAA,CAAY,EAAO,EAAS,EFhBH,OE8BrB,KAAK,QAAU,EAAiB,GAChC,KAAK,MAAQ,EACb,KAAK,OAAS,CAClB,CAMA,eAAA,CAAgB,GACZ,KAAK,aAAe,EAAiB,EACzC,ECnCJ,MAAM,UAAoB,EActB,WAAA,CAAY,EAAQ,EAAS,GAiCzB,OAxBc,EAAG,UACb,MAAM,EAAS,EAAO,KAAK,EAAI,MAE/B,GAAK,IAOD,EAAI,SAAW,SAAS,QAA2B,IAAjB,EAAO,OAY7C,OAAO,EAAO,MAAM,EAAE,GAEb,EAAS,EAC1B,ECvCJ,MAAM,EAIF,WAAA,GACI,KAAK,QAAU,IAAI,IACnB,KAAK,mBAAqB,IAAI,GAClC,CAMA,UAAI,GACA,OAAO,KAAK,OAChB,CAKA,gBAAA,GAEI,KAAK,iBAAiB,SAAW,IAC7B,MAAM,QAAE,GAAY,EACd,EAAkB,KAAK,cAAc,CAAE,UAAS,UAClD,GACA,EAAM,YAAY,EAEzB,GACL,CAuBA,gBAAA,GAEI,KAAK,iBAAiB,WAAa,IAG/B,GAAI,EAAM,MAA4B,eAApB,EAAM,KAAK,KAAuB,CAEhD,MAAM,QAAE,GAAY,EAAM,KACtB,EAGJ,MAAM,EAAkB,QAAQ,IAAI,EAAQ,YAAY,KAAK,IACpC,iBAAV,IACP,EAAQ,CAAC,IAEb,MAAM,EAAU,IAAI,WAAW,GAC/B,OAAO,KAAK,cAAc,CAAE,UAAS,SAAQ,KAKjD,EAAM,UAAU,GAEZ,EAAM,OAAS,EAAM,MAAM,IACtB,EAAgB,MAAK,IAAM,EAAM,MAAM,GAAG,aAAY,IAEnE,CACH,GACL,CAaA,aAAA,EAAc,QAAE,EAAO,MAAE,IASrB,MAAM,EAAM,IAAI,IAAI,EAAQ,IAAK,SAAS,MAC1C,IAAK,EAAI,SAAS,WAAW,QAIzB,cAEJ,MAAM,EAAa,EAAI,SAAW,SAAS,QACrC,OAAE,EAAM,MAAE,GAAU,KAAK,kBAAkB,CAC7C,QACA,UACA,aACA,QAEJ,IAAI,EAAU,GAAS,EAAM,QAe7B,MAAM,EAAS,EAAQ,OAQvB,IAPK,GAAW,KAAK,mBAAmB,IAAI,KAKxC,EAAU,KAAK,mBAAmB,IAAI,KAErC,EAMD,cAkBJ,IAAI,EACJ,IACI,EAAkB,EAAQ,OAAO,CAAE,MAAK,UAAS,QAAO,UAC5D,CACA,MAAO,GACH,EAAkB,QAAQ,OAAO,EACrC,CAEA,MAAM,EAAe,GAAS,EAAM,aAuCpC,OAtCI,aAA2B,UAC1B,KAAK,eAAiB,KACvB,EAAkB,EAAgB,OAAM,MAAO,IAE3C,GAAI,EAAc,CACV,EASJ,IACI,aAAa,EAAa,OAAO,CAAE,MAAK,UAAS,QAAO,UAC5D,CACA,MAAO,GACC,aAAoB,QACpB,EAAM,EAEd,CACJ,CACA,GAAI,KAAK,cAUL,OAAO,KAAK,cAAc,OAAO,CAAE,MAAK,UAAS,UAErD,MAAM,CAAG,KAGV,CACX,CAgBA,iBAAA,EAAkB,IAAE,EAAG,WAAE,EAAU,QAAE,EAAO,MAAE,IAC1C,MAAM,EAAS,KAAK,QAAQ,IAAI,EAAQ,SAAW,GACnD,IAAK,MAAM,KAAS,EAAQ,CACxB,IAAI,EAGJ,MAAM,EAAc,EAAM,MAAM,CAAE,MAAK,aAAY,UAAS,UAC5D,GAAI,EA6BA,OAjBA,EAAS,GACL,MAAM,QAAQ,IAA6B,IAAlB,EAAO,QAI3B,EAAY,cAAgB,QACG,IAApC,OAAO,KAAK,GAAa,QAIG,kBAAhB,KAPZ,OAAS,GAcN,CAAE,QAAO,SAExB,CAEA,MAAO,CAAC,CACZ,CAeA,iBAAA,CAAkB,EAAS,EJ1SF,OI2SrB,KAAK,mBAAmB,IAAI,EAAQ,EAAiB,GACzD,CAQA,eAAA,CAAgB,GACZ,KAAK,cAAgB,EAAiB,EAC1C,CAMA,aAAA,CAAc,GAiCL,KAAK,QAAQ,IAAI,EAAM,SACxB,KAAK,QAAQ,IAAI,EAAM,OAAQ,IAInC,KAAK,QAAQ,IAAI,EAAM,QAAQ,KAAK,EACxC,CAMA,eAAA,CAAgB,GACZ,IAAK,KAAK,QAAQ,IAAI,EAAM,QACxB,MAAM,IAAI,EAAa,6CAA8C,CACjE,OAAQ,EAAM,SAGtB,MAAM,EAAa,KAAK,QAAQ,IAAI,EAAM,QAAQ,QAAQ,GAC1D,KAAI,GAAc,GAId,MAAM,IAAI,EAAa,yCAHvB,KAAK,QAAQ,IAAI,EAAM,QAAQ,OAAO,EAAY,EAK1D,EC7XJ,IAAI,EAQG,MAAM,EAA2B,KAC/B,IACD,EAAgB,IAAI,EAEpB,EAAc,mBACd,EAAc,oBAEX,GCHX,MAAM,UAAsB,EAiBxB,WAAA,CAAY,EAAoB,GAe5B,OAdc,EAAG,cACb,MAAM,EAAkB,EAAmB,qBAC3C,IAAK,MAAM,KCtBhB,UAAgC,GAAK,4BAAE,EAA8B,CAAC,QAAS,YAAW,eAAE,EAAiB,aAAY,UAAE,GAAY,EAAI,gBAAE,GAAqB,CAAC,GACtK,MAAM,EAAY,IAAI,IAAI,EAAK,SAAS,MACxC,EAAU,KAAO,SACX,EAAU,KAChB,MAAM,ECHH,SAAmC,EAAW,EAA8B,IAG/E,IAAK,MAAM,IAAa,IAAI,EAAU,aAAa,QAC3C,EAA4B,MAAM,GAAW,EAAO,KAAK,MACzD,EAAU,aAAa,OAAO,GAGtC,OAAO,CACX,CDNoC,CAA0B,EAAW,GAErE,SADM,EAAwB,KAC1B,GAAkB,EAAwB,SAAS,SAAS,KAAM,CAClE,MAAM,EAAe,IAAI,IAAI,EAAwB,MACrD,EAAa,UAAY,QACnB,EAAa,IACvB,CACA,GAAI,EAAW,CACX,MAAM,EAAW,IAAI,IAAI,EAAwB,MACjD,EAAS,UAAY,cACf,EAAS,IACnB,CACA,GAAI,EAAiB,CACjB,MAAM,EAAiB,EAAgB,CAAE,IAAK,IAC9C,IAAK,MAAM,KAAgB,QACjB,EAAa,IAE3B,CACJ,CDAsC,CAAsB,EAAQ,IAAK,GAAU,CACnE,MAAM,EAAW,EAAgB,IAAI,GACrC,GAAI,EAAU,CAEV,MAAO,CAAE,WAAU,UADD,EAAmB,wBAAwB,GAEjE,CACJ,CAIM,GAEG,EAAmB,SACpC,EG7BJ,SAAS,EAAS,GACd,MAAM,EAAqB,KCK/B,SAAuB,EAAS,EAAS,GACrC,IAAI,EACJ,GAAuB,iBAAZ,EAAsB,CAC7B,MAAM,EAAa,IAAI,IAAI,EAAS,SAAS,MAkC7C,EAAQ,IAAI,GAZU,EAAG,SASd,EAAI,OAAS,EAAW,MAGF,EAAS,EAC9C,MACK,GAAI,aAAmB,OAExB,EAAQ,IAAI,EAAY,EAAS,EAAS,QAEzC,GAAuB,mBAAZ,EAEZ,EAAQ,IAAI,EAAM,EAAS,EAAS,OAEnC,MAAI,aAAmB,GAIxB,MAAM,IAAI,EAAa,yBAA0B,CAC7C,WAAY,kBACZ,SAAU,gBACV,UAAW,YANf,EAAQ,CAQZ,CACsB,IACR,cAAc,EAEhC,CD/DI,CADsB,IAAI,EAAc,EAAoB,GAEhE,CE5BA,MAAM,EAAK,EAAQ,KAEb,EAAoB,CACxB,CAAC,SAAU,cAAe,MAAO,GACjC,CAAC,SAAU,UAAW,MAAO,GAC7B,CAAC,SAAU,kBAAmB,MAAO,GACrC,CAAC,SAAU,gBAAiB,MAAO,GACnC,CAAC,SAAU,SAAU,MAAO,GAC5B,CAAC,SAAU,uBAAwB,MAAO,GAC1C,CAAC,SAAU,uBAAwB,MAAO,GAC1C,CAAC,SAAU,SAAU,MAAO,ICX9B,MAAM,EAAK,EAAQ,KCCnB,MAAM,EAAK,EAAQ,KCDnB,IAAI,EAAwC,SAAU,EAAS,EAAY,EAAG,GAE1E,OAAO,IAAK,IAAM,EAAI,WAAU,SAAU,EAAS,GAC/C,SAAS,EAAU,GAAS,IAAM,EAAK,EAAU,KAAK,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC1F,SAAS,EAAS,GAAS,IAAM,EAAK,EAAiB,MAAE,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC7F,SAAS,EAAK,GAJlB,IAAe,EAIa,EAAO,KAAO,EAAQ,EAAO,QAJ1C,EAIyD,EAAO,MAJhD,aAAiB,EAAI,EAAQ,IAAI,GAAE,SAAU,GAAW,EAAQ,EAAQ,KAIjB,KAAK,EAAW,EAAW,CAC7G,GAAM,EAAY,EAAU,MAAM,EAAS,GAAc,KAAK,OAClE,GACJ,EACA,MAAM,EAAK,EAAQ,KCRnB,MAAM,EAAK,EAAQ,KCAnB,MAAM,EAAK,EAAQ,KCAnB,MAAM,EAAK,EAAQ,KCDnB,IAAI,EAAwC,SAAU,EAAS,EAAY,EAAG,GAE1E,OAAO,IAAK,IAAM,EAAI,WAAU,SAAU,EAAS,GAC/C,SAAS,EAAU,GAAS,IAAM,EAAK,EAAU,KAAK,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC1F,SAAS,EAAS,GAAS,IAAM,EAAK,EAAiB,MAAE,GAAS,CAAE,MAAO,GAAK,EAAO,EAAI,CAAE,CAC7F,SAAS,EAAK,GAJlB,IAAe,EAIa,EAAO,KAAO,EAAQ,EAAO,QAJ1C,EAIyD,EAAO,MAJhD,aAAiB,EAAI,EAAQ,IAAI,GAAE,SAAU,GAAW,EAAQ,EAAQ,KAIjB,KAAK,EAAW,EAAW,CAC7G,GAAM,EAAY,EAAU,MAAM,EAAS,GAAc,KAAK,OAClE,GACJ,EACA,MAAM,EAAK,EAAQ,KCenB,IAAmC,ECPnC,KAAK,iBAAiB,SAAU,IAC9B,EAAM,YAAY,WAGhB,IAAK,EAAM,QAAQ,IAAI,SAAS,SAC9B,OAAO,MAAM,EAAM,SAErB,GAAI,EAAM,QAAQ,IAAI,SAAS,eAC7B,OAAO,MAAM,EAAM,SAErB,GAAI,EAAM,QAAQ,IAAI,SAAS,cAC7B,aAAa,MAAM,EAAM,SAK3B,IAAI,EAAO,CAAC,EAER,EAAM,QAAQ,IAAI,SAAS,mBAC7B,QTrBN,iBACE,MAAM,EAAW,EAAG,QAEpB,IAAI,QAAmB,EAAS,iBAWhC,OAVA,EAAa,EAAW,OAAO,EAAkB,QAAO,GAAK,EAAW,OAAM,GAAK,EAAE,UAAY,EAAE,cACnG,EAAa,EAAW,MAAM,EAAG,IAEb,EAAW,KAC7B,EAAG,WAAU,YACb,CACE,KAAM,EACN,MAAO,KAIb,CSMmB,GACJ,EAAM,QAAQ,IAAI,SAAS,eACpC,QRnCN,iBACE,MAAM,EAAW,EAAG,QAEpB,IAAI,QAAiB,EAAS,eA8B9B,OA7Bc,GAAY,EAAS,OAG/B,CACE,uBAAwB,sCACxB,eACE,0GACF,UAAW,gCACX,UACE,8OACF,eAAgB,+CAChB,eAAgB,0CAChB,eAAgB,IAChB,iBAAkB,KAEpB,CACE,uBAAwB,8CACxB,eACE,+GACF,UAAW,oCACX,UACE,8OACF,eAAgB,+CAChB,eAAgB,0CAChB,eAAgB,IAChB,iBAAkB,IAK1B,CQCmB,GACJ,EAAM,QAAQ,IAAI,SAAS,iBACpC,QPpCN,iBACE,MAAM,EAAW,EAAG,QAWpB,aATsB,EAAS,iBAEF,KAC3B,EAAG,WAAU,YACb,CACE,KAAM,EACN,MAAO,KAIb,COuBmB,GACJ,EAAM,QAAQ,IAAI,SAAS,iBACpC,QN/BN,SAAqB,GACjB,OAAO,EAAU,UAAM,OAAQ,GAAQ,YACnC,MAAM,EAAW,EAAG,QAYpB,aAXqB,EAAS,aAAa,IAChB,KAAI,EAAG,OAAM,KAAI,UAAS,KAAI,OAAM,SAAQ,SAAQ,SAAS,CACpF,OACA,KACA,SACA,SACA,KACA,UACA,KACA,UAGR,GACJ,CMemB,GACJ,EAAM,QAAQ,IAAI,SAAS,cACpC,QLxCN,eAAwB,GACtB,MAAM,EAAW,EAAG,QAEpB,IAAI,EAuBJ,OAlBE,EAJG,QAIW,EAAS,UAAU,SAHnB,EAAS,YAMV,EAAM,KACnB,EAAG,OAAM,KAAI,OAAM,QAAO,QAAO,cAAa,WAAU,cAAa,WAAU,kBAC/E,CACE,KAAM,EACN,GAAI,EACJ,KAAM,EACN,MAAO,EACP,MAAO,EACP,YAAa,EACb,SAAU,EACV,YAAa,EACb,SAAU,EACV,YAAa,KAInB,CKamB,GACJ,EAAM,QAAQ,IAAI,SAAS,sBACpC,QJ1CN,iBACE,MAAM,EAAW,EAAG,QAWpB,aAT0B,EAAS,qBAEE,KACnC,EAAG,cAAa,YAChB,CACE,KAAM,EACN,MAAO,KAIb,CI6BmB,GACJ,EAAM,QAAQ,IAAI,SAAS,oBACpC,QH5CN,iBACE,MAAM,EAAW,EAAG,QAWpB,aATyB,EAAS,oBAEC,KACjC,EAAG,cAAa,YAChB,CACE,KAAM,EACN,MAAO,KAIb,CG+BmB,GACJ,EAAM,QAAQ,IAAI,SAAS,gBACpC,QFvCN,SAAiB,EAAU,GACvB,OAAO,EAAU,UAAM,OAAQ,GAAQ,YACnC,MAAM,EAAW,EAAG,QACpB,IAAI,EAKJ,OAHI,EADA,QACa,EAAS,oBAAoB,SAE7B,EAAS,eAAe,GACpC,EAGS,CACV,KAAM,EAAK,KACX,SAAU,EAAK,SACf,aAAc,EAAK,aACnB,UAAW,EAAK,UAChB,GAAI,EAAK,IAPF,IAUf,GACJ,CEmBmB,IAWf,OALiB,IAAI,SAAS,KAAK,UAAU,GAAO,CAClD,OAAQ,IACR,QAAS,CAAE,eAAgB,qBAK9B,EA7CiB,GA6Cb,ICnCP,SAAkB,GACa,IACR,SAAS,EAChC,CFNI,CC2Da,yiCAAK,eD1DlB,EAAS","file":"service-worker.js","sourceRoot":"","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\nvar types = [\n  require('./nextTick'),\n  require('./queueMicrotask'),\n  require('./mutation.js'),\n  require('./messageChannel'),\n  require('./stateChange'),\n  require('./timeout')\n];\nvar draining;\nvar currentQueue;\nvar queueIndex = -1;\nvar queue = [];\nvar scheduled = false;\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n  if (queue.length) {\n    nextTick();\n  }\n}\n\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  if (draining) {\n    return;\n  }\n  scheduled = false;\n  draining = true;\n  var len = queue.length;\n  var timeout = setTimeout(cleanUpNextTick);\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (currentQueue && ++queueIndex < len) {\n      currentQueue[queueIndex].run();\n    }\n    queueIndex = -1;\n    len = queue.length;\n  }\n  currentQueue = null;\n  queueIndex = -1;\n  draining = false;\n  clearTimeout(timeout);\n}\nvar scheduleDrain;\nvar i = -1;\nvar len = types.length;\nwhile (++i < len) {\n  if (types[i] && types[i].test && types[i].test()) {\n    scheduleDrain = types[i].install(nextTick);\n    break;\n  }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\nItem.prototype.run = function () {\n  var fun = this.fun;\n  var array = this.array;\n  switch (array.length) {\n  case 0:\n    return fun();\n  case 1:\n    return fun(array[0]);\n  case 2:\n    return fun(array[0], array[1]);\n  case 3:\n    return fun(array[0], array[1], array[2]);\n  default:\n    return fun.apply(null, array);\n  }\n\n};\nmodule.exports = immediate;\nfunction immediate(task) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n  queue.push(new Item(task, args));\n  if (!scheduled && !draining) {\n    scheduled = true;\n    scheduleDrain();\n  }\n}\n","'use strict';\n\nexports.test = function () {\n  if (global.setImmediate) {\n    // we can only get here in IE10\n    // which doesn't handel postMessage well\n    return false;\n  }\n  return typeof global.MessageChannel !== 'undefined';\n};\n\nexports.install = function (func) {\n  var channel = new global.MessageChannel();\n  channel.port1.onmessage = func;\n  return function () {\n    channel.port2.postMessage(0);\n  };\n};","'use strict';\n//based off rsvp https://github.com/tildeio/rsvp.js\n//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE\n//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js\n\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nexports.test = function () {\n  return Mutation;\n};\n\nexports.install = function (handle) {\n  var called = 0;\n  var observer = new Mutation(handle);\n  var element = global.document.createTextNode('');\n  observer.observe(element, {\n    characterData: true\n  });\n  return function () {\n    element.data = (called = ++called % 2);\n  };\n};","'use strict';\nexports.test = function () {\n  return typeof global.queueMicrotask === 'function';\n};\n\nexports.install = function (func) {\n  return function () {\n    global.queueMicrotask(func);\n  };\n};\n","'use strict';\n\nexports.test = function () {\n  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');\n};\n\nexports.install = function (handle) {\n  return function () {\n\n    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n    var scriptEl = global.document.createElement('script');\n    scriptEl.onreadystatechange = function () {\n      handle();\n\n      scriptEl.onreadystatechange = null;\n      scriptEl.parentNode.removeChild(scriptEl);\n      scriptEl = null;\n    };\n    global.document.documentElement.appendChild(scriptEl);\n\n    return handle;\n  };\n};","'use strict';\nexports.test = function () {\n  return true;\n};\n\nexports.install = function (t) {\n  return function () {\n    setTimeout(t, 0);\n  };\n};","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash.slice()\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} [raw] True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import immediate from 'immediate';\nimport Md5 from 'spark-md5';\nimport { v4 } from 'uuid';\nimport vuvuzela from 'vuvuzela';\nimport EE from 'events';\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.keys = function () {\n  return Object.keys(this._store).map(k => unmangle(k));\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date && isFinite(object)) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return function (...args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  };\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return function (...args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  };\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(function (...args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  });\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\nclass Changes extends EE {\n  constructor() {\n    super();\n    \n    this._listeners = {};\n    \n    if (hasLocalStorage()) {\n      addEventListener(\"storage\", (e) => {\n        this.emit(e.key);\n      });\n    }\n  }\n\n  addListener(dbName, id, db, opts) {\n    if (this._listeners[id]) {\n      return;\n    }\n    var inprogress = false;\n    var self = this;\n    function eventFunction() {\n      if (!self._listeners[id]) {\n        return;\n      }\n      if (inprogress) {\n        inprogress = 'waiting';\n        return;\n      }\n      inprogress = true;\n      var changesOpts = pick(opts, [\n        'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n        'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n      ]);\n  \n      function onError() {\n        inprogress = false;\n      }\n  \n      db.changes(changesOpts).on('change', function (c) {\n        if (c.seq > opts.since && !opts.cancelled) {\n          opts.since = c.seq;\n          opts.onChange(c);\n        }\n      }).on('complete', function () {\n        if (inprogress === 'waiting') {\n          immediate(eventFunction);\n        }\n        inprogress = false;\n      }).on('error', onError);\n    }\n    this._listeners[id] = eventFunction;\n    this.on(dbName, eventFunction);\n  }\n  \n  removeListener(dbName, id) {\n    if (!(id in this._listeners)) {\n      return;\n    }\n    super.removeListener(dbName, this._listeners[id]);\n    delete this._listeners[id];\n  }\n  \n  notifyLocalWindows(dbName) {\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (hasLocalStorage()) {\n      localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n    }\n  }\n  \n  notify(dbName) {\n    this.emit(dbName);\n    this.notifyLocalWindows(dbName);\n  }\n}\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\nclass PouchError extends Error {\n  constructor(status, error, reason) {\n    super();\n    this.status = status;\n    this.name = error;\n    this.message = reason;\n    this.error = true;\n  }\n\n  toString() {\n    return JSON.stringify({\n      status: this.status,\n      name: this.name,\n      message: this.message,\n      reason: this.reason\n    });\n  }\n}\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    var names = Object.getOwnPropertyNames(error);\n    for (var i = 0, len = names.length; i < len; i++) {\n      if (typeof error[names[i]] !== 'function') {\n        this[names[i]] = error[names[i]];\n      }\n    }\n\n    if (this.stack === undefined) {\n      this.stack = (new Error()).stack;\n    }\n\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  if (!('stack' in err)) {\n    err.stack = (new Error()).stack;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(change.doc._attachments, att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EE.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return db.get(docId)\n    .catch(function (err) {\n      /* istanbul ignore next */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return {};\n    })\n    .then(function (doc) {\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return {updated: false, rev: docRev};\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      return tryAndPut(db, newDoc, diffFun);\n    });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = self.setImmediate || self.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\n/**\n * Creates a new revision string that does NOT include the revision height\n * For example '56649f1b0506c6ca9fda0746eb0cacdf'\n */\nfunction rev$$1(doc, deterministic_revs) {\n  if (!deterministic_revs) {\n    return v4().replace(/-/g, '').toLowerCase();\n  }\n\n  var mutateableDoc = $inject_Object_assign({}, doc);\n  delete mutateableDoc._rev_tree;\n  return stringMd5(JSON.stringify(mutateableDoc));\n}\n\nvar uuid = v4; // mimic old import, only v4 is ever used elsewhere\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// `findPathToLeaf()` returns an array of revs that goes from the specified\n// leaf rev to the root of that leaf’s branch.\n//\n// eg. for this rev tree:\n// 1-9692 ▶ 2-37aa ▶ 3-df22 ▶ 4-6e94 ▶ 5-df4a ▶ 6-6a3a ▶ 7-57e5\n//          ┃                 ┗━━━━━━▶ 5-8d8c ▶ 6-65e0\n//          ┗━━━━━━▶ 3-43f6 ▶ 4-a3b4\n//\n// For a `targetRev` of '7-57e5', `findPathToLeaf()` would return ['7-57e5', '6-6a3a', '5-df4a']\n// The `revs` arument has the same structure as what `revs_tree` has on e.g.\n// the IndexedDB representation of the rev tree datastructure. Please refer to\n// tests/unit/test.purge.js for examples of what these look like.\n//\n// This function will throw an error if:\n// - The requested revision does not exist\n// - The requested revision is not a leaf\nfunction findPathToLeaf(revs, targetRev) {\n  let path = [];\n  const toVisit = revs.slice();\n\n  let node;\n  while ((node = toVisit.pop())) {\n    const { pos, ids: tree } = node;\n    const rev = `${pos}-${tree[0]}`;\n    const branches = tree[2];\n\n    // just assuming we're already working on the path up towards our desired leaf.\n    path.push(rev);\n\n    // we've reached the leaf of our dreams, so return the computed path.\n    if (rev === targetRev) {\n      //…unleeeeess\n      if (branches.length !== 0) {\n        throw new Error('The requested revision is not a leaf');\n      }\n      return path.reverse();\n    }\n\n    // this is based on the assumption that after we have a leaf (`branches.length == 0`), we handle the next\n    // branch. this is true for all branches other than the path leading to the winning rev (which is 7-57e5 in\n    // the example above. i've added a reset condition for branching nodes (`branches.length > 1`) as well.\n    if (branches.length === 0 || branches.length > 1) {\n      path = [];\n    }\n\n    // as a next step, we push the branches of this node to `toVisit` for visiting it during the next iteration\n    for (let i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: pos + 1, ids: branches[i] });\n    }\n  }\n  if (path.length === 0) {\n    throw new Error('The requested revision does not exist');\n  }\n  return path.reverse();\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nclass Changes$1 extends EE {\n  constructor(db, opts, callback) {\n    super();\n    this.db = db;\n    opts = opts ? clone(opts) : {};\n    var complete = opts.complete = once((err, resp) => {\n      if (err) {\n        if (listenerCount(this, 'error') > 0) {\n          this.emit('error', err);\n        }\n      } else {\n        this.emit('complete', resp);\n      }\n      this.removeAllListeners();\n      db.removeListener('destroyed', onDestroy);\n    });\n    if (callback) {\n      this.on('complete', function (resp) {\n        callback(null, resp);\n      });\n      this.on('error', callback);\n    }\n    const onDestroy = () => {\n      this.cancel();\n    };\n    db.once('destroyed', onDestroy);\n  \n    opts.onChange = (change, pending, lastSeq) => {\n      /* istanbul ignore if */\n      if (this.isCancelled) {\n        return;\n      }\n      tryCatchInChangeListener(this, change, pending, lastSeq);\n    };\n  \n    var promise = new Promise(function (fulfill, reject) {\n      opts.complete = function (err, res) {\n        if (err) {\n          reject(err);\n        } else {\n          fulfill(res);\n        }\n      };\n    });\n    this.once('cancel', function () {\n      db.removeListener('destroyed', onDestroy);\n      opts.complete(null, {status: 'cancelled'});\n    });\n    this.then = promise.then.bind(promise);\n    this['catch'] = promise['catch'].bind(promise);\n    this.then(function (result) {\n      complete(null, result);\n    }, complete);\n  \n  \n  \n    if (!db.taskqueue.isReady) {\n      db.taskqueue.addTask((failed) => {\n        if (failed) {\n          opts.complete(failed);\n        } else if (this.isCancelled) {\n          this.emit('cancel');\n        } else {\n          this.validateChanges(opts);\n        }\n      });\n    } else {\n      this.validateChanges(opts);\n    }\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    if (this.db.taskqueue.isReady) {\n      this.emit('cancel');\n    }\n  }\n\n  validateChanges(opts) {\n    var callback = opts.complete;\n  \n    /* istanbul ignore else */\n    if (PouchDB._changesFilterPlugin) {\n      PouchDB._changesFilterPlugin.validate(opts, (err) => {\n        if (err) {\n          return callback(err);\n        }\n        this.doChanges(opts);\n      });\n    } else {\n      this.doChanges(opts);\n    }\n  }\n\n  doChanges(opts) {\n    var callback = opts.complete;\n  \n    opts = clone(opts);\n    if ('live' in opts && !('continuous' in opts)) {\n      opts.continuous = opts.live;\n    }\n    opts.processChange = processChange;\n  \n    if (opts.since === 'latest') {\n      opts.since = 'now';\n    }\n    if (!opts.since) {\n      opts.since = 0;\n    }\n    if (opts.since === 'now') {\n      this.db.info().then((info) => {\n        /* istanbul ignore if */\n        if (this.isCancelled) {\n          callback(null, {status: 'cancelled'});\n          return;\n        }\n        opts.since = info.update_seq;\n        this.doChanges(opts);\n      }, callback);\n      return;\n    }\n  \n    /* istanbul ignore else */\n    if (PouchDB._changesFilterPlugin) {\n      PouchDB._changesFilterPlugin.normalize(opts);\n      if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n        return PouchDB._changesFilterPlugin.filter(this, opts);\n      }\n    } else {\n      ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n        if (key in opts) {\n          guardedConsole('warn',\n            'The \"' + key + '\" option was passed in to changes/replicate, ' +\n            'but pouchdb-changes-filter plugin is not installed, so it ' +\n            'was ignored. Please install the plugin to enable filtering.'\n          );\n        }\n      });\n    }\n  \n    if (!('descending' in opts)) {\n      opts.descending = false;\n    }\n  \n    // 0 and 1 should return 1 document\n    opts.limit = opts.limit === 0 ? 1 : opts.limit;\n    opts.complete = callback;\n    var newPromise = this.db._changes(opts);\n    /* istanbul ignore else */\n    if (newPromise && typeof newPromise.cancel === 'function') {\n      const cancel = this.cancel;\n      this.cancel = (...args) => {\n        newPromise.cancel();\n        cancel.apply(this, args);\n      };\n    }\n  }\n}\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      immediate(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction appendPurgeSeq(db, docId, rev) {\n  return db.get('_local/purges').then(function (doc) {\n    const purgeSeq = doc.purgeSeq + 1;\n    doc.purges.push({\n      docId,\n      rev,\n      purgeSeq,\n    });\n    if (doc.purges.length > self.purged_infos_limit) {\n      doc.purges.splice(0, doc.purges.length - self.purged_infos_limit);\n    }\n    doc.purgeSeq = purgeSeq;\n    return doc;\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return {\n      _id: '_local/purges',\n      purges: [{\n        docId,\n        rev,\n        purgeSeq: 0,\n      }],\n      purgeSeq: 0,\n    };\n  }).then(function (doc) {\n    return db.put(doc);\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\nclass AbstractPouchDB extends EE {\n  _setup() {\n    this.post = adapterFun('post', function (doc, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object' || Array.isArray(doc)) {\n        return callback(createError(NOT_AN_OBJECT));\n      }\n      this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n    }).bind(this);\n\n    this.put = adapterFun('put', function (doc, opts, cb) {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object' || Array.isArray(doc)) {\n        return cb(createError(NOT_AN_OBJECT));\n      }\n      invalidIdError(doc._id);\n      if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n        if (doc._deleted) {\n          return this._removeLocal(doc, cb);\n        } else {\n          return this._putLocal(doc, cb);\n        }\n      }\n\n      const putDoc = (next) => {\n        if (typeof this._put === 'function' && opts.new_edits !== false) {\n          this._put(doc, opts, next);\n        } else {\n          this.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n        }\n      };\n\n      if (opts.force && doc._rev) {\n        transformForceOptionToNewEditsOption();\n        putDoc(function (err) {\n          var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n          cb(err, result);\n        });\n      } else {\n        putDoc(cb);\n      }\n\n      function transformForceOptionToNewEditsOption() {\n        var parts = doc._rev.split('-');\n        var oldRevId = parts[1];\n        var oldRevNum = parseInt(parts[0], 10);\n\n        var newRevNum = oldRevNum + 1;\n        var newRevId = rev$$1();\n\n        doc._revisions = {\n          start: newRevNum,\n          ids: [newRevId, oldRevId]\n        };\n        doc._rev = newRevNum + '-' + newRevId;\n        opts.new_edits = false;\n      }\n    }).bind(this);\n\n    this.putAttachment = adapterFun('putAttachment', function (docId, attachmentId, rev, blob, type) {\n      var api = this;\n      if (typeof type === 'function') {\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n      // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n      /* istanbul ignore if */\n      if (typeof type === 'undefined') {\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n      if (!type) {\n        guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n      }\n\n      function createAttachment(doc) {\n        var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n        doc._attachments = doc._attachments || {};\n        doc._attachments[attachmentId] = {\n          content_type: type,\n          data: blob,\n          revpos: ++prevrevpos\n        };\n        return api.put(doc);\n      }\n\n      return api.get(docId).then(function (doc) {\n        if (doc._rev !== rev) {\n          throw createError(REV_CONFLICT);\n        }\n\n        return createAttachment(doc);\n      }, function (err) {\n        // create new doc\n        /* istanbul ignore else */\n        if (err.reason === MISSING_DOC.message) {\n          return createAttachment({_id: docId});\n        } else {\n          throw err;\n        }\n      });\n    }).bind(this);\n\n    this.removeAttachment = adapterFun('removeAttachment', function (docId, attachmentId, rev, callback) {\n      this.get(docId, (err, obj) => {\n        /* istanbul ignore if */\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (obj._rev !== rev) {\n          callback(createError(REV_CONFLICT));\n          return;\n        }\n        /* istanbul ignore if */\n        if (!obj._attachments) {\n          return callback();\n        }\n        delete obj._attachments[attachmentId];\n        if (Object.keys(obj._attachments).length === 0) {\n          delete obj._attachments;\n        }\n        this.put(obj, callback);\n      });\n    }).bind(this);\n\n    this.remove = adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n      var doc;\n      if (typeof optsOrRev === 'string') {\n        // id, rev, opts, callback style\n        doc = {\n          _id: docOrId,\n          _rev: optsOrRev\n        };\n        if (typeof opts === 'function') {\n          callback = opts;\n          opts = {};\n        }\n      } else {\n        // doc, opts, callback style\n        doc = docOrId;\n        if (typeof optsOrRev === 'function') {\n          callback = optsOrRev;\n          opts = {};\n        } else {\n          callback = opts;\n          opts = optsOrRev;\n        }\n      }\n      opts = opts || {};\n      opts.was_delete = true;\n      var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n      newDoc._deleted = true;\n      if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n        return this._removeLocal(doc, callback);\n      }\n      this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n    }).bind(this);\n\n    this.revsDiff = adapterFun('revsDiff', function (req, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      var ids = Object.keys(req);\n\n      if (!ids.length) {\n        return callback(null, {});\n      }\n\n      var count = 0;\n      var missing = new ExportedMap();\n\n      function addToMissing(id, revId) {\n        if (!missing.has(id)) {\n          missing.set(id, {missing: []});\n        }\n        missing.get(id).missing.push(revId);\n      }\n\n      function processDoc(id, rev_tree) {\n        // Is this fast enough? Maybe we should switch to a set simulated by a map\n        var missingForId = req[id].slice(0);\n        traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n          opts) {\n            var rev = pos + '-' + revHash;\n            var idx = missingForId.indexOf(rev);\n            if (idx === -1) {\n              return;\n            }\n\n            missingForId.splice(idx, 1);\n            /* istanbul ignore if */\n            if (opts.status !== 'available') {\n              addToMissing(id, rev);\n            }\n          });\n\n        // Traversing the tree is synchronous, so now `missingForId` contains\n        // revisions that were not found in the tree\n        missingForId.forEach(function (rev) {\n          addToMissing(id, rev);\n        });\n      }\n\n      ids.map(function (id) {\n        this._getRevisionTree(id, function (err, rev_tree) {\n          if (err && err.status === 404 && err.message === 'missing') {\n            missing.set(id, {missing: req[id]});\n          } else if (err) {\n            /* istanbul ignore next */\n            return callback(err);\n          } else {\n            processDoc(id, rev_tree);\n          }\n\n          if (++count === ids.length) {\n            // convert LazyMap to object\n            var missingObj = {};\n            missing.forEach(function (value, key) {\n              missingObj[key] = value;\n            });\n            return callback(null, missingObj);\n          }\n        });\n      }, this);\n    }).bind(this);\n\n    // _bulk_get API for faster replication, as described in\n    // https://github.com/apache/couchdb-chttpd/pull/33\n    // At the \"abstract\" level, it will just run multiple get()s in\n    // parallel, because this isn't much of a performance cost\n    // for local databases (except the cost of multiple transactions, which is\n    // small). The http adapter overrides this in order\n    // to do a more efficient single HTTP request.\n    this.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n      bulkGet(this, opts, callback);\n    }).bind(this);\n\n    // compact one document and fire callback\n    // by compacting we mean removing all revisions which\n    // are further from the leaf in revision tree than max_height\n    this.compactDocument = adapterFun('compactDocument', function (docId, maxHeight, callback) {\n      this._getRevisionTree(docId, (err, revTree) => {\n        /* istanbul ignore if */\n        if (err) {\n          return callback(err);\n        }\n        var height = computeHeight(revTree);\n        var candidates = [];\n        var revs = [];\n        Object.keys(height).forEach(function (rev) {\n          if (height[rev] > maxHeight) {\n            candidates.push(rev);\n          }\n        });\n\n        traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n            revs.push(rev);\n          }\n        });\n        this._doCompaction(docId, revs, callback);\n      });\n    }).bind(this);\n\n    // compact the whole database using single document\n    // compaction\n    this.compact = adapterFun('compact', function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      this._compactionQueue = this._compactionQueue || [];\n      this._compactionQueue.push({opts: opts, callback: callback});\n      if (this._compactionQueue.length === 1) {\n        doNextCompaction(this);\n      }\n    }).bind(this);\n\n    /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\n    this.get = adapterFun('get', function (id, opts, cb) {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof id !== 'string') {\n        return cb(createError(INVALID_ID));\n      }\n      if (isLocalId(id) && typeof this._getLocal === 'function') {\n        return this._getLocal(id, cb);\n      }\n      var leaves = [];\n\n      const finishOpenRevs = () => {\n        var result = [];\n        var count = leaves.length;\n        /* istanbul ignore if */\n        if (!count) {\n          return cb(null, result);\n        }\n\n        // order with open_revs is unspecified\n        leaves.forEach((leaf) => {\n          this.get(id, {\n            rev: leaf,\n            revs: opts.revs,\n            latest: opts.latest,\n            attachments: opts.attachments,\n            binary: opts.binary\n          }, function (err, doc) {\n            if (!err) {\n              // using latest=true can produce duplicates\n              var existing;\n              for (var i = 0, l = result.length; i < l; i++) {\n                if (result[i].ok && result[i].ok._rev === doc._rev) {\n                  existing = true;\n                  break;\n                }\n              }\n              if (!existing) {\n                result.push({ok: doc});\n              }\n            } else {\n              result.push({missing: leaf});\n            }\n            count--;\n            if (!count) {\n              cb(null, result);\n            }\n          });\n        });\n      };\n\n      if (opts.open_revs) {\n        if (opts.open_revs === \"all\") {\n          this._getRevisionTree(id, function (err, rev_tree) {\n            /* istanbul ignore if */\n            if (err) {\n              return cb(err);\n            }\n            leaves = collectLeaves(rev_tree).map(function (leaf) {\n              return leaf.rev;\n            });\n            finishOpenRevs();\n          });\n        } else {\n          if (Array.isArray(opts.open_revs)) {\n            leaves = opts.open_revs;\n            for (var i = 0; i < leaves.length; i++) {\n              var l = leaves[i];\n              // looks like it's the only thing couchdb checks\n              if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n                return cb(createError(INVALID_REV));\n              }\n            }\n            finishOpenRevs();\n          } else {\n            return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n          }\n        }\n        return; // open_revs does not like other options\n      }\n\n      return this._get(id, opts, (err, result) => {\n        if (err) {\n          err.docId = id;\n          return cb(err);\n        }\n\n        var doc = result.doc;\n        var metadata = result.metadata;\n        var ctx = result.ctx;\n\n        if (opts.conflicts) {\n          var conflicts = collectConflicts(metadata);\n          if (conflicts.length) {\n            doc._conflicts = conflicts;\n          }\n        }\n\n        if (isDeleted(metadata, doc._rev)) {\n          doc._deleted = true;\n        }\n\n        if (opts.revs || opts.revs_info) {\n          var splittedRev = doc._rev.split('-');\n          var revNo       = parseInt(splittedRev[0], 10);\n          var revHash     = splittedRev[1];\n\n          var paths = rootToLeaf(metadata.rev_tree);\n          var path = null;\n\n          for (var i = 0; i < paths.length; i++) {\n            var currentPath = paths[i];\n            var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n              .indexOf(revHash);\n            var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n            if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n              path = currentPath;\n            }\n          }\n\n          /* istanbul ignore if */\n          if (!path) {\n            err = new Error('invalid rev tree');\n            err.docId = id;\n            return cb(err);\n          }\n\n          var indexOfRev = path.ids.map(function (x) { return x.id; })\n            .indexOf(doc._rev.split('-')[1]) + 1;\n          var howMany = path.ids.length - indexOfRev;\n          path.ids.splice(indexOfRev, howMany);\n          path.ids.reverse();\n\n          if (opts.revs) {\n            doc._revisions = {\n              start: (path.pos + path.ids.length) - 1,\n              ids: path.ids.map(function (rev) {\n                return rev.id;\n              })\n            };\n          }\n          if (opts.revs_info) {\n            var pos =  path.pos + path.ids.length;\n            doc._revs_info = path.ids.map(function (rev) {\n              pos--;\n              return {\n                rev: pos + '-' + rev.id,\n                status: rev.opts.status\n              };\n            });\n          }\n        }\n\n        if (opts.attachments && doc._attachments) {\n          var attachments = doc._attachments;\n          var count = Object.keys(attachments).length;\n          if (count === 0) {\n            return cb(null, doc);\n          }\n          Object.keys(attachments).forEach((key) => {\n            this._getAttachment(doc._id, key, attachments[key], {\n              // Previously the revision handling was done in adapter.js\n              // getAttachment, however since idb-next doesnt we need to\n              // pass the rev through\n              rev: doc._rev,\n              binary: opts.binary,\n              ctx: ctx\n            }, function (err, data) {\n              var att = doc._attachments[key];\n              att.data = data;\n              delete att.stub;\n              delete att.length;\n              if (!--count) {\n                cb(null, doc);\n              }\n            });\n          });\n        } else {\n          if (doc._attachments) {\n            for (var key in doc._attachments) {\n              /* istanbul ignore else */\n              if (Object.prototype.hasOwnProperty.call(doc._attachments, key)) {\n                doc._attachments[key].stub = true;\n              }\n            }\n          }\n          cb(null, doc);\n        }\n      });\n    }).bind(this);\n\n    // TODO: I dont like this, it forces an extra read for every\n    // attachment read and enforces a confusing api between\n    // adapter.js and the adapter implementation\n    this.getAttachment = adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n      if (opts instanceof Function) {\n        callback = opts;\n        opts = {};\n      }\n      this._get(docId, opts, (err, res) => {\n        if (err) {\n          return callback(err);\n        }\n        if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n          opts.ctx = res.ctx;\n          opts.binary = true;\n          this._getAttachment(docId, attachmentId,\n                              res.doc._attachments[attachmentId], opts, callback);\n        } else {\n          return callback(createError(MISSING_DOC));\n        }\n      });\n    }).bind(this);\n\n    this.allDocs = adapterFun('allDocs', function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n      if (opts.start_key) {\n        opts.startkey = opts.start_key;\n      }\n      if (opts.end_key) {\n        opts.endkey = opts.end_key;\n      }\n      if ('keys' in opts) {\n        if (!Array.isArray(opts.keys)) {\n          return callback(new TypeError('options.keys must be an array'));\n        }\n        var incompatibleOpt =\n          ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n          return incompatibleOpt in opts;\n        })[0];\n        if (incompatibleOpt) {\n          callback(createError(QUERY_PARSE_ERROR,\n            'Query parameter `' + incompatibleOpt +\n            '` is not compatible with multi-get'\n          ));\n          return;\n        }\n        if (!isRemote(this)) {\n          allDocsKeysParse(opts);\n          if (opts.keys.length === 0) {\n            return this._allDocs({limit: 0}, callback);\n          }\n        }\n      }\n\n      return this._allDocs(opts, callback);\n    }).bind(this);\n\n    this.close = adapterFun('close', function (callback) {\n      this._closed = true;\n      this.emit('closed');\n      return this._close(callback);\n    }).bind(this);\n\n    this.info = adapterFun('info', function (callback) {\n      this._info((err, info) => {\n        if (err) {\n          return callback(err);\n        }\n        // assume we know better than the adapter, unless it informs us\n        info.db_name = info.db_name || this.name;\n        info.auto_compaction = !!(this.auto_compaction && !isRemote(this));\n        info.adapter = this.adapter;\n        callback(null, info);\n      });\n    }).bind(this);\n\n    this.id = adapterFun('id', function (callback) {\n      return this._id(callback);\n    }).bind(this);\n\n    this.bulkDocs = adapterFun('bulkDocs', function (req, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      if (Array.isArray(req)) {\n        req = {\n          docs: req\n        };\n      }\n\n      if (!req || !req.docs || !Array.isArray(req.docs)) {\n        return callback(createError(MISSING_BULK_DOCS));\n      }\n\n      for (var i = 0; i < req.docs.length; ++i) {\n        if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n          return callback(createError(NOT_AN_OBJECT));\n        }\n      }\n\n      var attachmentError;\n      req.docs.forEach(function (doc) {\n        if (doc._attachments) {\n          Object.keys(doc._attachments).forEach(function (name) {\n            attachmentError = attachmentError || attachmentNameError(name);\n            if (!doc._attachments[name].content_type) {\n              guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n            }\n          });\n        }\n      });\n\n      if (attachmentError) {\n        return callback(createError(BAD_REQUEST, attachmentError));\n      }\n\n      if (!('new_edits' in opts)) {\n        if ('new_edits' in req) {\n          opts.new_edits = req.new_edits;\n        } else {\n          opts.new_edits = true;\n        }\n      }\n\n      var adapter = this;\n      if (!opts.new_edits && !isRemote(adapter)) {\n        // ensure revisions of the same doc are sorted, so that\n        // the local adapter processes them correctly (#2935)\n        req.docs.sort(compareByIdThenRev);\n      }\n\n      cleanDocs(req.docs);\n\n      // in the case of conflicts, we want to return the _ids to the user\n      // however, the underlying adapter may destroy the docs array, so\n      // create a copy here\n      var ids = req.docs.map(function (doc) {\n        return doc._id;\n      });\n\n      this._bulkDocs(req, opts, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n        if (!opts.new_edits) {\n          // this is what couch does when new_edits is false\n          res = res.filter(function (x) {\n            return x.error;\n          });\n        }\n        // add ids for error/conflict responses (not required for CouchDB)\n        if (!isRemote(adapter)) {\n          for (var i = 0, l = res.length; i < l; i++) {\n            res[i].id = res[i].id || ids[i];\n          }\n        }\n\n        callback(null, res);\n      });\n    }).bind(this);\n\n    this.registerDependentDatabase = adapterFun('registerDependentDatabase', function (dependentDb, callback) {\n      var dbOptions = clone(this.__opts);\n      if (this.__opts.view_adapter) {\n        dbOptions.adapter = this.__opts.view_adapter;\n      }\n\n      var depDB = new this.constructor(dependentDb, dbOptions);\n\n      function diffFun(doc) {\n        doc.dependentDbs = doc.dependentDbs || {};\n        if (doc.dependentDbs[dependentDb]) {\n          return false; // no update required\n        }\n        doc.dependentDbs[dependentDb] = true;\n        return doc;\n      }\n      upsert(this, '_local/_pouch_dependentDbs', diffFun).then(function () {\n        callback(null, {db: depDB});\n      }).catch(callback);\n    }).bind(this);\n\n    this.destroy = adapterFun('destroy', function (opts, callback) {\n\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      var usePrefix = 'use_prefix' in this ? this.use_prefix : true;\n\n      const destroyDb = () => {\n        // call destroy method of the particular adaptor\n        this._destroy(opts, (err, resp) => {\n          if (err) {\n            return callback(err);\n          }\n          this._destroyed = true;\n          this.emit('destroyed');\n          callback(null, resp || { 'ok': true });\n        });\n      };\n\n      if (isRemote(this)) {\n        // no need to check for dependent DBs if it's a remote DB\n        return destroyDb();\n      }\n\n      this.get('_local/_pouch_dependentDbs', (err, localDoc) => {\n        if (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            return callback(err);\n          } else { // no dependencies\n            return destroyDb();\n          }\n        }\n        var dependentDbs = localDoc.dependentDbs;\n        var PouchDB = this.constructor;\n        var deletedMap = Object.keys(dependentDbs).map((name) => {\n          // use_prefix is only false in the browser\n          /* istanbul ignore next */\n          var trueName = usePrefix ?\n            name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n          return new PouchDB(trueName, this.__opts).destroy();\n        });\n        Promise.all(deletedMap).then(destroyDb, callback);\n      });\n    }).bind(this);\n  }\n\n  _compact(opts, callback) {\n    var changesOpts = {\n      return_docs: false,\n      last_seq: opts.last_seq || 0\n    };\n    var promises = [];\n\n    var taskId;\n    var compactedDocs = 0;\n\n    const onChange = (row) => {\n      this.activeTasks.update(taskId, {\n        completed_items: ++compactedDocs\n      });\n      promises.push(this.compactDocument(row.id, 0));\n    };\n    const onError = (err) => {\n      this.activeTasks.remove(taskId, err);\n      callback(err);\n    };\n    const onComplete = (resp) => {\n      var lastSeq = resp.last_seq;\n      Promise.all(promises).then(() => {\n        return upsert(this, '_local/compaction', (doc) => {\n          if (!doc.last_seq || doc.last_seq < lastSeq) {\n            doc.last_seq = lastSeq;\n            return doc;\n          }\n          return false; // somebody else got here first, don't update\n        });\n      }).then(() => {\n        this.activeTasks.remove(taskId);\n        callback(null, {ok: true});\n      }).catch(onError);\n    };\n\n    this.info().then((info) => {\n      taskId = this.activeTasks.add({\n        name: 'database_compaction',\n        total_items: info.update_seq - changesOpts.last_seq,\n      });\n\n      this.changes(changesOpts)\n        .on('change', onChange)\n        .on('complete', onComplete)\n        .on('error', onError);\n    });\n  }\n\n  changes(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    opts = opts || {};\n\n    // By default set return_docs to false if the caller has opts.live = true,\n    // this will prevent us from collecting the set of changes indefinitely\n    // resulting in growing memory\n    opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;\n\n    return new Changes$1(this, opts, callback);\n  }\n\n  type() {\n    return (typeof this._type === 'function') ? this._type() : this.adapter;\n  }\n}\n\n// The abstract purge implementation expects a doc id and the rev of a leaf node in that doc.\n// It will return errors if the rev doesn’t exist or isn’t a leaf.\nAbstractPouchDB.prototype.purge = adapterFun('_purge', function (docId, rev, callback) {\n  if (typeof this._purge === 'undefined') {\n    return callback(createError(UNKNOWN_ERROR, 'Purge is not implemented in the ' + this.adapter + ' adapter.'));\n  }\n  var self = this;\n\n  self._getRevisionTree(docId, (error, revs) => {\n    if (error) {\n      return callback(error);\n    }\n    if (!revs) {\n      return callback(createError(MISSING_DOC));\n    }\n    let path;\n    try {\n      path = findPathToLeaf(revs, rev);\n    } catch (error) {\n      return callback(error.message || error);\n    }\n    self._purge(docId, path, (error, result) => {\n      if (error) {\n        return callback(error);\n      } else {\n        appendPurgeSeq(self, docId, rev).then(function () {\n          return callback(null, result);\n        });\n      }\n    });\n  });\n});\n\nclass TaskQueue {\n  constructor() {\n    this.isReady = false;\n    this.failed = false;\n    this.queue = [];\n  }\n\n  execute() {\n    var fun;\n    if (this.failed) {\n      while ((fun = this.queue.shift())) {\n        fun(this.failed);\n      }\n    } else {\n      while ((fun = this.queue.shift())) {\n        fun();\n      }\n    }\n  }\n\n  fail(err) {\n    this.failed = err;\n    this.execute();\n  }\n\n  ready(db) {\n    this.isReady = true;\n    this.db = db;\n    this.execute();\n  }\n\n  addTask(fun) {\n    this.queue.push(fun);\n    if (this.failed) {\n      this.execute();\n    }\n  }\n}\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\nfunction inherits(A, B) {\n  A.prototype = Object.create(B.prototype, {\n    constructor: { value: A }\n  });\n}\n\nfunction createClass(parent, init) {\n  let klass = function (...args) {\n    if (!(this instanceof klass)) {\n      return new klass(...args);\n    }\n    init.apply(this, args);\n  };\n  inherits(klass, parent);\n  return klass;\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\nclass PouchInternal extends AbstractPouchDB {\n  constructor(name, opts) {\n    super();\n    this._setup(name, opts);\n  }\n\n  _setup(name, opts) {\n    super._setup();\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    if (opts.deterministic_revs === undefined) {\n      opts.deterministic_revs = true;\n    }\n\n    this.__opts = opts = clone(opts);\n\n    this.auto_compaction = opts.auto_compaction;\n    this.purged_infos_limit = opts.purged_infos_limit || 1000;\n    this.prefix = PouchDB.prefix;\n\n    if (typeof name !== 'string') {\n      throw new Error('Missing/invalid DB name');\n    }\n\n    var prefixedName = (opts.prefix || '') + name;\n    var backend = parseAdapter(prefixedName, opts);\n\n    opts.name = backend.name;\n    opts.adapter = opts.adapter || backend.adapter;\n\n    this.name = name;\n    this._adapter = opts.adapter;\n    PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n    if (!PouchDB.adapters[opts.adapter] ||\n        !PouchDB.adapters[opts.adapter].valid()) {\n      throw new Error('Invalid Adapter: ' + opts.adapter);\n    }\n\n    if (opts.view_adapter) {\n      if (!PouchDB.adapters[opts.view_adapter] ||\n          !PouchDB.adapters[opts.view_adapter].valid()) {\n        throw new Error('Invalid View Adapter: ' + opts.view_adapter);\n      }\n    }\n\n    this.taskqueue = new TaskQueue();\n\n    this.adapter = opts.adapter;\n\n    PouchDB.adapters[opts.adapter].call(this, opts, (err) => {\n      if (err) {\n        return this.taskqueue.fail(err);\n      }\n      prepareForDestruction(this);\n\n      this.emit('created', this);\n      PouchDB.emit('created', this.name);\n      this.taskqueue.ready(this);\n    });\n  }\n}\n\nconst PouchDB = createClass(PouchInternal, function (name, opts) {\n  PouchInternal.prototype._setup.call(this, name, opts);\n});\n\n// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f$1 = fetch;\nvar h = Headers;\n\nclass ActiveTasks {\n  constructor() {\n    this.tasks = {};\n  }\n\n  list() {\n    return Object.values(this.tasks);\n  }\n\n  add(task) {\n    const id = v4();\n    this.tasks[id] = {\n      id,\n      name: task.name,\n      total_items: task.total_items,\n      created_at: new Date().toJSON()\n    };\n    return id;\n  }\n\n  get(id) {\n    return this.tasks[id];\n  }\n\n  /* eslint-disable no-unused-vars */\n  remove(id, reason) {\n    delete this.tasks[id];\n    return this.tasks;\n  }\n\n  update(id, updatedTask) {\n    const task = this.tasks[id];\n    if (typeof task !== 'undefined') {\n      const mergedTask = {\n        id: task.id,\n        name: task.name,\n        created_at: task.created_at,\n        total_items: updatedTask.total_items || task.total_items,\n        completed_items: updatedTask.completed_items || task.completed_items,\n        updated_at: new Date().toJSON()\n      };\n      this.tasks[id] = mergedTask;\n    }\n    return this.tasks;\n  }\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new EE();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(EE.prototype).forEach(function (key) {\n    if (typeof EE.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  let PouchWithDefaults = createClass(PouchDB, function (name, opts) {\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchWithDefaults.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  });\n\n  PouchWithDefaults.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchWithDefaults)) {\n      PouchWithDefaults[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchWithDefaults.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchWithDefaults;\n};\n\nPouchDB.fetch = function (url, opts) {\n  return f$1(url, opts);\n};\n\nPouchDB.prototype.activeTasks = PouchDB.activeTasks = new ActiveTasks();\n\n// managed automatically by set-version.js\nvar version = \"8.0.1\";\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (i > 0 && fieldName[i - 1] === '\\\\' && (ch === '$' || ch === '.')) {\n      // escaped delimiter\n      current = current.substring(0, current.length - 1) + ch;\n    } else if (ch === '.') {\n      // When `.` is not escaped (above), it is a field delimiter\n      fields.push(current);\n      current = '';\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  var first = {$or: true, $nor: true};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        // or, nor\n        if (matcher instanceof Array) {\n          if (first[field]) {\n            first[field] = false;\n            res[field] = matcher;\n            return;\n          }\n\n          var entries = [];\n          res[field].forEach(function (existing) {\n            Object.keys(matcher).forEach(function (key) {\n              var m = matcher[key];\n              var longest = Math.max(Object.keys(existing).length, Object.keys(m).length);\n              var merged = mergeAndedSelectors([existing, m]);\n              if (Object.keys(merged).length <= longest) {\n                // we have a situation like: (a :{$eq :1} || ...) && (a {$eq: 2} || ...)\n                // merging would produce a $eq 2 when actually we shouldn't ever match against these merged conditions\n                // merged should always contain more values to be valid\n                return;\n              }\n              entries.push(merged);\n            });\n          });\n          res[field] = entries;\n        } else {\n          // not\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          } else if (operator === \"$regex\") {\n            return mergeRegex(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// combine $regex values into one array\nfunction mergeRegex(value, fieldMatchers) {\n  if ('$regex' in fieldMatchers) {\n    // a value could match multiple regexes\n    fieldMatchers.$regex.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$regex = [value];\n  }\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n    for (var prop in obj) {\n        if (Array.isArray(obj)) {\n            for (var i in obj) {\n                if (obj[i]['$and']) {\n                    obj[i] = mergeAndedSelectors(obj[i]['$and']);\n                }\n            }\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            mergeAndedSelectorsNested(value); // <- recursive call\n        }\n    }\n    return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n    for (var prop in obj) {\n        if (prop === '$and') {\n            isAnd = true;\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            isAnd = isAndInSelector(value, isAnd); // <- recursive call\n        }\n    }\n    return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n\n  //#7458: if $and is present in selector (at any level) merge nested $and\n  if (isAndInSelector(result, false)) {\n    result = mergeAndedSelectorsNested(result);\n    if ('$and' in result) {\n      result = mergeAndedSelectors(result['$and']);\n    }\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    }\n    result[field] = matcher;\n  }\n\n  normalizeArrayOperators(result);\n\n  return result;\n}\n\n//\n// The $ne and $regex values must be placed in an array because these operators can be used multiple times on the same field.\n// When $and is used, mergeAndedSelectors takes care of putting some of them into arrays, otherwise it's done here.\n//\nfunction normalizeArrayOperators(selector) {\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n\n    if (Array.isArray(matcher)) {\n      matcher.forEach(function (matcherItem) {\n        if (matcherItem && typeof matcherItem === 'object') {\n          normalizeArrayOperators(matcherItem);\n        }\n      });\n    } else if (field === '$ne') {\n      selector.$ne = [matcher];\n    } else if (field === '$regex') {\n      selector.$regex = [matcher];\n    } else if (matcher && typeof matcher === 'object') {\n      normalizeArrayOperators(matcher);\n    }\n  });\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging\n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (Object.prototype.hasOwnProperty.call(origKey, k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (maybeUserOperator) {\n      var userValue = matcher[ maybeUserOperator ];\n      // explicit operator\n      if (maybeUserOperator.indexOf(\"$\") === 0) {\n        return match(maybeUserOperator, doc, userValue, parsedField, docFieldValue);\n      } else {\n        var subParsedField = parseField(maybeUserOperator);\n\n        if (\n          docFieldValue === undefined &&\n          typeof userValue !== \"object\" &&\n          subParsedField.length > 0\n        ) {\n          // the field does not exist, return or getFieldFromDoc will throw\n          return false;\n        }\n\n        var subDocFieldValue = getFieldFromDoc(docFieldValue, subParsedField);\n\n        if (typeof userValue === \"object\") {\n          // field value is an object that might contain more operators\n          return matchSelector(userValue, doc, parsedField, subDocFieldValue);\n        }\n\n        // implicit operator\n        return match(\"$eq\", doc, userValue, subParsedField, subDocFieldValue);\n      }\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    /* istanbul ignore next */\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  if (typeof docFieldValue !== \"number\" ||\n    parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  var divisor = userValue[0];\n  var mod = userValue[1];\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.some(function (docFieldValueItem) {\n        return collate(val, docFieldValueItem) === 0;\n      });\n    }\n\n    return collate(val, docFieldValue) === 0;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.some(function (docFieldValueItem) {\n      return collate(val, docFieldValueItem) === 0;\n    });\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      Array.isArray(docFieldValue) &&\n      arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      typeof docFieldValue == \"string\" &&\n      userValue.every(function (regexValue) {\n        return regexMatch(docFieldValue, regexValue);\n      });\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_access',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  // replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up in the document\nvar dataWords = toObject([\n  '_access',\n  '_attachments',\n  // replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+-/.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev$$1(doc, dbOpts.deterministic_revs);\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (Object.prototype.hasOwnProperty.call(docInfo.data._attachments, key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return Promise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return Promise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new Promise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  if (batchSize === -1) {\n    batchSize = 1000;\n  }\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange ; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result) || {};\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new Promise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    req.onerror = txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      immediate(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return Promise.reject(filtered);\n      }\n\n      if (!filtered) {\n        return Promise.resolve();\n      }\n      numResults++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n      // process the attachment immediately\n      // for the benefit of live listeners\n      if (opts.attachments && opts.include_docs) {\n        return new Promise(function (resolve) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              resolve(change);\n            });\n          });\n        });\n      } else {\n        return Promise.resolve(change);\n      }\n    }\n\n    function onBatchDone() {\n      var promises = [];\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));\n      }\n\n      Promise.all(promises).then(function (changes) {\n        for (var i = 0, len = changes.length; i < len; i++) {\n          if (changes[i]) {\n            opts.onChange(changes[i]);\n          }\n        }\n      }).catch(opts.complete);\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  var idbGlobalFailureError = null;\n  api._meta = null;\n\n  function enrichCallbackError(callback) {\n    return function (error, result) {\n      if (error && error instanceof Error && !error.reason) {\n        if (idbGlobalFailureError) {\n          error.reason = idbGlobalFailureError;\n        }\n      }\n\n      callback(error, result);\n    };\n  }\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, enrichCallbackError(callback));\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, enrichCallbackError(callback));\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return immediate(function () {\n      callback(null, api);\n    });\n  }\n\n  var req = indexedDB.open(dbName, ADAPTER_VERSION);\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idbGlobalFailureError = e.target.error;\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function (e) {\n    var msg = e.target.error && e.target.error.message;\n\n    if (!msg) {\n      msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    } else if (msg.indexOf(\"stored database is a higher version\") !== -1) {\n      msg = new Error('This DB was created with the newer \"indexeddb\" adapter, but you are trying to open it with the older \"idb\" adapter');\n    }\n\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Following #7085 buggy idb versions (typically Safari < 10.1) are\n  // considered valid.\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new Promise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nconst CHANGES_BATCH_SIZE = 25;\nconst MAX_SIMULTANEOUS_REVS = 50;\nconst CHANGES_TIMEOUT_BUFFER = 5000;\nconst DEFAULT_HEARTBEAT = 10000;\n\nlet supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  let doc = row.doc || row.ok;\n  let atts = doc && doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    let att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$1(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return Promise.resolve();\n  }\n\n  return Promise.all(Object.keys(doc._attachments).map(function (key) {\n    let attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new Promise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n  let protocol = parseUri(opts.prefix).protocol;\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    let dbName = opts.name.substr(opts.prefix.length);\n    // Ensure prefix has a trailing slash\n    let prefix = opts.prefix.replace(/\\/?$/, '/');\n    name = prefix + encodeURIComponent(dbName);\n  }\n\n  let uri = parseUri(name);\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  let parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  let pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\nfunction shouldCacheBust(opts) {\n  let ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?\n      navigator.userAgent.toLowerCase() : '';\n  let isIE = ua.indexOf('msie') !== -1;\n  let isTrident = ua.indexOf('trident') !== -1;\n  let isEdge = ua.indexOf('edge') !== -1;\n  let isGET = !('method' in opts) || opts.method === 'GET';\n  return (isIE || isTrident || isEdge) && isGET;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  let api = this;\n\n  let host = getHost(opts.name, opts);\n  let dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n\n  const ourFetch = async function (url, options) {\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    options.credentials = 'include';\n\n    if (opts.auth || host.auth) {\n      let nAuth = opts.auth || host.auth;\n      let str = nAuth.username + ':' + nAuth.password;\n      let token = thisBtoa(unescape(encodeURIComponent(str)));\n      options.headers.set('Authorization', 'Basic ' + token);\n    }\n\n    let headers = opts.headers || {};\n    Object.keys(headers).forEach(function (key) {\n      options.headers.append(key, headers[key]);\n    });\n\n    /* istanbul ignore if */\n    if (shouldCacheBust(options)) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();\n    }\n\n    let fetchFun = opts.fetch || f$1;\n    return await fetchFun(url, options);\n  };\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, function (...args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        let callback = args.pop();\n        callback(e);\n      });\n    }).bind(api);\n  }\n\n  async function fetchJSON(url, options) {\n\n    let result = {};\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (!options.headers.get('Content-Type')) {\n      options.headers.set('Content-Type', 'application/json');\n    }\n    if (!options.headers.get('Accept')) {\n      options.headers.set('Accept', 'application/json');\n    }\n\n    const response = await ourFetch(url, options);\n    result.ok = response.ok;\n    result.status = response.status;\n    const json = await response.json();\n\n    result.data = json;\n    if (!result.ok) {\n      result.data.status = result.status;\n      let err = generateErrorFromResponse(result.data);\n      throw err;\n    }\n\n    if (Array.isArray(result.data)) {\n      result.data = result.data.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n\n    return result;\n  }\n\n  let setupPromise;\n\n  async function setup() {\n    if (opts.skip_setup) {\n      return Promise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    setupPromise = fetchJSON(dbUrl).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return fetchJSON(dbUrl, {method: 'PUT'});\n      } else {\n        return Promise.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return Promise.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  immediate(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', async function (callback) {\n    let result;\n    try {\n      const response = await ourFetch(genUrl(host, ''));\n      result = await response.json();\n    } catch (err) {\n      result = {};\n    }\n\n    // Bad response or missing `uuid` should not prevent ID generation.\n    let uuid$$1 = (result && result.uuid) ? (result.uuid + host.db) : genDBUrl(host, '');\n    callback(null, uuid$$1);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', async function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    await fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'});\n\n    function ping() {\n      api.info(function (err, res) {\n        // CouchDB may send a \"compact_running:true\" if it's\n        // already compacting. PouchDB Server doesn't.\n        /* istanbul ignore else */\n        if (res && !res.compact_running) {\n          callback(null, {ok: true});\n        } else {\n          setTimeout(ping, opts.interval || 200);\n        }\n      });\n    }\n    // Ping the http if it's finished compaction\n    ping();\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    let self = this;\n\n    async function doBulkGet(cb) {\n      let params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      try {\n        const result = await fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {\n          method: 'POST',\n          body: JSON.stringify({ docs: opts.docs})\n        });\n\n        if (opts.attachments && opts.binary) {\n          result.data.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(null, result.data);\n      } catch (error) {\n        cb(error);\n      }\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      let batchSize = MAX_SIMULTANEOUS_REVS;\n      let numBatches = Math.ceil(opts.docs.length / batchSize);\n      let numDone = 0;\n      let results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (let i = 0; i < numBatches; i++) {\n        let subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    let dbUrl = genUrl(host, '');\n    let supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = async function (callback) {\n    try {\n      await setup();\n      const response = await ourFetch(genDBUrl(host, ''));\n      const info = await response.json();\n      info.host = genDBUrl(host, '');\n      callback(null, info);\n    } catch (err) {\n      callback(err);\n    }\n  };\n\n  api.fetch = async function (path, options) {\n    await setup();\n    const url = path.substring(0, 1) === '/' ?\n    genUrl(host, path.substring(1)) :\n    genDBUrl(host, path);\n    return ourFetch(url, options);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', async function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    let params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    function fetchAttachments(doc) {\n      let atts = doc._attachments;\n      let filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      async function fetchData(filename) {\n        const att = atts[filename];\n        const path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n            '?rev=' + doc._rev;\n\n        const response = await ourFetch(genDBUrl(host, path));\n\n        let blob;\n        if ('buffer' in response) {\n          blob = await response.buffer();\n        } else {\n          /* istanbul ignore next */\n          blob = await response.blob();\n        }\n\n        let data;\n        if (opts.binary) {\n          let typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');\n          if (!typeFieldDescriptor || typeFieldDescriptor.set) {\n            blob.type = att.content_type;\n          }\n          data = blob;\n        } else {\n          data = await new Promise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }\n\n        delete att.stub;\n        delete att.length;\n        att.data = data;\n      }\n\n      let promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetchData(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return Promise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    const url = genDBUrl(host, id + paramsToStr(params));\n    try {\n      const res = await fetchJSON(url);\n      if (opts.attachments) {\n        await fetchAllAttachments(res.data);\n      }\n      callback(null, res.data);\n    } catch (error) {\n      error.docId = id;\n      callback(error);\n    }\n  });\n\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove', async function (docOrId, optsOrRev, opts, cb) {\n    let doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        cb = optsOrRev;\n        opts = {};\n      } else {\n        cb = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    const rev = (doc._rev || opts.rev);\n    const url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev;\n\n    try {\n      const result = await fetchJSON(url, {method: 'DELETE'});\n      cb(null, result.data);\n    } catch (error) {\n      cb(error);\n    }\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment = adapterFun$$1('getAttachment', async function (docId, attachmentId,\n                                                            opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    const params = opts.rev ? ('?rev=' + opts.rev) : '';\n    const url = genDBUrl(host, encodeDocId(docId)) + '/' +\n        encodeAttachmentId(attachmentId) + params;\n    let contentType;\n    try {\n      const response = await ourFetch(url, {method: 'GET'});\n\n      if (!response.ok) {\n        throw response;\n      }\n\n      contentType = response.headers.get('content-type');\n      let blob;\n      if (typeof process !== 'undefined' && !process.browser && typeof response.buffer === 'function') {\n        blob = await response.buffer();\n      } else {\n        /* istanbul ignore next */\n        blob = await response.blob();\n      }\n\n      // TODO: also remove\n      if (typeof process !== 'undefined' && !process.browser) {\n        var typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');\n        if (!typeFieldDescriptor || typeFieldDescriptor.set) {\n          blob.type = contentType;\n        }\n      }\n      callback(null, blob);\n    } catch (err) {\n      callback(err);\n    }\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =  adapterFun$$1('removeAttachment', async function (\n    docId,\n    attachmentId,\n    rev,\n    callback,\n  ) {\n    const url = genDBUrl(host, encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    try {\n      const result = await fetchJSON(url, {method: 'DELETE'});\n      callback(null, result.data);\n    } catch (error) {\n      callback(error);\n    }\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = adapterFun$$1('putAttachment', async function (\n    docId,\n    attachmentId,\n    rev,\n    blob,\n    type,\n    callback,\n  ) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    const id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    let url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      let binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    try {\n      // Add the attachment\n      const result = await fetchJSON(url, {\n        headers: new h({'Content-Type': type}),\n        method: 'PUT',\n        body: blob\n      });\n      callback(null, result.data);\n    } catch (error) {\n      callback(error);\n    }\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = async function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    try {\n      await setup();\n      await Promise.all(req.docs.map(preprocessAttachments$1));\n\n      // Update/create the documents\n      const result = await fetchJSON(genDBUrl(host, '_bulk_docs'), {\n        method: 'POST',\n        body: JSON.stringify(req)\n      });\n      callback(null, result.data);\n    } catch (error) {\n      callback(error);\n    }\n  };\n\n  // Update/create document\n  api._put = async function (doc, opts, callback) {\n    try {\n      await setup();\n      await preprocessAttachments$1(doc);\n\n      const result = await fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {\n        method: 'PUT',\n        body: JSON.stringify(doc)\n      });\n      callback(null, result.data);\n    } catch (error) {\n      error.docId = doc && doc._id;\n      callback(error);\n    }\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', async function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    let params = {};\n    let body;\n    let method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    let paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    try {\n      const result = await fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {\n        method: method,\n        body: JSON.stringify(body)\n      });\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, result.data);\n    } catch (error) {\n      callback(error);\n    }\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    let batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    let requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    /* istanbul ignore if */\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    let params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    let limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    let leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (let param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(opts.query_params, param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    let method = 'GET';\n    let body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    let controller = new a();\n    let lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    const fetchData = async function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Cloudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      let url = genDBUrl(host, '_changes' + paramsToStr(params));\n      let fetchOpts = {\n        signal: controller.signal,\n        method: method,\n        body: JSON.stringify(body)\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      try {\n        await setup();\n        const result = await fetchJSON(url, fetchOpts);\n        callback(null, result.data);\n      } catch (error) {\n        callback(error);\n      }\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    let results = {results: []};\n\n    const fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      let raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        let pending = null;\n        let lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        let req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          let ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (opts.return_docs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      let finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        immediate(function () { fetchData(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetchData(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        controller.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', async function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    try {\n      // Get the missing document/revision IDs\n      const result = await fetchJSON(genDBUrl(host, '_revs_diff'), {\n        method: 'POST',\n        body: JSON.stringify(req)\n      });\n      callback(null, result.data);\n    } catch (error) {\n      callback(error);\n    }\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = async function (options, callback) {\n    try {\n      const json = await fetchJSON(genDBUrl(host, ''), {method: 'DELETE'});\n      callback(null, json);\n    } catch (error) {\n      if (error.status === 404) {\n        callback(null, {ok: true});\n      } else {\n        callback(error);\n      }\n    }\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nclass QueryParseError extends Error {\n  constructor(message) {\n    super();\n    this.status = 400;\n    this.name = 'query_parse_error';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, QueryParseError);\n    } catch (e) {}\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message) {\n    super();\n    this.status = 404;\n    this.name = 'not_found';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, NotFoundError);\n    } catch (e) {}\n  }\n}\n\nclass BuiltInError extends Error {\n  constructor(message) {\n    super();\n    this.status = 500;\n    this.name = 'invalid_value';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, BuiltInError);\n    } catch (e) {}\n  }\n}\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      immediate(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      immediate(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return function (...args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  };\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nclass TaskQueue$1 {\n  constructor() {\n    this.promise = new Promise(function (fulfill) {fulfill(); });\n  }\n\n  add(promiseFactory) {\n    this.promise = this.promise.catch(function () {\n      // just recover\n    }).then(function () {\n      return promiseFactory();\n    });\n    return this.promise;\n  }\n\n  finish() {\n    return this.promise;\n  }\n}\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nasync function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  const viewSignature = createViewSignature(mapFun, reduceFun);\n\n  let cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  const promiseForView = sourceDB.info().then(async function (info) {\n    const depDbName = info.db_name + '-mrview-' +\n    (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      let fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      const depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    await upsert(sourceDB, '_local/' + localDocName, diffFunction);\n    const res = await sourceDB.registerDependentDatabase(depDbName);\n    const db = res.db;\n    db.auto_compaction = true;\n    const view = {\n      name: depDbName,\n      db: db,\n      sourceDB: sourceDB,\n      adapter: sourceDB.adapter,\n      mapFun: mapFun,\n      reduceFun: reduceFun\n    };\n\n    let lastSeqDoc;\n    try {\n      lastSeqDoc = await view.db.get('_local/lastSeq');\n    } catch (err) {\n        /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n    }\n\n    view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n    if (cachedViews) {\n      view.db.once('destroyed', function () {\n        delete cachedViews[viewSignature];\n      });\n    }\n    return view;\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e, data) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e, data);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e, {fun: fun, doc: doc});\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e, {fun: fun, keys: keys, values: values, rereduce: rereduce});\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    const keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    const val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    const docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      const atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        const att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    let val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      const asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError(`Invalid value for integer: \"${number}\"`);\n      }\n      if (number < 0) {\n        return new QueryParseError(`Invalid value for positive integer: \"${number}\"`);\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    const startkeyName = options.descending ? 'endkey' : 'startkey';\n    const endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      const error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  async function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    let params = [];\n    let body;\n    let method = 'GET';\n    let ok;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      const MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      const keysAsString = `keys=${encodeURIComponent(JSON.stringify(opts.keys))}`;\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      const parts = parseViewName(fun);\n\n      const response = await db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new h({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      });\n      ok = response.ok;\n      // status = response.status;\n      const result = await response.json();\n\n      if (!ok) {\n        result.status = response.status;\n        throw generateErrorFromResponse(result);\n      }\n\n      // fail the entire request if the result contains an error\n      result.rows.forEach(function (row) {\n        /* istanbul ignore if */\n        if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n          throw new Error(row.reason);\n        }\n      });\n\n      return new Promise(function (resolve) {\n        resolve(result);\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    const response = await db.fetch('_temp_view' + params, {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    });\n\n    ok = response.ok;\n    // status = response.status;\n    const result = await response.json();\n    if (!ok) {\n      result.status = response.status;\n      throw generateErrorFromResponse(result);\n    }\n\n    return new Promise(function (resolve) {\n      resolve(result);\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  async function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    const metaDocId = '_local/doc_' + docId;\n    const defaultMetaDoc = {_id: metaDocId, keys: []};\n    const docData = docIdsToChangesAndEmits.get(docId);\n    const indexableKeysToKeyValues = docData[0];\n    const changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      const kvDocs = [];\n      const oldKeys = new ExportedSet();\n\n      for (let i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        const row = kvDocsRes.rows[i];\n        const doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          const keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      const newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          const kvDoc = {\n            _id: key\n          };\n          const keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    const metaDoc = await getMetaDoc();\n    const keyValueDocs = await getKeyValueDocs(metaDoc);\n    return processKeyValueDocs(metaDoc, keyValueDocs);\n  }\n\n  function updatePurgeSeq(view) {\n    // with this approach, we just assume to have processed all missing purges and write the latest\n    // purgeSeq into the _local/purgeSeq doc.\n    return view.sourceDB.get('_local/purges').then(function (res) {\n      const purgeSeq = res.purgeSeq;\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res._rev;\n      }).catch(function (err) {\n        if (err.status !== 404) {\n          throw err;\n        }\n        return undefined;\n      }).then(function (rev) {\n        return view.db.put({\n          _id: '_local/purgeSeq',\n          _rev: rev,\n          purgeSeq,\n        });\n      });\n    }).catch(function (err) {\n      if (err.status !== 404) {\n        throw err;\n      }\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        })\n          // TODO: this should be placed somewhere else, probably? we're querying both docs twice\n          //   (first time when getting the actual purges).\n          .then(() => updatePurgeSeq(view));\n      });\n  }\n\n  function getQueue(view) {\n    const viewName = typeof view === 'string' ? view : view.name;\n    let queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$1();\n    }\n    return queue;\n  }\n\n  async function updateView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view, opts);\n    })();\n  }\n\n  async function updateViewInQueue(view, opts) {\n    // bind the emit function once\n    let mapResults;\n    let doc;\n    let taskId;\n\n    function emit(key, value) {\n      const output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    const mapFun = mapper(view.mapFun, emit);\n\n    let currentSeq = view.seq || 0;\n\n    function createTask() {\n      return view.sourceDB.info().then(function (info) {\n        taskId = view.sourceDB.activeTasks.add({\n          name: 'view_indexing',\n          total_items: info.update_seq - currentSeq,\n        });\n      });\n    }\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    let indexed_docs = 0;\n    const progress = {\n      view: view.name,\n      indexed_docs: indexed_docs\n    };\n    view.sourceDB.emit('indexing', progress);\n\n    const queue = new TaskQueue$1();\n\n    async function processNextBatch() {\n      const response = await view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: opts.changes_batch_size\n      });\n      const purges = await getRecentPurges();\n      return processBatch(response, purges);\n    }\n\n    function getRecentPurges() {\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res.purgeSeq;\n      }).catch(function (err) {\n        if (err && err.status !== 404) {\n          throw err;\n        }\n        return -1;\n      }).then(function (purgeSeq) {\n        return view.sourceDB.get('_local/purges').then(function (res) {\n          const recentPurges = res.purges.filter(function (purge, index) {\n            return index > purgeSeq;\n          }).map((purge) => purge.docId);\n\n          const uniquePurges = recentPurges.filter(function (docId, index) {\n            return recentPurges.indexOf(docId) === index;\n          });\n\n          return Promise.all(uniquePurges.map(function (docId) {\n            return view.sourceDB.get(docId).then(function (doc) {\n              return { docId, doc };\n            }).catch(function (err) {\n              if (err.status !== 404) {\n                throw err;\n              }\n              return { docId };\n            });\n          }));\n        }).catch(function (err) {\n          if (err && err.status !== 404) {\n            throw err;\n          }\n          return [];\n        });\n      });\n    }\n\n    function processBatch(response, purges) {\n      var results = response.results;\n      if (!results.length && !purges.length) {\n        return;\n      }\n\n      for (let purge of purges) {\n        const index = results.findIndex(function (change) {\n          return change.id === purge.docId;\n        });\n        if (index < 0) {\n          // mimic a db.remove() on the changes feed\n          const entry = {\n            _id: purge.docId,\n            doc: {\n              _id: purge.docId,\n              _deleted: 1,\n            },\n            changes: [],\n          };\n\n          if (purge.doc) {\n            // update with new winning rev after purge\n            entry.doc = purge.doc;\n            entry.changes.push({ rev: purge.doc._rev });\n          }\n\n          results.push(entry);\n        }\n      }\n\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\n      indexed_docs = indexed_docs + results.length;\n      const progress = {\n        view: view.name,\n        last_seq: response.last_seq,\n        results_count: results.length,\n        indexed_docs: indexed_docs\n      };\n      view.sourceDB.emit('indexing', progress);\n      view.sourceDB.activeTasks.update(taskId, {completed_items: indexed_docs});\n\n      if (results.length < opts.changes_batch_size) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      const docIdsToChangesAndEmits = new ExportedMap();\n      for (let i = 0, len = results.length; i < len; i++) {\n        const change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          const indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      const indexableKeysToKeyValues = new ExportedMap();\n      let lastKey;\n      for (let i = 0, len = mapResults.length; i < len; i++) {\n        const emittedKeyValue = mapResults[i];\n        const complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    try {\n      await createTask();\n      await processNextBatch();\n      await queue.finish();\n      view.seq = currentSeq;\n      view.sourceDB.activeTasks.remove(taskId);\n    } catch (error) {\n      view.sourceDB.activeTasks.remove(taskId, error);      \n    }\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    const shouldGroup = options.group || options.group_level;\n\n    const reduceFun = reducer(view.reduceFun);\n\n    const groups = [];\n    const lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      const last = groups[groups.length - 1];\n      let groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (let i = 0, len = groups.length; i < len; i++) {\n      const e = groups[i];\n      const reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  async function queryViewInQueue(view, opts) {\n    let totalRows;\n    const shouldReduce = view.reduceFun && opts.reduce !== false;\n    const skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    async function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      const res = await view.db.allDocs(viewOpts);\n      totalRows = res.total_rows;\n\n      return res.rows.map(function (result) {\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n          result.doc.value !== null) {\n          const keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          const expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        const parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    }\n\n    async function onMapResultsReady(rows) {\n      let finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else if (typeof opts.keys === 'undefined') {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      } else {\n        // support limit, skip for keys query\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: sliceResults(rows,opts.limit,opts.skip)\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        const docIds = uniq(rows.map(rowToDocId));\n\n        const allDocsRes = await view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        });\n        var docIdsToDocs = new ExportedMap();\n        allDocsRes.rows.forEach(function (row) {\n          docIdsToDocs.set(row.id, row.doc);\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs.get(docId);\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      const keys = opts.keys;\n      const fetchPromises = keys.map(function (key) {\n        const viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      const result = await Promise.all(fetchPromises);\n      const flattenedResult = flatten(result);\n      return onMapResultsReady(flattenedResult);\n    } else { // normal query, no 'keys'\n      const viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      let startkey;\n      let endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        let inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        const keyStart = toIndexableString([opts.key]);\n        const keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n\n      const result = await fetchFromView(viewOpts);\n      return onMapResultsReady(result);\n    }\n  }\n\n  async function httpViewCleanup(db) {\n    const response = await db.fetch('_view_cleanup', {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST'\n    });\n    return response.json();\n  }\n\n  async function localViewCleanup(db) {\n    try {\n      const metaDoc = await db.get('_local/' + localDocName);\n      const docsToViews = new ExportedMap();\n\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        const parts = parseViewName(fullViewName);\n        const designDocName = '_design/' + parts[0];\n        const viewName = parts[1];\n        let views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      const opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n\n      const res = await db.allDocs(opts);\n      const viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        const ddocName = row.key.substring(8); // cuts off '_design/'\n        docsToViews.get(row.key).forEach(function (viewName) {\n          let fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          const viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          const statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n\n      const dbsToDelete = Object.keys(viewsToStatus)\n        .filter(function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\n      const destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n\n      return Promise.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    } catch (err) {\n      if (err.status === 404) {\n        return {ok: true};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    const updateViewOpts = {\n      changes_batch_size: db.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE$1\n    };\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(async function () {\n        const view = await createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n\n        return fin(updateView(view, updateViewOpts).then(\n          function () { return queryView(view, opts); }),\n          function () { return view.db.destroy(); }\n        );\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      const fullViewName = fun;\n      const parts = parseViewName(fullViewName);\n      const designDocName = parts[0];\n      const viewName = parts[1];\n\n      const doc = await db.get('_design/' + designDocName);\n      fun = doc.views && doc.views[viewName];\n\n      if (!fun) {\n        // basic validator; it's assumed that every subclass would want this\n        throw new NotFoundError(`ddoc ${doc._id} has no view named ${viewName}`);\n      }\n\n      ddocValidator(doc, viewName);\n      checkQueryParseError(opts, fun);\n\n      const view = await createView(\n        /* sourceDB */ db,\n        /* viewName */ fullViewName,\n        /* mapFun */ fun.map,\n        /* reduceFun */ fun.reduce,\n        /* temporary */ false,\n        /* localDocName */ localDocName);\n\n      if (opts.stale === 'ok' || opts.stale === 'update_after') {\n        if (opts.stale === 'update_after') {\n          immediate(function () {\n            updateView(view, updateViewOpts);\n          });\n        }\n        return queryView(view, opts);\n      } else { // stale not ok\n        await updateView(view, updateViewOpts);\n        return queryView(view, opts);\n      }\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    const db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    const promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  const abstractViewCleanup = callbackify(function () {\n    const db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return Promise.resolve()\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nclass CheckpointerInternal {\n  constructor(src, target, id, returnValue, opts) {\n    this.src = src;\n    this.target = target;\n    this.id = id;\n    this.returnValue = returnValue;\n    this.opts = opts || {};\n  }\n\n  writeCheckpoint(checkpoint, session) {\n    var self = this;\n    return this.updateTarget(checkpoint, session).then(function () {\n      return self.updateSource(checkpoint, session);\n    });\n  }\n\n  updateTarget(checkpoint, session) {\n    if (this.opts.writeTargetCheckpoint) {\n      return updateCheckpoint(this.target, this.id, checkpoint,\n        session, this.returnValue);\n    } else {\n      return Promise.resolve(true);\n    }\n  }\n\n  updateSource(checkpoint, session) {\n    if (this.opts.writeSourceCheckpoint) {\n      var self = this;\n      return updateCheckpoint(this.src, this.id, checkpoint,\n        session, this.returnValue)\n        .catch(function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return true;\n          }\n          throw err;\n        });\n    } else {\n      return Promise.resolve(true);\n    }\n  }\n\n  getCheckpoint() {\n    var self = this;\n  \n    if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n      return self.src.get(self.id).then(function (sourceDoc) {\n        return sourceDoc.last_seq || LOWEST_SEQ;\n      }).catch(function (err) {\n        /* istanbul ignore if */\n        if (err.status !== 404) {\n          throw err;\n        }\n        return LOWEST_SEQ;\n      });\n    }\n  \n    return self.target.get(self.id).then(function (targetDoc) {\n      if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n        return targetDoc.last_seq || LOWEST_SEQ;\n      }\n  \n      return self.src.get(self.id).then(function (sourceDoc) {\n        // Since we can't migrate an old version doc to a new one\n        // (no session id), we just go with the lowest seq in this case\n        /* istanbul ignore if */\n        if (targetDoc.version !== sourceDoc.version) {\n          return LOWEST_SEQ;\n        }\n  \n        var version;\n        if (targetDoc.version) {\n          version = targetDoc.version.toString();\n        } else {\n          version = \"undefined\";\n        }\n  \n        if (version in comparisons) {\n          return comparisons[version](targetDoc, sourceDoc);\n        }\n        /* istanbul ignore next */\n        return LOWEST_SEQ;\n      }, function (err) {\n        if (err.status === 404 && targetDoc.last_seq) {\n          return self.src.put({\n            _id: self.id,\n            last_seq: LOWEST_SEQ\n          }).then(function () {\n            return LOWEST_SEQ;\n          }, function (err) {\n            if (isForbiddenError(err)) {\n              self.opts.writeSourceCheckpoint = false;\n              return targetDoc.last_seq;\n            }\n            /* istanbul ignore next */\n            return LOWEST_SEQ;\n          });\n        }\n        throw err;\n      });\n    }).catch(function (err) {\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n}\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  if (!(this instanceof CheckpointerInternal)) {\n    return new CheckpointerInternal(src, target, id, returnValue, opts);\n  }\n  return Checkpointer;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return Promise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new Promise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  // initial_last_seq is the state of the source db before\n  // replication started, and it is _not_ updated during\n  // replication or used anywhere else, as opposed to last_seq\n  var initial_last_seq = 0;\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var style = opts.style || 'all_docs';\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n  var taskId;\n\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of\n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n\n    src.info().then(function (info) {\n      var task = src.activeTasks.get(taskId);\n      if (!currentBatch || !task) {\n        return;\n      }\n\n      var completed = task.completed_items || 0;\n      var total_items = parseInt(info.update_seq, 10) - parseInt(initial_last_seq, 10);\n      src.activeTasks.update(taskId, {\n        completed_items: completed + currentBatch.changes.length,\n        total_items\n      });\n    });\n\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      returnValue.emit('checkpoint', { 'checkpoint': currentBatch.seq });\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      returnValue.emit('checkpoint', { 'revs_diff': change });\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    returnValue.emit('checkpoint', { 'start_next_batch': currentBatch.seq });\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate$$1) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate$$1 ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    src.activeTasks.remove(taskId, fatalError);\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      // update processed items count by 1\n      var task = src.activeTasks.get(taskId);\n      if (task) {\n        // we can assume that task exists here? shouldn't be deleted by here.\n        var completed = task.completed_items || 0;\n        src.activeTasks.update(taskId, {completed_items: ++completed});\n      }\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    returnValue.emit('checkpoint', { 'pending_batch': pendingBatch.seq });\n    immediate(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          if (returnValue.cancelled) {\n            completeReplication();\n            throw new Error('cancelled');\n          } else {\n            complete();\n          }\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n  function createTask(checkpoint) {\n    return src.info().then(function (info) {\n      var total_items = typeof opts.since === 'undefined' ?\n        parseInt(info.update_seq, 10) - parseInt(checkpoint, 10) :\n        parseInt(info.update_seq, 10);\n\n      taskId = src.activeTasks.add({\n        name: `${continuous ? 'continuous ' : ''}replication from ${info.db_name}` ,\n        total_items,\n      });\n\n      return checkpoint;\n    });\n  }\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(createTask).then(function (checkpoint) {\n        last_seq = checkpoint;\n        initial_last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: style,\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\nclass Replication extends EE {\n  constructor() {\n    super();\n    this.cancelled = false;\n    this.state = 'pending';\n    const promise = new Promise((fulfill, reject) => {\n      this.once('complete', fulfill);\n      this.once('error', reject);\n    });\n    this.then = function (resolve, reject) {\n      return promise.then(resolve, reject);\n    };\n    this.catch = function (reject) {\n      return promise.catch(reject);\n    };\n    // As we allow error handling via \"error\" event as well,\n    // put a stub in here so that rejecting never throws UnhandledError.\n    this.catch(function () {});\n  }\n\n  cancel() {\n    this.cancelled = true;\n    this.state = 'cancelled';\n    this.emit('cancel');\n  }\n\n  ready(src, target) {\n    if (this._readyCalled) {\n      return;\n    }\n    this._readyCalled = true;\n  \n    const onDestroy = () => {\n      this.cancel();\n    };\n    src.once('destroyed', onDestroy);\n    target.once('destroyed', onDestroy);\n    function cleanup() {\n      src.removeListener('destroyed', onDestroy);\n      target.removeListener('destroyed', onDestroy);\n    }\n    this.once('complete', cleanup);\n    this.once('error', cleanup);\n  }\n}\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nclass Sync extends EE {\n  constructor(src, target, opts, callback) {\n    super();\n    this.canceled = false;\n\n    const optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n    const optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n    this.push = replicateWrapper(src, target, optsPush);\n    this.pull = replicateWrapper(target, src, optsPull);\n\n    this.pushPaused = true;\n    this.pullPaused = true;\n\n    const pullChange = (change) => {\n      this.emit('change', {\n        direction: 'pull',\n        change: change\n      });\n    };\n    const pushChange = (change) => {\n      this.emit('change', {\n        direction: 'push',\n        change: change\n      });\n    };\n    const pushDenied = (doc) => {\n      this.emit('denied', {\n        direction: 'push',\n        doc: doc\n      });\n    };\n    const pullDenied = (doc) => {\n      this.emit('denied', {\n        direction: 'pull',\n        doc: doc\n      });\n    };\n    const pushPaused = () => {\n      this.pushPaused = true;\n      /* istanbul ignore if */\n      if (this.pullPaused) {\n        this.emit('paused');\n      }\n    };\n    const pullPaused = () => {\n      this.pullPaused = true;\n      /* istanbul ignore if */\n      if (this.pushPaused) {\n        this.emit('paused');\n      }\n    };\n    const pushActive = () => {\n      this.pushPaused = false;\n      /* istanbul ignore if */\n      if (this.pullPaused) {\n        this.emit('active', {\n          direction: 'push'\n        });\n      }\n    };\n    const pullActive = () => {\n      this.pullPaused = false;\n      /* istanbul ignore if */\n      if (this.pushPaused) {\n        this.emit('active', {\n          direction: 'pull'\n        });\n      }\n    };\n\n    let removed = {};\n\n    const removeAll = (type) => { // type is 'push' or 'pull'\n      return (event, func) => {\n        const isChange = event === 'change' &&\n          (func === pullChange || func === pushChange);\n        const isDenied = event === 'denied' &&\n          (func === pullDenied || func === pushDenied);\n        const isPaused = event === 'paused' &&\n          (func === pullPaused || func === pushPaused);\n        const isActive = event === 'active' &&\n          (func === pullActive || func === pushActive);\n\n        if (isChange || isDenied || isPaused || isActive) {\n          if (!(event in removed)) {\n            removed[event] = {};\n          }\n          removed[event][type] = true;\n          if (Object.keys(removed[event]).length === 2) {\n            // both push and pull have asked to be removed\n            this.removeAllListeners(event);\n          }\n        }\n      };\n    };\n\n    if (opts.live) {\n      this.push.on('complete', this.pull.cancel.bind(this.pull));\n      this.pull.on('complete', this.push.cancel.bind(this.push));\n    }\n\n    function addOneListener(ee, event, listener) {\n      if (ee.listeners(event).indexOf(listener) == -1) {\n        ee.on(event, listener);\n      }\n    }\n\n    this.on('newListener', function (event) {\n      if (event === 'change') {\n        addOneListener(this.pull, 'change', pullChange);\n        addOneListener(this.push, 'change', pushChange);\n      } else if (event === 'denied') {\n        addOneListener(this.pull, 'denied', pullDenied);\n        addOneListener(this.push, 'denied', pushDenied);\n      } else if (event === 'active') {\n        addOneListener(this.pull, 'active', pullActive);\n        addOneListener(this.push, 'active', pushActive);\n      } else if (event === 'paused') {\n        addOneListener(this.pull, 'paused', pullPaused);\n        addOneListener(this.push, 'paused', pushPaused);\n      }\n    });\n\n    this.on('removeListener', function (event) {\n      if (event === 'change') {\n        this.pull.removeListener('change', pullChange);\n        this.push.removeListener('change', pushChange);\n      } else if (event === 'denied') {\n        this.pull.removeListener('denied', pullDenied);\n        this.push.removeListener('denied', pushDenied);\n      } else if (event === 'active') {\n        this.pull.removeListener('active', pullActive);\n        this.push.removeListener('active', pushActive);\n      } else if (event === 'paused') {\n        this.pull.removeListener('paused', pullPaused);\n        this.push.removeListener('paused', pushPaused);\n      }\n    });\n\n    this.pull.on('removeListener', removeAll('pull'));\n    this.push.on('removeListener', removeAll('push'));\n\n    const promise = Promise.all([\n      this.push,\n      this.pull\n    ]).then((resp) => {\n      const out = {\n        push: resp[0],\n        pull: resp[1]\n      };\n      this.emit('complete', out);\n      if (callback) {\n        callback(null, out);\n      }\n      this.removeAllListeners();\n      return out;\n    }, (err) => {\n      this.cancel();\n      if (callback) {\n        // if there's a callback, then the callback can receive\n        // the error event\n        callback(err);\n      } else {\n        // if there's no callback, then we're safe to emit an error\n        // event, which would otherwise throw an unhandled error\n        // due to 'error' being a special event in EventEmitters\n        this.emit('error', err);\n      }\n      this.removeAllListeners();\n      if (callback) {\n        // no sense throwing if we're already emitting an 'error' event\n        throw err;\n      }\n    });\n\n    this.then = function (success, err) {\n      return promise.then(success, err);\n    };\n\n    this.catch = function (err) {\n      return promise.catch(err);\n    };\n  }\n\n  cancel() {\n    if (!this.canceled) {\n      this.canceled = true;\n      this.push.cancel();\n      this.pull.cancel();\n    }\n  }\n}\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\nexport default PouchDB;\n","class PouchError extends Error {\n  constructor(status, error, reason) {\n    super();\n    this.status = status;\n    this.name = error;\n    this.message = reason;\n    this.error = true;\n  }\n\n  toString() {\n    return JSON.stringify({\n      status: this.status,\n      name: this.name,\n      message: this.message,\n      reason: this.reason\n    });\n  }\n}\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    var names = Object.getOwnPropertyNames(error);\n    for (var i = 0, len = names.length; i < len; i++) {\n      if (typeof error[names[i]] !== 'function') {\n        this[names[i]] = error[names[i]];\n      }\n    }\n\n    if (this.stack === undefined) {\n      this.stack = (new Error()).stack;\n    }\n\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  if (!('stack' in err)) {\n    err.stack = (new Error()).stack;\n  }\n\n  return err;\n}\n\nexport { UNAUTHORIZED, MISSING_BULK_DOCS, MISSING_DOC, REV_CONFLICT, INVALID_ID, MISSING_ID, RESERVED_ID, NOT_OPEN, UNKNOWN_ERROR, BAD_ARG, INVALID_REQUEST, QUERY_PARSE_ERROR, DOC_VALIDATION, BAD_REQUEST, NOT_AN_OBJECT, DB_MISSING, WSQ_ERROR, LDB_ERROR, FORBIDDEN, INVALID_REV, FILE_EXISTS, MISSING_STUB, IDB_ERROR, INVALID_URL, createError, generateErrorFromResponse };\n","// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f = fetch;\nvar h = Headers;\n\nexport { f as fetch, h as Headers, a as AbortController };\n","function mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.keys = function () {\n  return Object.keys(this._store).map(k => unmangle(k));\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\nexport { ExportedSet as Set, ExportedMap as Map };\n","var thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\nfunction typedBuffer() {\n}\n\nexport { thisAtob as atob, thisBtoa as btoa, b64ToBluffer as base64StringToBlobOrBuffer, binaryStringToArrayBuffer, binStringToBluffer as binaryStringToBlobOrBuffer, createBlob as blob, blobToBase64 as blobOrBufferToBase64, blobToBinaryString as blobOrBufferToBinaryString, readAsArrayBuffer, readAsBinaryString, typedBuffer };\n","function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging\n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (Object.prototype.hasOwnProperty.call(origKey, k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };\n","import { btoa, readAsArrayBuffer } from 'pouchdb-binary-utils';\nimport Md5 from 'spark-md5';\n\nvar setImmediateShim = self.setImmediate || self.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return btoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nexport { binaryMd5, stringMd5 };\n","import { Map } from 'pouchdb-collections';\nimport immediate from 'immediate';\nimport { createError, BAD_REQUEST, INVALID_ID, MISSING_ID, RESERVED_ID } from 'pouchdb-errors';\nimport EventEmitter from 'events';\nimport { assign } from 'pouchdb-utils';\nimport { v4 } from 'uuid';\nimport { stringMd5 } from 'pouchdb-md5';\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date && isFinite(object)) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return function (...args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  };\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return function (...args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  };\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(function (...args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  });\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new Map();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\nclass Changes extends EventEmitter {\n  constructor() {\n    super();\n    \n    this._listeners = {};\n    \n    if (hasLocalStorage()) {\n      addEventListener(\"storage\", (e) => {\n        this.emit(e.key);\n      });\n    }\n  }\n\n  addListener(dbName, id, db, opts) {\n    if (this._listeners[id]) {\n      return;\n    }\n    var inprogress = false;\n    var self = this;\n    function eventFunction() {\n      if (!self._listeners[id]) {\n        return;\n      }\n      if (inprogress) {\n        inprogress = 'waiting';\n        return;\n      }\n      inprogress = true;\n      var changesOpts = pick(opts, [\n        'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n        'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n      ]);\n  \n      function onError() {\n        inprogress = false;\n      }\n  \n      db.changes(changesOpts).on('change', function (c) {\n        if (c.seq > opts.since && !opts.cancelled) {\n          opts.since = c.seq;\n          opts.onChange(c);\n        }\n      }).on('complete', function () {\n        if (inprogress === 'waiting') {\n          immediate(eventFunction);\n        }\n        inprogress = false;\n      }).on('error', onError);\n    }\n    this._listeners[id] = eventFunction;\n    this.on(dbName, eventFunction);\n  }\n  \n  removeListener(dbName, id) {\n    if (!(id in this._listeners)) {\n      return;\n    }\n    super.removeListener(dbName, this._listeners[id]);\n    delete this._listeners[id];\n  }\n  \n  notifyLocalWindows(dbName) {\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (hasLocalStorage()) {\n      localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n    }\n  }\n  \n  notify(dbName) {\n    this.emit(dbName);\n    this.notifyLocalWindows(dbName);\n  }\n}\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign$1;\n{\n  if (typeof Object.assign === 'function') {\n    assign$1 = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign$1 = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$2 = assign$1;\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(change.doc._attachments, att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    var match = fun.toString().match(/^\\s*function\\s*(?:(\\S+)\\s*)?\\(/);\n    if (match && match[1]) {\n      return match[1];\n    }\n    else {\n      return '';\n    }\n  };\n}\n\nvar res$1 = res;\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return db.get(docId)\n    .catch(function (err) {\n      /* istanbul ignore next */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return {};\n    })\n    .then(function (doc) {\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return {updated: false, rev: docRev};\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      return tryAndPut(db, newDoc, diffFun);\n    });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n/**\n * Creates a new revision string that does NOT include the revision height\n * For example '56649f1b0506c6ca9fda0746eb0cacdf'\n */\nfunction rev(doc, deterministic_revs) {\n  if (!deterministic_revs) {\n    return v4().replace(/-/g, '').toLowerCase();\n  }\n\n  var mutateableDoc = assign({}, doc);\n  delete mutateableDoc._rev_tree;\n  return stringMd5(JSON.stringify(mutateableDoc));\n}\n\nvar uuid = v4; // mimic old import, only v4 is ever used elsewhere\n\nexport { adapterFun, assign$2 as assign, bulkGet as bulkGetShim, Changes as changesHandler, clone, defaultBackOff, explainError, filterChange, flatten, res$1 as functionName, guardedConsole, hasLocalStorage, invalidIdError, isRemote, listenerCount, immediate as nextTick, normalizeDesignDocFunctionName as normalizeDdocFunctionName, once, parseDesignDocFunctionName as parseDdocFunctionName, parseUri, pick, rev, scopeEval, toPromise, upsert, uuid };\n","import { Set } from 'pouchdb-collections';\nimport { nextTick } from 'pouchdb-utils';\n\nclass QueryParseError extends Error {\n  constructor(message) {\n    super();\n    this.status = 400;\n    this.name = 'query_parse_error';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, QueryParseError);\n    } catch (e) {}\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message) {\n    super();\n    this.status = 404;\n    this.name = 'not_found';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, NotFoundError);\n    } catch (e) {}\n  }\n}\n\nclass BuiltInError extends Error {\n  constructor(message) {\n    super();\n    this.status = 500;\n    this.name = 'invalid_value';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, BuiltInError);\n    } catch (e) {}\n  }\n}\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return function (...args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  };\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new Set(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nexport { uniq, sequentialize, fin, callbackify, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError };\n","import { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nclass TaskQueue {\n  constructor() {\n    this.promise = new Promise(function (fulfill) {fulfill(); });\n  }\n\n  add(promiseFactory) {\n    this.promise = this.promise.catch(function () {\n      // just recover\n    }).then(function () {\n      return promiseFactory();\n    });\n    return this.promise;\n  }\n\n  finish() {\n    return this.promise;\n  }\n}\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nasync function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  const viewSignature = createViewSignature(mapFun, reduceFun);\n\n  let cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  const promiseForView = sourceDB.info().then(async function (info) {\n    const depDbName = info.db_name + '-mrview-' +\n    (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      let fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      const depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    await upsert(sourceDB, '_local/' + localDocName, diffFunction);\n    const res = await sourceDB.registerDependentDatabase(depDbName);\n    const db = res.db;\n    db.auto_compaction = true;\n    const view = {\n      name: depDbName,\n      db: db,\n      sourceDB: sourceDB,\n      adapter: sourceDB.adapter,\n      mapFun: mapFun,\n      reduceFun: reduceFun\n    };\n\n    let lastSeqDoc;\n    try {\n      lastSeqDoc = await view.db.get('_local/lastSeq');\n    } catch (err) {\n        /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n    }\n\n    view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n    if (cachedViews) {\n      view.db.once('destroyed', function () {\n        delete cachedViews[viewSignature];\n      });\n    }\n    return view;\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e, data) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e, data);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e, {fun: fun, doc: doc});\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e, {fun: fun, keys: keys, values: values, rereduce: rereduce});\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    const keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    const val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    const docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      const atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        const att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    let val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      const asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError(`Invalid value for integer: \"${number}\"`);\n      }\n      if (number < 0) {\n        return new QueryParseError(`Invalid value for positive integer: \"${number}\"`);\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    const startkeyName = options.descending ? 'endkey' : 'startkey';\n    const endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      const error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  async function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    let params = [];\n    let body;\n    let method = 'GET';\n    let ok;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      const MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      const keysAsString = `keys=${encodeURIComponent(JSON.stringify(opts.keys))}`;\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      const parts = parseViewName(fun);\n\n      const response = await db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      });\n      ok = response.ok;\n      // status = response.status;\n      const result = await response.json();\n\n      if (!ok) {\n        result.status = response.status;\n        throw generateErrorFromResponse(result);\n      }\n\n      // fail the entire request if the result contains an error\n      result.rows.forEach(function (row) {\n        /* istanbul ignore if */\n        if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n          throw new Error(row.reason);\n        }\n      });\n\n      return new Promise(function (resolve) {\n        resolve(result);\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    const response = await db.fetch('_temp_view' + params, {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    });\n\n    ok = response.ok;\n    // status = response.status;\n    const result = await response.json();\n    if (!ok) {\n      result.status = response.status;\n      throw generateErrorFromResponse(result);\n    }\n\n    return new Promise(function (resolve) {\n      resolve(result);\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  async function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    const metaDocId = '_local/doc_' + docId;\n    const defaultMetaDoc = {_id: metaDocId, keys: []};\n    const docData = docIdsToChangesAndEmits.get(docId);\n    const indexableKeysToKeyValues = docData[0];\n    const changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      const kvDocs = [];\n      const oldKeys = new Set();\n\n      for (let i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        const row = kvDocsRes.rows[i];\n        const doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          const keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      const newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          const kvDoc = {\n            _id: key\n          };\n          const keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    const metaDoc = await getMetaDoc();\n    const keyValueDocs = await getKeyValueDocs(metaDoc);\n    return processKeyValueDocs(metaDoc, keyValueDocs);\n  }\n\n  function updatePurgeSeq(view) {\n    // with this approach, we just assume to have processed all missing purges and write the latest\n    // purgeSeq into the _local/purgeSeq doc.\n    return view.sourceDB.get('_local/purges').then(function (res) {\n      const purgeSeq = res.purgeSeq;\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res._rev;\n      }).catch(function (err) {\n        if (err.status !== 404) {\n          throw err;\n        }\n        return undefined;\n      }).then(function (rev) {\n        return view.db.put({\n          _id: '_local/purgeSeq',\n          _rev: rev,\n          purgeSeq,\n        });\n      });\n    }).catch(function (err) {\n      if (err.status !== 404) {\n        throw err;\n      }\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        })\n          // TODO: this should be placed somewhere else, probably? we're querying both docs twice\n          //   (first time when getting the actual purges).\n          .then(() => updatePurgeSeq(view));\n      });\n  }\n\n  function getQueue(view) {\n    const viewName = typeof view === 'string' ? view : view.name;\n    let queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  async function updateView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view, opts);\n    })();\n  }\n\n  async function updateViewInQueue(view, opts) {\n    // bind the emit function once\n    let mapResults;\n    let doc;\n    let taskId;\n\n    function emit(key, value) {\n      const output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    const mapFun = mapper(view.mapFun, emit);\n\n    let currentSeq = view.seq || 0;\n\n    function createTask() {\n      return view.sourceDB.info().then(function (info) {\n        taskId = view.sourceDB.activeTasks.add({\n          name: 'view_indexing',\n          total_items: info.update_seq - currentSeq,\n        });\n      });\n    }\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    let indexed_docs = 0;\n    const progress = {\n      view: view.name,\n      indexed_docs: indexed_docs\n    };\n    view.sourceDB.emit('indexing', progress);\n\n    const queue = new TaskQueue();\n\n    async function processNextBatch() {\n      const response = await view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: opts.changes_batch_size\n      });\n      const purges = await getRecentPurges();\n      return processBatch(response, purges);\n    }\n\n    function getRecentPurges() {\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res.purgeSeq;\n      }).catch(function (err) {\n        if (err && err.status !== 404) {\n          throw err;\n        }\n        return -1;\n      }).then(function (purgeSeq) {\n        return view.sourceDB.get('_local/purges').then(function (res) {\n          const recentPurges = res.purges.filter(function (purge, index) {\n            return index > purgeSeq;\n          }).map((purge) => purge.docId);\n\n          const uniquePurges = recentPurges.filter(function (docId, index) {\n            return recentPurges.indexOf(docId) === index;\n          });\n\n          return Promise.all(uniquePurges.map(function (docId) {\n            return view.sourceDB.get(docId).then(function (doc) {\n              return { docId, doc };\n            }).catch(function (err) {\n              if (err.status !== 404) {\n                throw err;\n              }\n              return { docId };\n            });\n          }));\n        }).catch(function (err) {\n          if (err && err.status !== 404) {\n            throw err;\n          }\n          return [];\n        });\n      });\n    }\n\n    function processBatch(response, purges) {\n      var results = response.results;\n      if (!results.length && !purges.length) {\n        return;\n      }\n\n      for (let purge of purges) {\n        const index = results.findIndex(function (change) {\n          return change.id === purge.docId;\n        });\n        if (index < 0) {\n          // mimic a db.remove() on the changes feed\n          const entry = {\n            _id: purge.docId,\n            doc: {\n              _id: purge.docId,\n              _deleted: 1,\n            },\n            changes: [],\n          };\n\n          if (purge.doc) {\n            // update with new winning rev after purge\n            entry.doc = purge.doc;\n            entry.changes.push({ rev: purge.doc._rev });\n          }\n\n          results.push(entry);\n        }\n      }\n\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\n      indexed_docs = indexed_docs + results.length;\n      const progress = {\n        view: view.name,\n        last_seq: response.last_seq,\n        results_count: results.length,\n        indexed_docs: indexed_docs\n      };\n      view.sourceDB.emit('indexing', progress);\n      view.sourceDB.activeTasks.update(taskId, {completed_items: indexed_docs});\n\n      if (results.length < opts.changes_batch_size) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      const docIdsToChangesAndEmits = new Map();\n      for (let i = 0, len = results.length; i < len; i++) {\n        const change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          const indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      const indexableKeysToKeyValues = new Map();\n      let lastKey;\n      for (let i = 0, len = mapResults.length; i < len; i++) {\n        const emittedKeyValue = mapResults[i];\n        const complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    try {\n      await createTask();\n      await processNextBatch();\n      await queue.finish();\n      view.seq = currentSeq;\n      view.sourceDB.activeTasks.remove(taskId);\n    } catch (error) {\n      view.sourceDB.activeTasks.remove(taskId, error);      \n    }\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    const shouldGroup = options.group || options.group_level;\n\n    const reduceFun = reducer(view.reduceFun);\n\n    const groups = [];\n    const lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      const last = groups[groups.length - 1];\n      let groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (let i = 0, len = groups.length; i < len; i++) {\n      const e = groups[i];\n      const reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  async function queryViewInQueue(view, opts) {\n    let totalRows;\n    const shouldReduce = view.reduceFun && opts.reduce !== false;\n    const skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    async function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      const res = await view.db.allDocs(viewOpts);\n      totalRows = res.total_rows;\n\n      return res.rows.map(function (result) {\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n          result.doc.value !== null) {\n          const keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          const expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        const parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    }\n\n    async function onMapResultsReady(rows) {\n      let finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else if (typeof opts.keys === 'undefined') {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      } else {\n        // support limit, skip for keys query\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: sliceResults(rows,opts.limit,opts.skip)\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        const docIds = uniq(rows.map(rowToDocId));\n\n        const allDocsRes = await view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        });\n        var docIdsToDocs = new Map();\n        allDocsRes.rows.forEach(function (row) {\n          docIdsToDocs.set(row.id, row.doc);\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs.get(docId);\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      const keys = opts.keys;\n      const fetchPromises = keys.map(function (key) {\n        const viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      const result = await Promise.all(fetchPromises);\n      const flattenedResult = flatten(result);\n      return onMapResultsReady(flattenedResult);\n    } else { // normal query, no 'keys'\n      const viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      let startkey;\n      let endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        let inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        const keyStart = toIndexableString([opts.key]);\n        const keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n\n      const result = await fetchFromView(viewOpts);\n      return onMapResultsReady(result);\n    }\n  }\n\n  async function httpViewCleanup(db) {\n    const response = await db.fetch('_view_cleanup', {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST'\n    });\n    return response.json();\n  }\n\n  async function localViewCleanup(db) {\n    try {\n      const metaDoc = await db.get('_local/' + localDocName);\n      const docsToViews = new Map();\n\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        const parts = parseViewName(fullViewName);\n        const designDocName = '_design/' + parts[0];\n        const viewName = parts[1];\n        let views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      const opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n\n      const res = await db.allDocs(opts);\n      const viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        const ddocName = row.key.substring(8); // cuts off '_design/'\n        docsToViews.get(row.key).forEach(function (viewName) {\n          let fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          const viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          const statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n\n      const dbsToDelete = Object.keys(viewsToStatus)\n        .filter(function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\n      const destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n\n      return Promise.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    } catch (err) {\n      if (err.status === 404) {\n        return {ok: true};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    const updateViewOpts = {\n      changes_batch_size: db.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE\n    };\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(async function () {\n        const view = await createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n\n        return fin(updateView(view, updateViewOpts).then(\n          function () { return queryView(view, opts); }),\n          function () { return view.db.destroy(); }\n        );\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      const fullViewName = fun;\n      const parts = parseViewName(fullViewName);\n      const designDocName = parts[0];\n      const viewName = parts[1];\n\n      const doc = await db.get('_design/' + designDocName);\n      fun = doc.views && doc.views[viewName];\n\n      if (!fun) {\n        // basic validator; it's assumed that every subclass would want this\n        throw new NotFoundError(`ddoc ${doc._id} has no view named ${viewName}`);\n      }\n\n      ddocValidator(doc, viewName);\n      checkQueryParseError(opts, fun);\n\n      const view = await createView(\n        /* sourceDB */ db,\n        /* viewName */ fullViewName,\n        /* mapFun */ fun.map,\n        /* reduceFun */ fun.reduce,\n        /* temporary */ false,\n        /* localDocName */ localDocName);\n\n      if (opts.stale === 'ok' || opts.stale === 'update_after') {\n        if (opts.stale === 'update_after') {\n          nextTick(function () {\n            updateView(view, updateViewOpts);\n          });\n        }\n        return queryView(view, opts);\n      } else { // stale not ok\n        await updateView(view, updateViewOpts);\n        return queryView(view, opts);\n      }\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    const db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    const promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  const abstractViewCleanup = callbackify(function () {\n    const db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;\n","import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = doc[elem] || {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (i > 0 && fieldName[i - 1] === '\\\\' && (ch === '$' || ch === '.')) {\n      // escaped delimiter\n      current = current.substring(0, current.length - 1) + ch;\n    } else if (ch === '.') {\n      // When `.` is not escaped (above), it is a field delimiter\n      fields.push(current);\n      current = '';\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  var first = {$or: true, $nor: true};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        // or, nor\n        if (matcher instanceof Array) {\n          if (first[field]) {\n            first[field] = false;\n            res[field] = matcher;\n            return;\n          }\n\n          var entries = [];\n          res[field].forEach(function (existing) {\n            Object.keys(matcher).forEach(function (key) {\n              var m = matcher[key];\n              var longest = Math.max(Object.keys(existing).length, Object.keys(m).length);\n              var merged = mergeAndedSelectors([existing, m]);\n              if (Object.keys(merged).length <= longest) {\n                // we have a situation like: (a :{$eq :1} || ...) && (a {$eq: 2} || ...)\n                // merging would produce a $eq 2 when actually we shouldn't ever match against these merged conditions\n                // merged should always contain more values to be valid\n                return;\n              }\n              entries.push(merged);\n            });\n          });\n          res[field] = entries;\n        } else {\n          // not\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          } else if (operator === \"$regex\") {\n            return mergeRegex(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// combine $regex values into one array\nfunction mergeRegex(value, fieldMatchers) {\n  if ('$regex' in fieldMatchers) {\n    // a value could match multiple regexes\n    fieldMatchers.$regex.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$regex = [value];\n  }\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n    for (var prop in obj) {\n        if (Array.isArray(obj)) {\n            for (var i in obj) {\n                if (obj[i]['$and']) {\n                    obj[i] = mergeAndedSelectors(obj[i]['$and']);\n                }\n            }\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            mergeAndedSelectorsNested(value); // <- recursive call\n        }\n    }\n    return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n    for (var prop in obj) {\n        if (prop === '$and') {\n            isAnd = true;\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            isAnd = isAndInSelector(value, isAnd); // <- recursive call\n        }\n    }\n    return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n\n  //#7458: if $and is present in selector (at any level) merge nested $and\n  if (isAndInSelector(result, false)) {\n    result = mergeAndedSelectorsNested(result);\n    if ('$and' in result) {\n      result = mergeAndedSelectors(result['$and']);\n    }\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    }\n    result[field] = matcher;\n  }\n\n  normalizeArrayOperators(result);\n\n  return result;\n}\n\n//\n// The $ne and $regex values must be placed in an array because these operators can be used multiple times on the same field.\n// When $and is used, mergeAndedSelectors takes care of putting some of them into arrays, otherwise it's done here.\n//\nfunction normalizeArrayOperators(selector) {\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n\n    if (Array.isArray(matcher)) {\n      matcher.forEach(function (matcherItem) {\n        if (matcherItem && typeof matcherItem === 'object') {\n          normalizeArrayOperators(matcherItem);\n        }\n      });\n    } else if (field === '$ne') {\n      selector.$ne = [matcher];\n    } else if (field === '$regex') {\n      selector.$regex = [matcher];\n    } else if (matcher && typeof matcher === 'object') {\n      normalizeArrayOperators(matcher);\n    }\n  });\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (maybeUserOperator) {\n      var userValue = matcher[ maybeUserOperator ];\n      // explicit operator\n      if (maybeUserOperator.indexOf(\"$\") === 0) {\n        return match(maybeUserOperator, doc, userValue, parsedField, docFieldValue);\n      } else {\n        var subParsedField = parseField(maybeUserOperator);\n\n        if (\n          docFieldValue === undefined &&\n          typeof userValue !== \"object\" &&\n          subParsedField.length > 0\n        ) {\n          // the field does not exist, return or getFieldFromDoc will throw\n          return false;\n        }\n\n        var subDocFieldValue = getFieldFromDoc(docFieldValue, subParsedField);\n\n        if (typeof userValue === \"object\") {\n          // field value is an object that might contain more operators\n          return matchSelector(userValue, doc, parsedField, subDocFieldValue);\n        }\n\n        // implicit operator\n        return match(\"$eq\", doc, userValue, subParsedField, subDocFieldValue);\n      }\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    /* istanbul ignore next */\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  if (typeof docFieldValue !== \"number\" ||\n    parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  var divisor = userValue[0];\n  var mod = userValue[1];\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.some(function (docFieldValueItem) {\n        return collate(val, docFieldValueItem) === 0;\n      });\n    }\n\n    return collate(val, docFieldValue) === 0;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.some(function (docFieldValueItem) {\n      return collate(val, docFieldValueItem) === 0;\n    });\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      Array.isArray(docFieldValue) &&\n      arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      typeof docFieldValue == \"string\" &&\n      userValue.every(function (regexValue) {\n        return regexMatch(docFieldValue, regexValue);\n      });\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };\n","import { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { collate } from 'pouchdb-collate';\nimport { getFieldFromDoc, setFieldInDoc, parseField, matchesSelector, getKey, getValue, massageSelector, compare, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\n// throws if the user is using the wrong query field value type\nfunction checkFieldValueType(name, value, isHttp) {\n\tvar message = '';\n\tvar received = value;\n\tvar addReceived = true;\n\tif ([ '$in', '$nin', '$or', '$and', '$mod', '$nor', '$all' ].indexOf(name) !== -1) {\n\t\tif (!Array.isArray(value)) {\n\t\t\tmessage = 'Query operator ' + name + ' must be an array.';\n\n\t\t}\n\t}\n\n\tif ([ '$not', '$elemMatch', '$allMatch' ].indexOf(name) !== -1) {\n\t\tif (!(!Array.isArray(value) && typeof value === 'object' && value !== null)) {\n\t\t\tmessage = 'Query operator ' + name + ' must be an object.';\n\t\t}\n\t}\n\n\tif (name === '$mod' && Array.isArray(value)) {\n\t\tif (value.length !== 2) {\n\t\t\tmessage = 'Query operator $mod must be in the format [divisor, remainder], ' +\n\t\t\t\t'where divisor and remainder are both integers.';\n\t\t} else {\n\t\t\tvar divisor = value[0];\n\t\t\tvar mod = value[1];\n\t\t\tif (divisor === 0) {\n\t\t\t\tmessage = 'Query operator $mod\\'s divisor cannot be 0, cannot divide by zero.';\n\t\t\t\taddReceived = false;\n\t\t\t}\n\t\t\tif (typeof divisor !== 'number' || parseInt(divisor, 10) !== divisor) {\n\t\t\t\tmessage = 'Query operator $mod\\'s divisor is not an integer.';\n\t\t\t\treceived = divisor;\n\t\t\t}\n\t\t\tif (parseInt(mod, 10) !== mod) {\n\t\t\t\tmessage = 'Query operator $mod\\'s remainder is not an integer.';\n\t\t\t\treceived = mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (name === '$exists') {\n\t\tif (typeof value !== 'boolean') {\n\t\t\tmessage = 'Query operator $exists must be a boolean.';\n\t\t}\n\t}\n\n\tif (name === '$type') {\n\t\tvar allowed = [ 'null', 'boolean', 'number', 'string', 'array', 'object' ];\n\t\tvar allowedStr = '\"' + allowed.slice(0, allowed.length - 1).join('\", \"') + '\", or \"' + allowed[allowed.length - 1] + '\"';\n\t\tif (typeof value !== 'string') {\n\t\t\tmessage = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n\t\t} else if (allowed.indexOf(value) == -1) {\n\t\t\tmessage = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n\t\t}\n\t}\n\n\tif (name === '$size') {\n\t\tif (parseInt(value, 10) !== value) {\n\t\t\tmessage = 'Query operator $size must be a integer.';\n\t\t}\n\t}\n\n\tif (name === '$regex') {\n\t\tif (typeof value !== 'string') {\n\t\t\tif (isHttp) {\n\t\t\t\tmessage = 'Query operator $regex must be a string.';\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tmessage = 'Query operator $regex must be a string or an instance ' +\n\t\t\t\t\t'of a javascript regular expression.';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (message) {\n\t\tif (addReceived) {\n\n\t\t\tvar type = received === null\n\t\t\t? ' '\n\t\t\t: Array.isArray(received)\n\t\t\t? ' array'\n\t\t\t: ' ' + typeof received;\n\t\t\tvar receivedStr = typeof received === 'object' && received !== null\n\t\t\t?  JSON.stringify(received, null, '\\t')\n\t\t\t: received;\n\n\t\t\tmessage += ' Received' + type + ': ' + receivedStr;\n\t\t}\n\t\tthrow new Error(message);\n\t}\n}\n\n\nvar requireValidation = [ '$all', '$allMatch', '$and', '$elemMatch', '$exists', '$in', '$mod', '$nin', '$nor', '$not', '$or', '$regex', '$size', '$type' ];\n\nvar arrayTypeComparisonOperators = [ '$in', '$nin', '$mod', '$all'];\n\nvar equalityOperators = [ '$eq', '$gt', '$gte', '$lt', '$lte' ];\n\n// recursively walks down the a query selector validating any operators\nfunction validateSelector(input, isHttp) {\n\tif (Array.isArray(input)) {\n\t\tfor (var entry of input) {\n\t\t\tif (typeof entry === 'object' && value !== null) {\n\t\t\t\tvalidateSelector(entry, isHttp);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar fields = Object.keys(input);\n\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar key = fields[i];\n\t\t\tvar value = input[key];\n\n\t\t\tif (requireValidation.indexOf(key) !== -1) {\n\t\t\t\tcheckFieldValueType(key, value, isHttp);\n\t\t\t}\n\t\t\tif (equalityOperators.indexOf(key) !== -1) {\n\t\t\t\t// skip, explicit comparison operators can be anything\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (arrayTypeComparisonOperators.indexOf(key) !== -1) {\n\t\t\t\t// skip, their values are already valid\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof value === 'object' && value !== null) {\n\t\t\t\tvalidateSelector(value, isHttp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({'Content-type': 'application/json'});\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  validateSelector(requestDef.selector, true);\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  dbFetch(db, url, {method: 'DELETE'}, callback);\n}\n\nfunction callbackify(fun) {\n  return function (...args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  };\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = function (...args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n};\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit, selector) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit, selector) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit, selector);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit, selector);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit, selector);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit, selector);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  const fields = Object.keys(mapFunDef.fields);\n  const partialSelector = mapFunDef.partial_filter_selector;\n\n  return createMapper(fields, emit, partialSelector);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\nfunction abstractMapper$1 (db) {\n  if (db._customFindAbstractMapper) {\n    return {\n      // Calls the _customFindAbstractMapper, but with a third argument:\n      // the standard findAbstractMapper query/viewCleanup.\n      // This allows the indexeddb adapter to support partial_filter_selector.\n      query: function addQueryFallback(signature, opts) {\n        var fallback = abstractMapper.query.bind(this);\n        return db._customFindAbstractMapper.query.call(this, signature, opts, fallback);\n      },\n      viewCleanup: function addViewCleanupFallback() {\n        var fallback = abstractMapper.viewCleanup.bind(this);\n        return db._customFindAbstractMapper.viewCleanup.call(this, fallback);\n      }\n    };\n  }\n  return abstractMapper;\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  if (indexDef.partial_filter_selector) {\n    indexDef.partial_filter_selector = massageSelector(\n      indexDef.partial_filter_selector\n    );\n  }\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(getFieldFromDoc(doc, parseField(field)));\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields),\n        partial_filter_selector: requestDef.index.partial_filter_selector\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper$1(db).query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\nconst SHORT_CIRCUIT_QUERY = {\n  queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n  inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.filter(function (index) {\n    return checkIndexMatches(index, sortOrder, userFields, selector);\n  });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n\n  return {\n    startkey: COLLATE_LO\n  };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n      finish(i);\n      break;\n    } else if (i > 0) {\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction shouldShortCircuit(selector) {\n  // We have a field to select from, but not a valid value\n  // this should result in a short circuited query \n  // just like the http adapter (couchdb) and mongodb\n  // see tests for issue #7810\n  \n  // @todo Use 'Object.values' when Node.js v6 support is dropped.\n  const values = Object.keys(selector).map(function (key) {\n    return selector[key];\n  });\n  return values.some(function (val) { \n    return typeof val === 'object' && Object.keys(val).length === 0;\n});\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  if (shouldShortCircuit(selector)) {\n    return assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n  }\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  if (opts.limit > 0 && opts.indexes_count) {\n    // brute force and quite naive impl.\n    // amp up the limit with the amount of (indexes) design docs\n    // or is this too naive? How about skip?\n    opts.original_limit = opts.limit;\n    opts.limit += opts.indexes_count;\n  }\n\n  return db.allDocs(opts)\n    .then(function (res) {\n      // filter out any design docs that _all_docs might return\n      res.rows = res.rows.filter(function (row) {\n        return !/^_design\\//.test(row.id);\n      });\n      // put back original limit\n      if (opts.original_limit) {\n        opts.limit = opts.original_limit;\n      }\n      // enforce the rows to respect the given limit\n      res.rows = res.rows.slice(0, opts.limit);\n      return res;\n    });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    // must be validated before massaging\n    validateSelector(requestDef.selector, false);\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false,\n      // Add amount of index for doAllDocs to use (related to issue #7810)\n      indexes_count: getIndexesRes.total_rows,\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper$1(db).query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'No matching index found, create an index to optimize query time.';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper$1(db).viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport PouchDB from \"pouchdb-browser\";\nimport pouchdbFind from \"pouchdb-find\";\nPouchDB.plugin(pouchdbFind);\nlet posts;\nlet socials;\nlet users;\nlet messages;\nlet guids;\nlet transactions;\nlet categories;\nlet subcategories;\nlet locations;\nlet sublocations;\nlet socialcategories;\nlet settings;\nfunction initDatabase() {\n    posts = new PouchDB(\".pouchdb/posts\");\n    socials = new PouchDB(\".pouchdb/socials\");\n    users = new PouchDB(\".pouchdb/users\");\n    messages = new PouchDB(\".pouchdb/messages\");\n    guids = new PouchDB(\".pouchdb/guids\");\n    transactions = new PouchDB(\".pouchdb/transactions\");\n    categories = new PouchDB(\".pouchdb/categories\");\n    socialcategories = new PouchDB(\".pouchdb/socialcategories\");\n    subcategories = new PouchDB(\".pouchdb/subcategories\");\n    locations = new PouchDB(\".pouchdb/locations\");\n    sublocations = new PouchDB(\".pouchdb/sublocations\");\n    settings = new PouchDB(\".pouchdb/settings\");\n}\ninitDatabase();\nlet database = {\n    insertPost: function (postObj) {\n        postObj._id = postObj.guid;\n        return posts.put(postObj);\n    },\n    insertSocial: function (socialObj) {\n        socialObj._id = socialObj.guid;\n        return socials.put(socialObj);\n    },\n    insertUser: function (userObj) {\n        userObj._id = userObj.user;\n        return users.put(userObj);\n    },\n    findUserByName: function (name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result = yield users.find({\n                selector: { user: name },\n            });\n            return result.docs[0];\n        });\n    },\n    findUserByStakeAddr: function (addr) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result = yield users.find({\n                selector: { stakeAddress: addr },\n            });\n            return result.docs[0];\n        });\n    },\n    insertMessage: function (obj) {\n        obj._id = obj.guid;\n        return messages.put(obj);\n    },\n    insertGuid: function (obj) {\n        obj._id = obj.guid;\n        return guids.put(obj);\n    },\n    findGuid: function (id) {\n        return guids.get(id).catch(function (err) { });\n    },\n    insertTransaction: function (obj) {\n        obj._id = obj.transactionId;\n        return transactions.put(obj);\n    },\n    findTransaction: function (id) {\n        return transactions.get(id).catch(function (err) { });\n    },\n    incrementCategory: function (obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            obj._id = obj.category;\n            let oldObj = yield categories.get(obj._id).catch(function (err) { });\n            if (oldObj) {\n                obj._rev = oldObj._rev;\n                obj.count = oldObj.count + 1;\n            }\n            else\n                obj.count = 1;\n            return categories.put(obj);\n        });\n    },\n    incrementSocialCategory: function (obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            obj._id = obj.category;\n            let oldObj = yield socialcategories.get(obj._id).catch(function (err) { });\n            if (oldObj) {\n                obj._rev = oldObj._rev;\n                obj.count = oldObj.count + 1;\n            }\n            else\n                obj.count = 1;\n            return socialcategories.put(obj);\n        });\n    },\n    incrementSubcategory: function (obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            obj._id = obj.subcategory;\n            let oldObj = yield subcategories.get(obj._id).catch(function (err) { });\n            if (oldObj) {\n                obj._rev = oldObj._rev;\n                obj.count = oldObj.count + 1;\n            }\n            else\n                obj.count = 1;\n            return subcategories.put(obj);\n        });\n    },\n    incrementLocation: function (obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            obj._id = obj.location;\n            let oldObj = yield locations.get(obj._id).catch(function (err) { });\n            if (oldObj) {\n                obj._rev = oldObj._rev;\n                obj.count = oldObj.count + 1;\n            }\n            else\n                obj.count = 1;\n            return locations.put(obj);\n        });\n    },\n    incrementSublocation: function (obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            obj._id = obj.sublocation;\n            let oldObj = yield sublocations.get(obj._id).catch(function (err) { });\n            if (oldObj) {\n                obj._rev = oldObj._rev;\n                obj.count = oldObj.count + 1;\n            }\n            else\n                obj.count = 1;\n            return sublocations.put(obj);\n        });\n    },\n    listPosts: function (category) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield posts.createIndex({\n                index: { fields: [\"ts\"] },\n            });\n            let result = yield posts.find({\n                selector: category\n                    ? { ts: { $gte: null }, category: category }\n                    : { ts: { $gte: null } },\n                sort: [\"ts\"],\n                limit: 100,\n            });\n            return result.docs;\n        });\n    },\n    listSocials: function (category) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield socials.createIndex({\n                index: { fields: [\"ts\"] },\n            });\n            let result = yield socials.find({\n                selector: category\n                    ? { ts: { $gte: null }, category: category }\n                    : { ts: { $gte: null } },\n                sort: [\"ts\"],\n                limit: 100,\n            });\n            return result.docs;\n        });\n    },\n    listMessages: function (user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield messages.createIndex({\n                index: { fields: [\"ts\"] },\n            });\n            let result = yield messages.find({\n                selector: { ts: { $gte: null }, $or: [{ to: user }, { from: user }] },\n                sort: [\"ts\"],\n                limit: 100,\n            });\n            return result.docs;\n        });\n    },\n    listCategories: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield categories.createIndex({\n                index: { fields: [\"count\"] },\n            });\n            let result = yield categories.find({\n                selector: { count: { $gte: null } },\n                sort: [\"count\"],\n                limit: 20,\n            });\n            return result.docs;\n        });\n    },\n    listSocialCategories: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield socialcategories.createIndex({\n                index: { fields: [\"count\"] },\n            });\n            let result = yield socialcategories.find({\n                selector: { count: { $gte: null } },\n                sort: [\"count\"],\n                limit: 20,\n            });\n            return result.docs;\n        });\n    },\n    listSubcategories: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield subcategories.createIndex({\n                index: { fields: [\"count\"] },\n            });\n            let result = yield subcategories.find({\n                selector: { count: { $gte: null } },\n                sort: [\"count\"],\n                limit: 20,\n            });\n            return result.docs;\n        });\n    },\n    listLocations: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield locations.createIndex({\n                index: { fields: [\"count\"] },\n            });\n            let result = yield locations.find({\n                selector: { count: { $gte: null } },\n                sort: [\"count\"],\n                limit: 20,\n            });\n            return result.docs;\n        });\n    },\n    listSublocations: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield sublocations.createIndex({\n                index: { fields: [\"count\"] },\n            });\n            let result = yield sublocations.find({\n                selector: { count: { $gte: null } },\n                sort: [\"count\"],\n                limit: 20,\n            });\n            return result.docs;\n        });\n    },\n    insertSettings: function (settingsObj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            settingsObj._id = \"settings\";\n            let oldObj = yield settings.get(settingsObj._id).catch(function (err) { });\n            if (oldObj) {\n                settingsObj._rev = oldObj._rev;\n            }\n            return settings.put(settingsObj, { force: true });\n        });\n    },\n    findSettings: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            let dbSettings = yield settings.get(\"settings\").catch(function (err) { });\n            return dbSettings;\n        });\n    },\n    clearDatabase: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            const savedSettings = yield this.findSettings();\n            console.log(savedSettings);\n            console.log(\"Deleting db...\");\n            Promise.all([\n                posts.destroy(),\n                socials.destroy(),\n                users.destroy(),\n                messages.destroy(),\n                guids.destroy(),\n                transactions.destroy(),\n                categories.destroy(),\n                socialcategories.destroy(),\n                subcategories.destroy(),\n                locations.destroy(),\n                sublocations.destroy(),\n                settings.destroy(),\n            ]).then(() => {\n                console.log(\"Starting db...\");\n                initDatabase();\n                database.insertSettings(savedSettings);\n            });\n        });\n    },\n};\nexport const getDb = () => {\n    return database;\n};\n","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.0.0'] && _();\n}\ncatch (e) { }\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:precaching:7.0.0'] && _();\n}\ncatch (e) { }\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:routing:7.0.0'] && _();\n}\ncatch (e) { }\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:7.0.0'] && _();\n}\ncatch (e) { }\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../../_version.js';\nexport const messages = {\n    'invalid-value': ({ paramName, validValueDescription, value }) => {\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return (`The '${paramName}' parameter was given a value with an ` +\n            `unexpected value. ${validValueDescription} Received a value of ` +\n            `${JSON.stringify(value)}.`);\n    },\n    'not-an-array': ({ moduleName, className, funcName, paramName }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${className}.${funcName}()' must be an array.`);\n    },\n    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName, }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${classNameStr}` +\n            `${funcName}()' must be of type ${expectedType}.`);\n    },\n    'incorrect-class': ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem, }) => {\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        if (isReturnValueProblem) {\n            return (`The return value from ` +\n                `'${moduleName}.${classNameStr}${funcName}()' ` +\n                `must be an instance of class ${expectedClassName}.`);\n        }\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${classNameStr}${funcName}()' ` +\n            `must be an instance of class ${expectedClassName}.`);\n    },\n    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName, }) => {\n        if (!expectedMethod ||\n            !paramName ||\n            !moduleName ||\n            !className ||\n            !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return (`${moduleName}.${className}.${funcName}() expected the ` +\n            `'${paramName}' parameter to expose a '${expectedMethod}' method.`);\n    },\n    'add-to-cache-list-unexpected-type': ({ entry }) => {\n        return (`An unexpected entry was passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\n            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\n            `strings with one or more characters, objects with a url property or ` +\n            `Request objects.`);\n    },\n    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {\n        if (!firstEntry || !secondEntry) {\n            throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return (`Two of the entries passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n            `${firstEntry} but different revision details. Workbox is ` +\n            `unable to cache and version the asset correctly. Please remove one ` +\n            `of the entries.`);\n    },\n    'plugin-error-request-will-fetch': ({ thrownErrorMessage }) => {\n        if (!thrownErrorMessage) {\n            throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n        return (`An error was thrown by a plugins 'requestWillFetch()' method. ` +\n            `The thrown error message was: '${thrownErrorMessage}'.`);\n    },\n    'invalid-cache-name': ({ cacheNameId, value }) => {\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return (`You must provide a name containing at least one character for ` +\n            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +\n            `'${JSON.stringify(value)}'`);\n    },\n    'unregister-route-but-not-found-with-method': ({ method }) => {\n        if (!method) {\n            throw new Error(`Unexpected input to ` +\n                `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return (`The route you're trying to unregister was not  previously ` +\n            `registered for the method type '${method}'.`);\n    },\n    'unregister-route-route-not-registered': () => {\n        return (`The route you're trying to unregister was not previously ` +\n            `registered.`);\n    },\n    'queue-replay-failed': ({ name }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    'duplicate-queue-name': ({ name }) => {\n        return (`The Queue name '${name}' is already being used. ` +\n            `All instances of backgroundSync.Queue must be given unique names.`);\n    },\n    'expired-test-without-max-age': ({ methodName, paramName }) => {\n        return (`The '${methodName}()' method can only be used when the ` +\n            `'${paramName}' is used in the constructor.`);\n    },\n    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {\n        return (`The supplied '${paramName}' parameter was an unsupported type. ` +\n            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\n            `valid input types.`);\n    },\n    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName, }) => {\n        return (`The supplied '${paramName}' parameter must be an array of ` +\n            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\n            `Please check the call to ${moduleName}.${className}.${funcName}() ` +\n            `to fix the issue.`);\n    },\n    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {\n        return (`You must define either config.maxEntries or config.maxAgeSeconds` +\n            `in ${moduleName}.${className}.${funcName}`);\n    },\n    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {\n        return (`You must define either config.statuses or config.headers` +\n            `in ${moduleName}.${className}.${funcName}`);\n    },\n    'invalid-string': ({ moduleName, funcName, paramName }) => {\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return (`When using strings, the '${paramName}' parameter must start with ` +\n            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\n            `Please see the docs for ${moduleName}.${funcName}() for ` +\n            `more info.`);\n    },\n    'channel-name-required': () => {\n        return (`You must provide a channelName to construct a ` +\n            `BroadcastCacheUpdate instance.`);\n    },\n    'invalid-responses-are-same-args': () => {\n        return (`The arguments passed into responsesAreSame() appear to be ` +\n            `invalid. Please ensure valid Responses are used.`);\n    },\n    'expire-custom-caches-only': () => {\n        return (`You must provide a 'cacheName' property when using the ` +\n            `expiration plugin with a runtime caching strategy.`);\n    },\n    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return (`The 'unit' portion of the Range header must be set to 'bytes'. ` +\n            `The Range header provided was \"${normalizedRangeHeader}\"`);\n    },\n    'single-range-only': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return (`Multiple ranges are not supported. Please use a  single start ` +\n            `value, and optional end value. The Range header provided was ` +\n            `\"${normalizedRangeHeader}\"`);\n    },\n    'invalid-range-values': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return (`The Range header is missing both start and end values. At least ` +\n            `one of those values is needed. The Range header provided was ` +\n            `\"${normalizedRangeHeader}\"`);\n    },\n    'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n    },\n    'range-not-satisfiable': ({ size, start, end }) => {\n        return (`The start (${start}) and end (${end}) values in the Range are ` +\n            `not satisfiable by the cached response, which is ${size} bytes.`);\n    },\n    'attempt-to-cache-non-get-request': ({ url, method }) => {\n        return (`Unable to cache '${url}' because it is a '${method}' request and ` +\n            `only 'GET' requests can be cached.`);\n    },\n    'cache-put-with-no-response': ({ url }) => {\n        return (`There was an attempt to cache '${url}' but the response was not ` +\n            `defined.`);\n    },\n    'no-response': ({ url, error }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    'bad-precaching-response': ({ url, status }) => {\n        return (`The precaching request for '${url}' failed` +\n            (status ? ` with an HTTP status of ${status}.` : `.`));\n    },\n    'non-precached-url': ({ url }) => {\n        return (`createHandlerBoundToURL('${url}') was called, but that URL is ` +\n            `not precached. Please pass in a URL that is precached instead.`);\n    },\n    'add-to-cache-list-conflicting-integrities': ({ url }) => {\n        return (`Two of the entries passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n            `${url} with different integrity values. Please remove one of them.`);\n    },\n    'missing-precache-entry': ({ cacheName, url }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    'cross-origin-copy-response': ({ origin }) => {\n        return (`workbox-core.copyResponse() can only be used with same-origin ` +\n            `responses. It was passed a response with origin ${origin}.`);\n    },\n    'opaque-streams-source': ({ type }) => {\n        const message = `One of the workbox-streams sources resulted in an ` +\n            `'${type}' response.`;\n        if (type === 'opaqueredirect') {\n            return (`${message} Please do not use a navigation request that results ` +\n                `in a redirect as a source.`);\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = (code, ...args) => {\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {}) => {\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nexport const messageGenerator = process.env.NODE_ENV === 'production' ? fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\nexport { WorkboxError };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from '../_private/WorkboxError.js';\nimport '../_version.js';\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, details) => {\n    if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details) => {\n    const type = typeof object[expectedMethod];\n    if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n    }\n};\nconst isType = (object, expectedType, details) => {\n    if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n    }\n};\nconst isInstance = (object, \n// Need the general type to do the check later.\n// eslint-disable-next-line @typescript-eslint/ban-types\nexpectedClass, details) => {\n    if (!(object instanceof expectedClass)) {\n        details['expectedClassName'] = expectedClass.name;\n        throw new WorkboxError('incorrect-class', details);\n    }\n};\nconst isOneOf = (value, validValues, details) => {\n    if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n    }\n};\nconst isArrayOfClass = (value, \n// Need general type to do check later.\nexpectedClass, // eslint-disable-line\ndetails) => {\n    const error = new WorkboxError('not-array-of-class', details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports = process.env.NODE_ENV === 'production'\n    ? null\n    : {\n        hasMethod,\n        isArray,\n        isInstance,\n        isOneOf,\n        isType,\n        isArrayOfClass,\n    };\nexport { finalAssertExports as assert };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst _cacheNameDetails = {\n    googleAnalytics: 'googleAnalytics',\n    precache: 'precache-v2',\n    prefix: 'workbox',\n    runtime: 'runtime',\n    suffix: typeof registration !== 'undefined' ? registration.scope : '',\n};\nconst _createCacheName = (cacheName) => {\n    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n        .filter((value) => value && value.length > 0)\n        .join('-');\n};\nconst eachCacheNameDetail = (fn) => {\n    for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n    }\n};\nexport const cacheNames = {\n    updateDetails: (details) => {\n        eachCacheNameDetail((key) => {\n            if (typeof details[key] === 'string') {\n                _cacheNameDetails[key] = details[key];\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: () => {\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: () => {\n        return _cacheNameDetails.suffix;\n    },\n};\n","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\nfunction waitUntil(event, asyncFn) {\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n}\nexport { waitUntil };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function createCacheKey(entry) {\n    if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n    if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href,\n    };\n}\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\nclass PrecacheInstallReportPlugin {\n    constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({ request, state, }) => {\n            // TODO: `state` should never be undefined...\n            if (state) {\n                state.originalRequest = request;\n            }\n        };\n        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {\n            if (event.type === 'install') {\n                if (state &&\n                    state.originalRequest &&\n                    state.originalRequest instanceof Request) {\n                    // TODO: `state` should never be undefined...\n                    const url = state.originalRequest.url;\n                    if (cachedResponse) {\n                        this.notUpdatedURLs.push(url);\n                    }\n                    else {\n                        this.updatedURLs.push(url);\n                    }\n                }\n            }\n            return cachedResponse;\n        };\n    }\n}\nexport { PrecacheInstallReportPlugin };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\nclass PrecacheCacheKeyPlugin {\n    constructor({ precacheController }) {\n        this.cacheKeyWillBeUsed = async ({ request, params, }) => {\n            // Params is type any, can't change right now.\n            /* eslint-disable */\n            const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) ||\n                this._precacheController.getCacheKeyForURL(request.url);\n            /* eslint-enable */\n            return cacheKey\n                ? new Request(cacheKey, { headers: request.headers })\n                : request;\n        };\n        this._precacheController = precacheController;\n    }\n}\nexport { PrecacheCacheKeyPlugin };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            }\n            catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport { WorkboxError } from './_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof workbox-core\n */\nasync function copyResponse(response, modifier) {\n    let origin = null;\n    // If response.url isn't set, assume it's cross-origin and keep origin null.\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', { origin });\n    }\n    const clonedResponse = response.clone();\n    // Create a fresh `ResponseInit` object by cloning the headers.\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText,\n    };\n    // Apply any user modifications.\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    // Create the new response from the body stream and `ResponseInit`\n    // modifications. Note: not all browsers support the Response.body stream,\n    // so fall back to reading the entire body into memory as a blob.\n    const body = canConstructResponseFromBodyStream()\n        ? clonedResponse.body\n        : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n}\nexport { copyResponse };\n","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams) {\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\n/**\n * Matches an item in the cache, ignoring specific URL params. This is similar\n * to the `ignoreSearch` option, but it allows you to ignore just specific\n * params (while continuing to match on the others).\n *\n * @private\n * @param {Cache} cache\n * @param {Request} request\n * @param {Object} matchOptions\n * @param {Array<string>} ignoreParams\n * @return {Promise<Response|undefined>}\n */\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    // If the request doesn't include any ignored params, match as normal.\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    // Otherwise, match by comparing keys\n    const keysOptions = Object.assign(Object.assign({}, matchOptions), { ignoreSearch: true });\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys) {\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\nexport { cacheMatchIgnoreParams };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n// Callbacks to be executed whenever there's a quota error.\n// Can't change Function type right now.\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst quotaErrorCallbacks = new Set();\nexport { quotaErrorCallbacks };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns a promise that resolves and the passed number of milliseconds.\n * This utility is an async/await-friendly version of `setTimeout`.\n *\n * @param {number} ms\n * @return {Promise}\n * @private\n */\nexport function timeout(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst getFriendlyURL = (url) => {\n    const urlObj = new URL(String(url), location.href);\n    // See https://github.com/GoogleChrome/workbox/issues/2323\n    // We want to include everything, except for the origin if it's same-origin.\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n};\nexport { getFriendlyURL };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from '../_private/logger.js';\nimport { quotaErrorCallbacks } from '../models/quotaErrorCallbacks.js';\nimport '../_version.js';\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox-core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` +\n            `callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks) {\n        await callback();\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(callback, 'is complete.');\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log('Finished running callbacks.');\n    }\n}\nexport { executeQuotaErrorCallbacks };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            // Do not add integrity if the original request is no-cors\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors'\n                    ? integrityInRequest || integrityInManifest\n                    : undefined,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            // Also if the original request users no-cors we don't use integrity.\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            if (integrityInManifest &&\n                noIntegrityConflict &&\n                request.mode !== 'no-cors') {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n        precacheController = new PrecacheController();\n    }\n    return precacheController;\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n    'DELETE',\n    'GET',\n    'HEAD',\n    'PATCH',\n    'POST',\n    'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n    if (handler && typeof handler === 'object') {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.hasMethod(handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return handler;\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(handler, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return { handle: handler };\n    }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { defaultMethod, validMethods } from './utils/constants.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox-routing\n */\nclass Route {\n    /**\n     * Constructor for Route class.\n     *\n     * @param {workbox-routing~matchCallback} match\n     * A callback function that determines whether the route matches a given\n     * `fetch` event by returning a non-falsy value.\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(match, handler, method = defaultMethod) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(match, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'match',\n            });\n            if (method) {\n                assert.isOneOf(method, validMethods, { paramName: 'method' });\n            }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    /**\n     *\n     * @param {workbox-routing-handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response\n     */\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\nexport { Route };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * {@link workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * @memberof workbox-routing\n * @extends workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n    /**\n     * If the regular expression contains\n     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n     * the captured values will be passed to the\n     * {@link workbox-routing~handlerCallback} `params`\n     * argument.\n     *\n     * @param {RegExp} regExp The regular expression to match against URLs.\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(regExp, handler, method) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(regExp, RegExp, {\n                moduleName: 'workbox-routing',\n                className: 'RegExpRoute',\n                funcName: 'constructor',\n                paramName: 'pattern',\n            });\n        }\n        const match = ({ url }) => {\n            const result = regExp.exec(url.href);\n            // Return immediately if there's no match.\n            if (!result) {\n                return;\n            }\n            // Require that the match start at the first character in the URL string\n            // if it's a cross-origin request.\n            // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n            // behind this behavior.\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` +\n                        `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` +\n                        `handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            // If the route matches, but there aren't any capture groups defined, then\n            // this will return [], which is truthy and therefore sufficient to\n            // indicate a match.\n            // If there are capture groups, then it will return their values.\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\nexport { RegExpRoute };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            // event.data is type 'any'\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request, event });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    void requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle.\n     * @param {ExtendableEvent} options.event The event that triggered the\n     *     request.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event, }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url,\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([`Found a route to handle this request:`, route]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise &&\n            (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err) => {\n                // If there's a route catch handler, process that first\n                if (catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({ url, request, event, params });\n                    }\n                    catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({ url, request, event });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n     *     against the current origin.\n     * @param {Request} options.request The request to match.\n     * @param {Event} options.event The corresponding event.\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, sameOrigin, request, event, }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            // route.match returns type any, not possible to change right now.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const matchResult = route.match({ url, sameOrigin, request, event });\n            if (matchResult) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Warn developers that using an async matchCallback is almost always\n                    // not the right thing to do.\n                    if (matchResult instanceof Promise) {\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +\n                            `matchCallback function was used. Please convert the ` +\n                            `following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if (matchResult.constructor === Object && // eslint-disable-line\n                    Object.keys(matchResult).length === 0) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to associate with this\n     * default handler. Each method has its own default.\n     */\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Router } from '../Router.js';\nimport '../_version.js';\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n    if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n    }\n    return defaultRouter;\n};\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\nclass PrecacheRoute extends Route {\n    /**\n     * @param {PrecacheController} precacheController A `PrecacheController`\n     * instance used to both match requests and respond to fetch events.\n     * @param {Object} [options] Options to control how requests are matched\n     * against the list of precached URLs.\n     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n     * check cache entries for a URLs ending with '/' to see if there is a hit when\n     * appending the `directoryIndex` value.\n     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n     * array of regex's to remove search params when looking for a cache match.\n     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n     * check the cache for the URL with a `.html` added to the end of the end.\n     * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n     * This is a function that should take a URL and return an array of\n     * alternative URLs that should be checked for precache matches.\n     */\n    constructor(precacheController, options) {\n        const match = ({ request, }) => {\n            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n            for (const possibleURL of generateURLVariations(request.url, options)) {\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n                    return { cacheKey, integrity };\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n            }\n            return;\n        };\n        super(match, precacheController.strategy);\n    }\n}\nexport { PrecacheRoute };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { removeIgnoredSearchParams } from './removeIgnoredSearchParams.js';\nimport '../_version.js';\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({ url: urlObject });\n        for (const urlToAttempt of additionalURLs) {\n            yield urlToAttempt.href;\n        }\n    }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n    // Convert the iterable into an array at the start of the loop to make sure\n    // deletion doesn't mess up iteration.\n    for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport { PrecacheRoute } from './PrecacheRoute.js';\nimport './_version.js';\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n * options.\n *\n * @memberof workbox-precaching\n */\nfunction addRoute(options) {\n    const precacheController = getOrCreatePrecacheController();\n    const precacheRoute = new PrecacheRoute(precacheController, options);\n    registerRoute(precacheRoute);\n}\nexport { addRoute };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call {@link workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox-routing.Route} The generated `Route`.\n *\n * @memberof workbox-routing\n */\nfunction registerRoute(capture, handler, method) {\n    let route;\n    if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n                throw new WorkboxError('invalid-string', {\n                    moduleName: 'workbox-routing',\n                    funcName: 'registerRoute',\n                    paramName: 'capture',\n                });\n            }\n            // We want to check if Express-style wildcards are in the pathname only.\n            // TODO: Remove this log message in v4.\n            const valueToCheck = capture.startsWith('http')\n                ? captureUrl.pathname\n                : capture;\n            // See https://github.com/pillarjs/path-to-regexp#parameters\n            const wildcards = '[*:?+]';\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +\n                    `character (${wildcards}). Strings are now always interpreted as ` +\n                    `exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                if (url.pathname === captureUrl.pathname &&\n                    url.origin !== captureUrl.origin) {\n                    logger.debug(`${capture} only partially matches the cross-origin URL ` +\n                        `${url.toString()}. This route will only handle cross-origin requests ` +\n                        `if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n    }\n    else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n    }\n    else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n    }\n    else if (capture instanceof Route) {\n        route = capture;\n    }\n    else {\n        throw new WorkboxError('unsupported-route-type', {\n            moduleName: 'workbox-routing',\n            funcName: 'registerRoute',\n            paramName: 'capture',\n        });\n    }\n    const defaultRouter = getOrCreateDefaultRouter();\n    defaultRouter.registerRoute(route);\n    return route;\n}\nexport { registerRoute };\n","\r\nconst db = require('../db/dbConnection');\r\n\r\nconst defaultCategories = [\r\n  {category: 'Electronics', count: 0},\r\n  {category: 'Fashion', count: 0},\r\n  {category: 'Health & Beauty', count: 0},\r\n  {category: 'Home & Garden', count: 0},\r\n  {category: 'Sports', count: 0},\r\n  {category: 'Collectibles and Art', count: 0},\r\n  {category: 'Industrial equipment', count: 0},\r\n  {category: 'Motors', count: 0}\r\n];\r\n\r\n// get categories \r\nasync function getCategories() {\r\n  const database = db.getDb();\r\n\r\n  let categories = await database.listCategories();\r\n  categories = categories.concat(defaultCategories.filter(x => categories.every(y => x.category != y.category)));\r\n  categories = categories.slice(0, 20);\r\n\r\n  let categoriesDto = categories.map(\r\n    ({ category, count }) => \r\n    ({ \r\n      name: category, \r\n      count: count,\r\n    }));\r\n\r\n  return categoriesDto;\r\n}\r\n\r\nexport { getCategories }\r\n","const db = require(\"../db/dbConnection\");\r\n\r\n// get config\r\nasync function getConfig() {\r\n  const database = db.getDb();\r\n\r\n  let settings = await database.findSettings();\r\n  let isProd = !settings || settings.isProd;\r\n\r\n  let config = isProd\r\n    ? {\r\n        FOLLOW_TRANSACTION_URL: \"https://cardanoscan.io/transaction/\",\r\n        WALLET_ADDRESS:\r\n          \"addr1qxhz3awnfyy5frmusy56ryrjjv53fdeygtdt8x6tupvykpnt2zdd2zgwjlww68p93x66xtertaqtctk5lpx9n6jugq4sjwn0u0\",\r\n        KOIOS_URL: \"https://api.koios.rest/api/v1\",\r\n        KOIOS_KEY:\r\n          \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZGRyIjoic3Rha2UxdTk0NHB4azRweThmMGg4ZHJzamNuZGRyOXUzNDdzOXU5bTIwc256ZWFmd3lxMmN4M2s5NjUiLCJleHAiOjE3MzgxMDAwNDMsInRpZXIiOjEsInByb2pJRCI6ImNhcmRhbm8ifQ.EhUGSZsofThIZL30uwkZKnJ4O3AghqRXwcoRTiL88TA\",\r\n        BLOCKFROST_URL: \"https://cardano-mainnet.blockfrost.io/api/v0\",\r\n        BLOCKFROST_KEY: \"mainnetN08Xw3dFGIrTiXdK6AfE8FGMXJwqEU3E\",\r\n        METADATA_LABEL: 989,\r\n        POLLING_INTERVAL: 10000,\r\n      }\r\n    : {\r\n        FOLLOW_TRANSACTION_URL: \"https://preprod.cardanoscan.io/transaction/\",\r\n        WALLET_ADDRESS:\r\n          \"addr_test1qrztg7gawfx52upqqjty6zz868mmyzlp620xhvhqfh35rxrxjm6xyw8p6zs69fzxg93l5674a8j3w0v44c38dzdvtn9qlkqf4x\",\r\n        KOIOS_URL: \"https://preprod.koios.rest/api/v1\",\r\n        KOIOS_KEY:\r\n          \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZGRyIjoic3Rha2UxdTk0NHB4azRweThmMGg4ZHJzamNuZGRyOXUzNDdzOXU5bTIwc256ZWFmd3lxMmN4M2s5NjUiLCJleHAiOjE3MzgxMDAwNDMsInRpZXIiOjEsInByb2pJRCI6ImNhcmRhbm8ifQ.EhUGSZsofThIZL30uwkZKnJ4O3AghqRXwcoRTiL88TA\",\r\n        BLOCKFROST_URL: \"https://cardano-preprod.blockfrost.io/api/v0\",\r\n        BLOCKFROST_KEY: \"preprodn0MIxSnJ4Qg4CmmXdstYgHeXth1DuAH7\",\r\n        METADATA_LABEL: 989,\r\n        POLLING_INTERVAL: 10000,\r\n      };\r\n\r\n  console.log(config);\r\n  return config;\r\n}\r\n\r\nexport { getConfig };\r\n","\r\nconst db = require('../db/dbConnection');\r\n\r\n// get locations\r\nasync function getLocations() {\r\n  const database = db.getDb();\r\n\r\n  let locations = await database.listLocations();\r\n\r\n  let locationsDto = locations.map(\r\n    ({ location, count }) => \r\n    ({ \r\n      name: location, \r\n      count: count,\r\n    }));\r\n\r\n  return locationsDto;\r\n}\r\n\r\nexport { getLocations }\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst db = require(\"../db/dbConnection\");\n// get messages\nfunction getMessages(username) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const database = db.getDb();\n        let messages = yield database.listMessages(username);\n        let messagesDto = messages.map(({ from, to, message, ts, guid, srcKey, dstKey, iv }) => ({\n            from,\n            to,\n            srcKey,\n            dstKey,\n            iv,\n            message,\n            ts,\n            guid,\n        }));\n        return messagesDto;\n    });\n}\nexport { getMessages };\n","\r\nconst db = require('../db/dbConnection');\r\n\r\n// get posts \r\nasync function getPosts(query) {\r\n  const database = db.getDb();\r\n\r\n  let posts;\r\n  if (!query) {\r\n    posts = await database.listPosts();\r\n  }\r\n  else {\r\n    posts = await database.listPosts(query);\r\n  }\r\n\r\n  let postsDto = posts.map(\r\n    ({ from, ts, guid, title, price, description, category, subcategory, location, sublocation }) => \r\n    ({ \r\n      from: from, \r\n      ts: ts,\r\n      guid: guid,\r\n      title: title,\r\n      price: price,\r\n      description: description,\r\n      category: category,\r\n      subcategory: subcategory,\r\n      location: location,\r\n      sublocation: sublocation\r\n    }));\r\n\r\n  return postsDto;\r\n}\r\n\r\nexport { getPosts }\r\n","\r\nconst db = require('../db/dbConnection');\r\n\r\n// get subcategories \r\nasync function getSubcategories() {\r\n  const database = db.getDb();\r\n\r\n  let subcategories = await database.listSubcategories();\r\n\r\n  let subcategoriesDto = subcategories.map(\r\n    ({ subcategory, count }) => \r\n    ({ \r\n      name: subcategory, \r\n      count: count,\r\n    }));\r\n\r\n  return subcategoriesDto;\r\n}\r\n\r\nexport { getSubcategories }\r\n","\r\nconst db = require('../db/dbConnection');\r\n\r\n// get sublocations\r\nasync function getSublocations() {\r\n  const database = db.getDb();\r\n\r\n  let sublocations = await database.listSublocations();\r\n\r\n  let sublocationsDto = sublocations.map(\r\n    ({ sublocation, count }) => \r\n    ({ \r\n      name: sublocation, \r\n      count: count,\r\n    }));\r\n\r\n  return sublocationsDto;\r\n}\r\n\r\nexport { getSublocations }\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst db = require(\"../db/dbConnection\");\n// get name\nfunction getUser(username, stakeAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const database = db.getDb();\n        let user;\n        if (stakeAddress)\n            user = yield database.findUserByStakeAddr(stakeAddress);\n        else\n            user = yield database.findUserByName(username);\n        if (!user) {\n            return null;\n        }\n        let userDto = {\n            user: user.user,\n            userinfo: user.userinfo,\n            stakeAddress: user.stakeAddress,\n            publicKey: user.publicKey,\n            ts: user.ts,\n        };\n        return userDto;\n    });\n}\nexport { getUser };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addRoute } from './addRoute.js';\nimport { precache } from './precache.js';\nimport './_version.js';\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * {@link workbox-precaching.precache} and\n * {@link workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See the\n * {@link workbox-precaching.PrecacheRoute} options.\n *\n * @memberof workbox-precaching\n */\nfunction precacheAndRoute(entries, options) {\n    precache(entries);\n    addRoute(options);\n}\nexport { precacheAndRoute };\n","\nimport { precacheAndRoute } from 'workbox-precaching';\n// import { storeDataInPouchDB, getCachedDataFromPouchDB } from './pouchdb-utils';\n\n// import { populateDb } from './api/data-gatherer';\nimport { getCategories } from './api/categories';\nimport { getConfig } from './api/config';\nimport { getLocations } from './api/locations';\nimport { getMessages } from './api/messages';\nimport { getPosts } from './api/posts';\nimport { getSubcategories } from './api/subcategories';\nimport { getSublocations } from './api/sublocations';\nimport { getUser } from './api/users';\n\n// importScripts('https://cdn.jsdelivr.net/npm/pouchdb@7.3.1/dist/pouchdb.min.js');\n\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith((async () => {\n\n    console.log('service-worker: ' + event.request.url);\n    if (!event.request.url.includes(\"/api/\")) {\n      return fetch(event.request);\n    }\n    if (event.request.url.includes(\"blockfrost.\")) {\n      return fetch(event.request);\n    }\n    if (event.request.url.includes(\"koios.rest\")) {\n      return await fetch(event.request);\n    }\n\n    console.log('Service Worker intercepted a fetch event:', event.request.url);\n\n    let data = {};\n\n    if (event.request.url.includes(\"/api/categories\")) {\n      data = await getCategories();\n    } else if (event.request.url.includes(\"/api/config\")) {\n      data = await getConfig();\n    } else if (event.request.url.includes(\"/api/location\")) {\n      data = await getLocations();\n    } else if (event.request.url.includes(\"/api/messages\")) {\n      data = await getMessages();\n    } else if (event.request.url.includes(\"/api/posts\")) {\n      data = await getPosts();\n    } else if (event.request.url.includes(\"/api/subcategories\")) {\n      data = await getSubcategories();\n    } else if (event.request.url.includes(\"/api/sublocation\")) {\n      data = await getSublocations();\n    } else if (event.request.url.includes(\"/api/users\")) {\n      data = await getUser();\n    } else {\n      console.log(\"NO ENDPOINT FOUND FOR: \" + event.request.url);\n    }\n\n    console.log(JSON.stringify(data));\n    const response = new Response(JSON.stringify(data), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    });\n\n    return response;\n\n  })());\n});\n\n\n    /* event.respondWith(\n        caches.match(event.request).then((response) => {\n            return response || fetch(event.request);\n        })\n    ); */\n\n/*let page = 1;\n\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    async () => {\n      console.log(\"ACTIVATE\");\n      page = await populateDb(page);\n    });\n});*/\n\n\nprecacheAndRoute(self.__WB_MANIFEST);\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * {@link workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * {@link workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @memberof workbox-precaching\n */\nfunction precache(entries) {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.precache(entries);\n}\nexport { precache };\n"]}